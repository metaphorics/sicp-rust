<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<!-- Created by GNU Texinfo 7.1, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>2.2 (Structure and Interpretation of Computer Programs, 2e)</title>

<meta name="description" content="2.2 (Structure and Interpretation of Computer Programs, 2e)" />
<meta name="keywords" content="2.2 (Structure and Interpretation of Computer Programs, 2e)" />
<meta name="resource-type" content="document" />
<meta name="distribution" content="global" />
<meta name="Generator" content="texi2any" />
<meta name="viewport" content="width=device-width,initial-scale=1" />

<link href="index.xhtml" rel="start" title="Top" />
<link href="Term-Index.xhtml" rel="index" title="Term Index" />
<link href="index.xhtml#SEC_Contents" rel="contents" title="Table of Contents" />
<link href="Chapter-2.xhtml" rel="up" title="Chapter 2" />
<link href="2_002e3.xhtml#g_t2_002e3" rel="next" title="2.3" />
<link href="2_002e1.xhtml#g_t2_002e1" rel="prev" title="2.1" />
<style type="text/css">
<!--
a.copiable-link {visibility: hidden; text-decoration: none; line-height: 0em}
div.example {margin-left: 3.2em}
span:hover a.copiable-link {visibility: visible}
ul.mark-bullet {list-style-type: disc}
-->
</style>

<script src="js/jquery.min.js" type="text/javascript"></script>
<script src="js/footnotes.js" type="text/javascript"></script>
<script src="js/browsertest.js" type="text/javascript"></script>
</head>

<body lang="en">
<div class="section-level-extent" id="g_t2_002e2">
<div class="nav-panel">
<p>
Next: <a href="2_002e3.xhtml#g_t2_002e3" accesskey="n" rel="next">Symbolic Data</a>, Previous: <a href="2_002e1.xhtml#g_t2_002e1" accesskey="p" rel="prev">Introduction to Data Abstraction</a>, Up: <a href="Chapter-2.xhtml" accesskey="u" rel="up">Building Abstractions with Data</a> &#160; [<a href="index.xhtml#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Term-Index.xhtml" title="Index" rel="index">Index</a>]</p>
</div>
<h3 class="section" id="Hierarchical-Data-and-the-Closure-Property"><span>2.2 Hierarchical Data and the Closure Property<a class="copiable-link" href="#Hierarchical-Data-and-the-Closure-Property"> &#182;</a></span></h3>

<p>As we have seen, pairs provide a primitive &#8220;glue&#8221; that we can use to
construct compound data objects.  <a class="ref" href="#Figure-2_002e2">Figure 2.2</a> shows a standard way to
visualize a pair&#8212;in this case, the pair formed by <code class="code">(cons 1 2)</code>.  In this
representation, which is called <a class="index-entry-id" id="index-box_002dand_002dpointer-notation"></a>
<em class="dfn">box-and-pointer notation</em>, each object
is shown as a <a class="index-entry-id" id="index-pointer"></a>
<em class="dfn">pointer</em> to a box.  The box for a primitive object
contains a representation of the object.  For example, the box for a number
contains a numeral.  The box for a pair is actually a double box, the left part
containing (a pointer to) the <code class="code">car</code> of the pair and the right part
containing the <code class="code">cdr</code>.
</p>
<div class="float">
<a class="anchor" id="Figure-2_002e2"></a><img class="image" src="fig/chap2/Fig2.2e.std.svg" alt="fig/chap2/Fig2.2e" />
<div class="caption"><p><strong class="strong">Figure 2.2:</strong> Box-and-pointer representation of <code class="code">(cons 1 2)</code>.</p></div></div>
<p>We have already seen that <code class="code">cons</code> can be used to combine not only numbers
but pairs as well.  (You made use of this fact, or should have, in doing
<a class="ref" href="2_002e1.xhtml#Exercise-2_002e2">Exercise 2.2</a> and <a class="ref" href="2_002e1.xhtml#Exercise-2_002e3">Exercise 2.3</a>.)  As a consequence, pairs provide a
universal building block from which we can construct all sorts of data
structures.  <a class="ref" href="#Figure-2_002e3">Figure 2.3</a> shows two ways to use pairs to combine the
numbers 1, 2, 3, and 4.
</p>
<div class="float">
<a class="anchor" id="Figure-2_002e3"></a><img class="image" src="fig/chap2/Fig2.3e.std.svg" alt="fig/chap2/Fig2.3e" />
<div class="caption"><p><strong class="strong">Figure 2.3:</strong> Two ways to combine 1, 2, 3, and 4 using pairs.</p></div></div>
<p>The ability to create pairs whose elements are pairs is the essence of list
structure&#8217;s importance as a representational tool.  We refer to this ability as
the <a class="index-entry-id" id="index-closure-property"></a>
<em class="dfn">closure property</em> of <code class="code">cons</code>.  In general, an operation for
combining data objects satisfies the closure property if the results of
combining things with that operation can themselves be combined using the same
operation.<a class="footnote" id="DOCF67" href="#FOOT67"><sup>67</sup></a> Closure
is the key to power in any means of combination because it permits us to create
<a class="index-entry-id" id="index-hierarchical"></a>
<em class="dfn">hierarchical</em> structures&#8212;structures made up of parts, which
themselves are made up of parts, and so on.
</p>
<p>From the outset of <a class="ref" href="Chapter-1.xhtml">Building Abstractions with Procedures</a>, we&#8217;ve made essential use of closure in
dealing with procedures, because all but the very simplest programs rely on the
fact that the elements of a combination can themselves be combinations.  In
this section, we take up the consequences of closure for compound data.  We
describe some conventional techniques for using pairs to represent sequences
and trees, and we exhibit a graphics language that illustrates closure in a
vivid way.<a class="footnote" id="DOCF68" href="#FOOT68"><sup>68</sup></a>
</p>

<hr />
<div class="subsection-level-extent" id="g_t2_002e2_002e1">
<h4 class="subsection" id="Representing-Sequences"><span>2.2.1 Representing Sequences<a class="copiable-link" href="#Representing-Sequences"> &#182;</a></span></h4>

<p>One of the useful structures we can build with pairs is a
<a class="index-entry-id" id="index-sequence"></a>
<em class="dfn">sequence</em>&#8212;an ordered collection of data objects.  There are, of
course, many ways to represent sequences in terms of pairs.  One particularly
straightforward representation is illustrated in <a class="ref" href="#Figure-2_002e4">Figure 2.4</a>, where the
sequence 1, 2, 3, 4 is represented as a chain of pairs.  The <code class="code">car</code> of each
pair is the corresponding item in the chain, and the <code class="code">cdr</code> of the pair is
the next pair in the chain.  The <code class="code">cdr</code> of the final pair signals the end
of the sequence by indicating the end with an empty slice or by using a
fixed-length collection. In Rust, we use <code class="code">Vec</code> for dynamic sequences:
</p>
<div class="example">
<pre class="example-preformatted">// In Rust, we use Vec for sequences
vec![1, 2, 3, 4]
</pre></div>

<div class="float">
<a class="anchor" id="Figure-2_002e4"></a><img class="image" src="fig/chap2/Fig2.4e.std.svg" alt="fig/chap2/Fig2.4e" />
<div class="caption"><p><strong class="strong">Figure 2.4:</strong> The sequence 1, 2, 3, 4 represented as a chain of pairs.</p></div></div>
<p>In Rust, such a sequence is called a <a class="index-entry-id" id="index-vector"></a>
<em class="dfn">vector</em>, created with the
<code class="code">vec!</code> macro.<a class="footnote" id="DOCF69" href="#FOOT69"><sup>69</sup></a>  The above sequence is written as:
</p>
<div class="example">
<pre class="example-preformatted">let one_through_four = vec![1, 2, 3, 4];
</pre></div>

<p>Rust displays vectors using debug formatting:
</p>
<div class="example">
<pre class="example-preformatted">let one_through_four = vec![1, 2, 3, 4];

println!(&quot;{:?}&quot;, one_through_four);
// =&gt; [1, 2, 3, 4]
</pre></div>

<p>We can think of <code class="code">first()</code> or indexing with <code class="code">[0]</code> as selecting the first item in the
list, and of <code class="code">&amp;list[1..]</code> as selecting the sublist consisting of all but the first
item.  For prepending an element, we can use <code class="code">concat</code> or build a new vector:<a class="footnote" id="DOCF70" href="#FOOT70"><sup>70</sup></a>
</p>
<div class="example">
<pre class="example-preformatted">let one_through_four = vec![1, 2, 3, 4];

one_through_four[0]
// =&gt; 1

&amp;one_through_four[1..]
// =&gt; [2, 3, 4]

one_through_four[1]  // second element
// =&gt; 2

// Prepend 10 to create new vector
[vec![10], one_through_four.clone()].concat()
// =&gt; [10, 1, 2, 3, 4]

// Or using iterators
std::iter::once(5).chain(one_through_four.iter().copied()).collect::&lt;Vec&lt;_&gt;&gt;()
// =&gt; [5, 1, 2, 3, 4]
</pre></div>

<p>The value of <code class="code">nil</code>, used to terminate the chain of pairs, can be thought
of as a sequence of no elements, the <a class="index-entry-id" id="index-empty-list"></a>
<em class="dfn">empty list</em>.  The word
<a class="index-entry-id" id="index-nil"></a>
<em class="dfn">nil</em> is a contraction of the Latin word <em class="emph">nihil</em>, which means
&#8220;nothing.&#8221;<a class="footnote" id="DOCF71" href="#FOOT71"><sup>71</sup></a>
</p>
<h4 class="subsubheading" id="List-operations"><span>List operations<a class="copiable-link" href="#List-operations"> &#182;</a></span></h4>

<p>The use of pairs to represent sequences of elements as lists is accompanied by
conventional programming techniques for manipulating lists by successively
&#8220;<code class="code">cdr</code>ing down&#8221; the lists.  For example, the procedure <code class="code">list-ref</code>
takes as arguments a list and a number <em class="math">n</em> and returns the <em class="math">n^{\text{th}}</em> item of
the list.  It is customary to number the elements of the list beginning with 0.
The method for computing <code class="code">list-ref</code> is the following:
</p>
<ul class="itemize mark-bullet">
<li>For <em class="math">{n = 0}</em>, we return the first element of the list.

</li><li>Otherwise, we return the <em class="math">{(n - 1)}</em>-st item of the
rest of the list.

</li></ul>

<p>In Rust, vectors provide direct indexing, so we simply use <code class="code">items[n]</code>:
</p>
<div class="example">
<pre class="example-preformatted">fn list_ref&lt;T: Clone&gt;(items: &amp;[T], n: usize) -&gt; T {
    items[n].clone()
}

let squares = vec![1, 4, 9, 16, 25];

list_ref(&amp;squares, 3)
// =&gt; 16

// Or simply use indexing directly:
squares[3]
// =&gt; 16
</pre></div>

<p>To get the length of a list, Rust provides the <code class="code">len()</code> method.
Here&#8217;s a recursive implementation that mirrors the Scheme version:
</p>
<div class="example">
<pre class="example-preformatted">fn length&lt;T&gt;(items: &amp;[T]) -&gt; usize {
    if items.is_empty() {
        0
    } else {
        1 + length(&amp;items[1..])
    }
}

let odds = vec![1, 3, 5, 7];

length(&amp;odds)
// =&gt; 4

// Or simply use the built-in method:
odds.len()
// =&gt; 4
</pre></div>

<p>The <code class="code">length</code> procedure implements a simple recursive plan. The reduction
step is:
</p>
<ul class="itemize mark-bullet">
<li>The <code class="code">length</code> of any list is 1 plus the <code class="code">length</code> of the <code class="code">cdr</code> of
the list.

</li></ul>

<p>This is applied successively until we reach the base case:
</p>
<ul class="itemize mark-bullet">
<li>The <code class="code">length</code> of the empty list is 0.

</li></ul>

<p>We could also compute <code class="code">length</code> in an iterative style using <code class="code">fold</code>:
</p>
<div class="example">
<pre class="example-preformatted">fn length_iter&lt;T&gt;(items: &amp;[T]) -&gt; usize {
    items.iter().fold(0, |count, _| count + 1)
}
</pre></div>

<p>Another conventional programming technique is to build up an answer
vector while iterating through a list, as in concatenation, which
takes two lists as arguments and combines their elements to make a new list:
</p>
<div class="example">
<pre class="example-preformatted">let squares = vec![1, 4, 9, 16, 25];
let odds = vec![1, 3, 5, 7];

[squares.clone(), odds.clone()].concat()
// =&gt; [1, 4, 9, 16, 25, 1, 3, 5, 7]

[odds.clone(), squares.clone()].concat()
// =&gt; [1, 3, 5, 7, 1, 4, 9, 16, 25]
</pre></div>

<p>Here&#8217;s a recursive implementation that mirrors the Scheme version:
</p>
<div class="example">
<pre class="example-preformatted">fn append&lt;T: Clone&gt;(list1: &amp;[T], list2: &amp;[T]) -&gt; Vec&lt;T&gt; {
    if list1.is_empty() {
        list2.to_vec()
    } else {
        let mut result = vec![list1[0].clone()];
        result.extend(append(&amp;list1[1..], list2));
        result
    }
}
</pre></div>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-2_002e17"></a>Exercise 2.17:</strong> Define a function
<code class="code">last_element</code> that returns the last element of a
given (nonempty) list:
</p>
<div class="example">
<pre class="example-preformatted">fn last_element&lt;T: Clone&gt;(items: &amp;[T]) -&gt; T {
    items.last().unwrap().clone()
}

last_element(&amp;vec![23, 72, 149, 34])
// =&gt; 34
</pre></div>
</blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-2_002e18"></a>Exercise 2.18:</strong> Define a function <code class="code">reverse</code>
that takes a list as argument and returns a list of the same elements in
reverse order:
</p>
<div class="example">
<pre class="example-preformatted">fn reverse&lt;T: Clone&gt;(items: &amp;[T]) -&gt; Vec&lt;T&gt; {
    items.iter().rev().cloned().collect()
}

reverse(&amp;vec![1, 4, 9, 16, 25])
// =&gt; [25, 16, 9, 4, 1]
</pre></div>
</blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-2_002e19"></a>Exercise 2.19:</strong> Consider the change-counting
program of <a class="ref" href="1_002e2.xhtml#g_t1_002e2_002e2">Tree Recursion</a>.  It would be nice to be able to easily change
the currency used by the program, so that we could compute the number of ways
to change a British pound, for example.  As the program is written, the
knowledge of the currency is distributed partly into the procedure
<code class="code">first_denomination</code> and partly into the procedure <code class="code">count_change</code>
(which knows that there are five kinds of U.S. coins).  It would be nicer to be
able to supply a list of coins to be used for making change.
</p>
<p>We want to rewrite the function <code class="code">cc</code> so that its second argument is a
slice of the values of the coins to use rather than an integer specifying which
coins to use.  We could then have arrays that defined each kind of currency:
</p>
<div class="example">
<pre class="example-preformatted">const US_COINS: &amp;[i32] = &amp;[50, 25, 10, 5, 1];
const UK_COINS: &amp;[i32] = &amp;[100, 50, 20, 10, 5, 2, 1];
</pre></div>

<p>We could then call <code class="code">cc</code> as follows:
</p>
<div class="example">
<pre class="example-preformatted">cc(100, US_COINS)
// =&gt; 292
</pre></div>

<p>To do this will require changing the program <code class="code">cc</code> somewhat.  It will still
have the same form, but it will access its second argument differently, as
follows:
</p>
<div class="example">
<pre class="example-preformatted">fn cc(amount: i32, coin_values: &amp;[i32]) -&gt; i32 {
    if amount == 0 {
        1
    } else if amount &lt; 0 || coin_values.is_empty() {
        0
    } else {
        cc(amount, &amp;coin_values[1..])  // except first denomination
            + cc(amount - coin_values[0], coin_values)  // first denomination
    }
}
</pre></div>

<p>In Rust, <code class="code">coin_values[0]</code> gives the first denomination,
<code class="code">&amp;coin_values[1..]</code> gives all except the first, and
<code class="code">coin_values.is_empty()</code> tests if there are no more coins.
Does the order of the slice <code class="code">coin_values</code>
affect the answer produced by <code class="code">cc</code>?  Why or why not?
</p></blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-2_002e20"></a>Exercise 2.20:</strong> Functions like <code class="code">sum</code> and
<code class="code">product</code> take arbitrary numbers of arguments. In Rust, we handle this
with slices or iterators.  For instance, given the definition
</p>
<div class="example">
<pre class="example-preformatted">fn f(x: i32, y: i32, rest: &amp;[i32]) { /* body */ }
</pre></div>

<p>the function <code class="code">f</code> can be called with a slice for the remaining arguments.
If we call
</p>
<div class="example">
<pre class="example-preformatted">f(1, 2, &amp;[3, 4, 5, 6])
</pre></div>

<p>then in the body of <code class="code">f</code>, <code class="code">x</code> will be 1, <code class="code">y</code> will be 2, and
<code class="code">rest</code> will be the slice <code class="code">[3, 4, 5, 6]</code>.  Given the definition
</p>
<div class="example">
<pre class="example-preformatted">fn g(args: &amp;[i32]) { /* body */ }
</pre></div>

<p>the function <code class="code">g</code> can be called with zero or more arguments in a slice.
If we call
</p>
<div class="example">
<pre class="example-preformatted">g(&amp;[1, 2, 3, 4, 5, 6])
</pre></div>

<p>then in the body of <code class="code">g</code>, <code class="code">args</code> will be the slice <code class="code">[1, 2, 3, 4, 5, 6]</code>.
</p>
<p>Use slices and iterator methods to write a function <code class="code">same_parity</code> that takes a
slice of integers and returns a vector of all elements that have the same
even-odd parity as the first element.  For example,
</p>
<div class="example">
<pre class="example-preformatted">fn same_parity(items: &amp;[i32]) -&gt; Vec&lt;i32&gt; {
    let first = items[0];
    let parity = first % 2;
    items.iter()
        .filter(|&amp;&amp;x| x % 2 == parity)
        .copied()
        .collect()
}

same_parity(&amp;[1, 2, 3, 4, 5, 6, 7])
// =&gt; [1, 3, 5, 7]

same_parity(&amp;[2, 3, 4, 5, 6, 7])
// =&gt; [2, 4, 6]
</pre></div>
</blockquote>

<h4 class="subsubheading" id="Mapping-over-lists"><span>Mapping over lists<a class="copiable-link" href="#Mapping-over-lists"> &#182;</a></span></h4>

<p>One extremely useful operation is to apply some transformation to each element
in a list and generate the list of results.  For instance, the following
function scales each number in a list by a given factor:
</p>
<div class="example">
<pre class="example-preformatted">fn scale_list(items: &amp;[i32], factor: i32) -&gt; Vec&lt;i32&gt; {
    if items.is_empty() {
        vec![]
    } else {
        let mut result = vec![items[0] * factor];
        result.extend(scale_list(&amp;items[1..], factor));
        result
    }
}

scale_list(&amp;[1, 2, 3, 4, 5], 10)
// =&gt; [10, 20, 30, 40, 50]
</pre></div>

<p>We can abstract this general idea and capture it as a common pattern expressed
as a higher-order function, just as in <a class="ref" href="1_002e3.xhtml#g_t1_002e3">Formulating Abstractions with Higher-Order Procedures</a>.  The higher-order
operation here is the <code class="code">map</code> iterator adapter.  <code class="code">map</code> takes a closure
and returns an iterator that applies the closure to each element:<a class="footnote" id="DOCF72" href="#FOOT72"><sup>72</sup></a>
</p>
<div class="example">
<pre class="example-preformatted">// Rust provides map as an iterator method
vec![-10.0, 2.5, -11.6, 17.0].iter()
    .map(|x| x.abs())
    .collect::&lt;Vec&lt;_&gt;&gt;()
// =&gt; [10.0, 2.5, 11.6, 17.0]

vec![1, 2, 3, 4].iter()
    .map(|x| x * x)
    .collect::&lt;Vec&lt;_&gt;&gt;()
// =&gt; [1, 4, 9, 16]
</pre></div>

<p>Now we can give a cleaner definition of <code class="code">scale_list</code> using <code class="code">map</code>:
</p>
<div class="example">
<pre class="example-preformatted">fn scale_list(items: &amp;[i32], factor: i32) -&gt; Vec&lt;i32&gt; {
    items.iter().map(|x| x * factor).collect()
}
</pre></div>

<p><code class="code">Map</code> is an important construct, not only because it captures a common
pattern, but because it establishes a higher level of abstraction in dealing
with lists.  In the original definition of <code class="code">scale-list</code>, the recursive
structure of the program draws attention to the element-by-element processing
of the list.  Defining <code class="code">scale-list</code> in terms of <code class="code">map</code> suppresses that
level of detail and emphasizes that scaling transforms a list of elements to a
list of results.  The difference between the two definitions is not that the
computer is performing a different process (it isn&#8217;t) but that we think about
the process differently.  In effect, <code class="code">map</code> helps establish an abstraction
barrier that isolates the implementation of procedures that transform lists
from the details of how the elements of the list are extracted and combined.
Like the barriers shown in <a class="ref" href="2_002e1.xhtml#Figure-2_002e1">Figure 2.1</a>, this abstraction gives us the
flexibility to change the low-level details of how sequences are implemented,
while preserving the conceptual framework of operations that transform
sequences to sequences.  Section <a class="ref" href="#g_t2_002e2_002e3">Sequences as Conventional Interfaces</a> expands on this use of sequences
as a framework for organizing programs.
</p>
<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-2_002e21"></a>Exercise 2.21:</strong> The function <code class="code">square_list</code>
takes a slice of numbers as argument and returns a vector of the squares of those
numbers.
</p>
<div class="example">
<pre class="example-preformatted">square_list(&amp;[1, 2, 3, 4])
// =&gt; [1, 4, 9, 16]
</pre></div>

<p>Here are two different definitions of <code class="code">square_list</code>.  Complete both of
them by filling in the missing expressions:
</p>
<div class="example">
<pre class="example-preformatted">fn square_list(items: &amp;[i32]) -&gt; Vec&lt;i32&gt; {
    if items.is_empty() {
        vec![]
    } else {
        let mut result = vec![/* ?? */];
        result.extend(/* ?? */);
        result
    }
}

fn square_list(items: &amp;[i32]) -&gt; Vec&lt;i32&gt; {
    items.iter().map(/* ?? */).collect()
}
</pre></div>
</blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-2_002e22"></a>Exercise 2.22:</strong> Louis Reasoner tries to rewrite
the first <code class="code">square_list</code> function of <a class="ref" href="#Exercise-2_002e21">Exercise 2.21</a> so that it
evolves an iterative process:
</p>
<div class="example">
<pre class="example-preformatted">fn square_list(items: &amp;[i32]) -&gt; Vec&lt;i32&gt; {
    fn iter(things: &amp;[i32], mut answer: Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; {
        if things.is_empty() {
            answer
        } else {
            answer.insert(0, things[0] * things[0]);  // prepend
            iter(&amp;things[1..], answer)
        }
    }
    iter(items, vec![])
}
</pre></div>

<p>Unfortunately, defining <code class="code">square_list</code> this way produces the answer list in
the reverse order of the one desired.  Why?
</p>
<p>Louis then tries to fix his bug by pushing to the end instead:
</p>
<div class="example">
<pre class="example-preformatted">fn square_list(items: &amp;[i32]) -&gt; Vec&lt;i32&gt; {
    fn iter(things: &amp;[i32], mut answer: Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; {
        if things.is_empty() {
            answer
        } else {
            answer.push(things[0] * things[0]);  // append
            iter(&amp;things[1..], answer)
        }
    }
    iter(items, vec![])
}
</pre></div>

<p>This actually works in Rust! But if we were constrained to only prepend, explain
why the original approach produces reversed output.
</p></blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-2_002e23"></a>Exercise 2.23:</strong> Rust&#8217;s <code class="code">for_each</code> iterator method is
similar to <code class="code">map</code>.  It takes a closure and applies it to each element in turn.
However, rather than producing an iterator of results, <code class="code">for_each</code>
just applies the closure for its side effects.
<code class="code">for_each</code> is used with closures that perform an action, such as
printing.  For example,
</p>
<div class="example">
<pre class="example-preformatted">[57, 321, 88].iter().for_each(|x| println!(&quot;{}&quot;, x));
// Output:
// 57
// 321
// 88
</pre></div>

<p>Implement a function <code class="code">for_each</code> that takes a closure and a slice,
applying the closure to each element.
</p></blockquote>

<hr />
</div>
<div class="subsection-level-extent" id="g_t2_002e2_002e2">
<h4 class="subsection" id="Hierarchical-Structures"><span>2.2.2 Hierarchical Structures<a class="copiable-link" href="#Hierarchical-Structures"> &#182;</a></span></h4>

<p>The representation of sequences in terms of vectors generalizes naturally to
represent sequences whose elements may themselves be sequences.  For example,
we can represent nested data using Rust&#8217;s <code class="code">enum</code> types or nested vectors:
</p>
<div class="example">
<pre class="example-preformatted">// Using nested vectors (dynamic)
let nested: Vec&lt;Vec&lt;i32&gt;&gt; = vec![vec![1, 2], vec![3, 4]];

// Or using an enum for mixed structures
#[derive(Debug)]
enum NestedList {
    Elem(i32),
    List(Vec&lt;NestedList&gt;),
}
use NestedList::*;

let x = List(vec![List(vec![Elem(1), Elem(2)]), Elem(3), Elem(4)]);
// Represents ((1 2) 3 4)
</pre></div>

<p>as a list of three items, the first of which is itself a list, <code class="code">(1 2)</code>.
Indeed, this is suggested by the form in which the result is printed by the
interpreter.  <a class="ref" href="#Figure-2_002e5">Figure 2.5</a> shows the representation of
this structure in terms of pairs.
</p>
<div class="float">
<a class="anchor" id="Figure-2_002e5"></a><img class="image" src="fig/chap2/Fig2.5e.std.svg" alt="fig/chap2/Fig2.5e" />
<div class="caption"><p><strong class="strong">Figure 2.5:</strong> Structure formed by <code class="code">(cons (list 1 2) (list 3 4))</code>.</p></div></div>
<p>Another way to think of sequences whose elements are sequences is as
<a class="index-entry-id" id="index-trees"></a>
<em class="dfn">trees</em>.  The elements of the sequence are the branches of the tree,
and elements that are themselves sequences are subtrees.  <a class="ref" href="#Figure-2_002e6">Figure 2.6</a>
shows the structure in <a class="ref" href="#Figure-2_002e5">Figure 2.5</a> viewed as a tree.
</p>
<div class="float">
<a class="anchor" id="Figure-2_002e6"></a><img class="image" src="fig/chap2/Fig2.6b.std.svg" alt="fig/chap2/Fig2.6b" />
<div class="caption"><p><strong class="strong">Figure 2.6:</strong> The list structure in <a class="ref" href="#Figure-2_002e5">Figure 2.5</a> viewed as a tree.</p></div></div>
<p>Recursion is a natural tool for dealing with tree structures, since we can
often reduce operations on trees to operations on their branches, which reduce
in turn to operations on the branches of the branches, and so on, until we
reach the leaves of the tree.  As an example, compare vector&#8217;s <code class="code">len()</code>
method with the <code class="code">count_leaves</code> function, which
returns the total number of leaves of a tree:
</p>
<div class="example">
<pre class="example-preformatted">use NestedList::*;

// x = ((1 2) 3 4)
let x = List(vec![List(vec![Elem(1), Elem(2)]), Elem(3), Elem(4)]);

// length of top level (3 items)
fn length(list: &amp;NestedList) -&gt; usize {
    match list {
        Elem(_) =&gt; 1,
        List(items) =&gt; items.len(),
    }
}

length(&amp;x)
// =&gt; 3

fn count_leaves(tree: &amp;NestedList) -&gt; usize {
    match tree {
        Elem(_) =&gt; 1,
        List(items) =&gt; items.iter().map(count_leaves).sum(),
    }
}

count_leaves(&amp;x)
// =&gt; 4

// (list x x) = (((1 2) 3 4) ((1 2) 3 4))
let xx = List(vec![x.clone(), x.clone()]);

length(&amp;xx)
// =&gt; 2

count_leaves(&amp;xx)
// =&gt; 8
</pre></div>

<p>To implement <code class="code">count-leaves</code>, recall the recursive plan for computing
<code class="code">length</code>:
</p>
<ul class="itemize mark-bullet">
<li><code class="code">Length</code> of a list <code class="code">x</code> is 1 plus <code class="code">length</code> of the
<code class="code">cdr</code> of <code class="code">x</code>.

</li><li><code class="code">Length</code> of the empty list is 0.

</li></ul>

<p><code class="code">Count-leaves</code> is similar.  The value for the empty list is the same:
</p>
<ul class="itemize mark-bullet">
<li><code class="code">Count-leaves</code> of the empty list is 0.

</li></ul>

<p>But in the reduction step, where we strip off the <code class="code">car</code> of the list, we
must take into account that the <code class="code">car</code> may itself be a tree whose leaves we
need to count.  Thus, the appropriate reduction step is
</p>
<ul class="itemize mark-bullet">
<li><code class="code">Count-leaves</code> of a tree <code class="code">x</code> is <code class="code">count-leaves</code> of the <code class="code">car</code>
of <code class="code">x</code> plus <code class="code">count-leaves</code> of the <code class="code">cdr</code> of <code class="code">x</code>.

</li></ul>

<p>Finally, by taking <code class="code">car</code>s we reach actual leaves, so we need another base
case:
</p>
<ul class="itemize mark-bullet">
<li><code class="code">Count-leaves</code> of a leaf is 1.

</li></ul>

<p>To aid in writing recursive functions on trees, Rust provides pattern matching
on enum variants.  Here is the complete function:
</p>
<div class="example">
<pre class="example-preformatted">fn count_leaves(tree: &amp;NestedList) -&gt; usize {
    match tree {
        Elem(_) =&gt; 1,
        List(items) if items.is_empty() =&gt; 0,
        List(items) =&gt; items.iter().map(count_leaves).sum(),
    }
}
</pre></div>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-2_002e24"></a>Exercise 2.24:</strong> Suppose we create
<code class="code">List(vec![Elem(1), List(vec![Elem(2), List(vec![Elem(3), Elem(4)])])])</code>.
Give the result printed by debug formatting, the corresponding structure, and the
interpretation of this as a tree (as in <a class="ref" href="#Figure-2_002e6">Figure 2.6</a>).
</p></blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-2_002e25"></a>Exercise 2.25:</strong> Give combinations of indexing
that will pick 7 from each of the following structures:
</p>
<div class="example">
<pre class="example-preformatted">// (1 3 (5 7) 9) as nested vector
let a: Vec&lt;Vec&lt;i32&gt;&gt; = vec![vec![1], vec![3], vec![5, 7], vec![9]];
// How to get 7?

// ((7))
let b = vec![vec![7]];
// How to get 7?

// Deeply nested
let c = vec![1, vec![2, vec![3, vec![4, vec![5, vec![6, 7]]]]]];
// (Requires NestedList enum for mixed types)
</pre></div>
</blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-2_002e26"></a>Exercise 2.26:</strong> Suppose we define <code class="code">x</code> and
<code class="code">y</code> to be two vectors:
</p>
<div class="example">
<pre class="example-preformatted">let x = vec![1, 2, 3];
let y = vec![4, 5, 6];
</pre></div>

<p>What result is produced by evaluating each of the following expressions:
</p>
<div class="example">
<pre class="example-preformatted">[x.clone(), y.clone()].concat()  // append
// =&gt; ?

vec![x.clone(), y.clone()]       // as nested
// =&gt; ?

// What's the difference?
</pre></div>
</blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-2_002e27"></a>Exercise 2.27:</strong> Modify your <code class="code">reverse</code>
function of <a class="ref" href="#Exercise-2_002e18">Exercise 2.18</a> to produce a <code class="code">deep_reverse</code> function
that takes a tree as argument and returns as its value the tree with its
elements reversed and with all subtrees deep-reversed as well.  For example,
</p>
<div class="example">
<pre class="example-preformatted">// x = ((1 2) (3 4))
let x = List(vec![
    List(vec![Elem(1), Elem(2)]),
    List(vec![Elem(3), Elem(4)])
]);

// reverse: ((3 4) (1 2))
// deep_reverse: ((4 3) (2 1))

fn deep_reverse(tree: &amp;NestedList) -&gt; NestedList {
    match tree {
        Elem(n) =&gt; Elem(*n),
        List(items) =&gt; List(
            items.iter()
                .rev()
                .map(deep_reverse)
                .collect()
        ),
    }
}
</pre></div>
</blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-2_002e28"></a>Exercise 2.28:</strong> Write a function <code class="code">fringe</code>
that takes a tree and returns a vector whose
elements are all the leaves of the tree arranged in left-to-right order.  For
example,
</p>
<div class="example">
<pre class="example-preformatted">fn fringe(tree: &amp;NestedList) -&gt; Vec&lt;i32&gt; {
    match tree {
        Elem(n) =&gt; vec![*n],
        List(items) =&gt; items.iter().flat_map(fringe).collect(),
    }
}

// x = ((1 2) (3 4))
fringe(&amp;x)
// =&gt; [1, 2, 3, 4]

fringe(&amp;List(vec![x.clone(), x.clone()]))
// =&gt; [1, 2, 3, 4, 1, 2, 3, 4]
</pre></div>
</blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-2_002e29"></a>Exercise 2.29:</strong> A binary mobile consists of two
branches, a left branch and a right branch.  Each branch is a rod of a certain
length, from which hangs either a weight or another binary mobile.  We can
represent a binary mobile using Rust structs and enums:
</p>
<div class="example">
<pre class="example-preformatted">struct Mobile {
    left: Branch,
    right: Branch,
}

struct Branch {
    length: f64,
    structure: Structure,
}

enum Structure {
    Weight(f64),
    SubMobile(Box&lt;Mobile&gt;),
}
</pre></div>

<ol class="enumerate" type="a" start="1">
<li> The selectors are automatically available as struct field access:
<code class="code">mobile.left</code>, <code class="code">mobile.right</code>, <code class="code">branch.length</code>, and
<code class="code">branch.structure</code>.

</li><li> Using pattern matching, define a function <code class="code">total_weight</code> that returns the
total weight of a mobile.

</li><li> A mobile is said to be <a class="index-entry-id" id="index-balanced"></a>
<em class="dfn">balanced</em> if the torque applied by its top-left
branch is equal to that applied by its top-right branch (that is, if the length
of the left rod multiplied by the weight hanging from that rod is equal to the
corresponding product for the right side) and if each of the submobiles hanging
off its branches is balanced. Design a function that tests whether a binary
mobile is balanced.

</li><li> In Rust, changing from a struct with two fields to a tuple struct requires
updating all field access from <code class="code">.left/.right</code> to <code class="code">.0/.1</code>. How does
Rust&#8217;s struct system compare to Scheme&#8217;s approach?

</li></ol>
</blockquote>

<h4 class="subsubheading" id="Mapping-over-trees"><span>Mapping over trees<a class="copiable-link" href="#Mapping-over-trees"> &#182;</a></span></h4>

<p>Just as <code class="code">map</code> is a powerful abstraction for dealing with sequences,
<code class="code">map</code> together with recursion is a powerful abstraction for dealing with
trees.  For instance, the <code class="code">scale_tree</code> function, analogous to
<code class="code">scale_list</code> of <a class="ref" href="#g_t2_002e2_002e1">Representing Sequences</a>, takes as arguments a numeric factor
and a tree whose leaves are numbers.  It returns a tree of the same shape,
where each number is multiplied by the factor.  The recursive plan for
<code class="code">scale_tree</code> is similar to the one for <code class="code">count_leaves</code>:
</p>
<div class="example">
<pre class="example-preformatted">fn scale_tree(tree: &amp;NestedList, factor: i32) -&gt; NestedList {
    match tree {
        Elem(n) =&gt; Elem(n * factor),
        List(items) =&gt; List(
            items.iter()
                .map(|t| scale_tree(t, factor))
                .collect()
        ),
    }
}

// (1 (2 (3 4) 5) (6 7))
let tree = List(vec![
    Elem(1),
    List(vec![Elem(2), List(vec![Elem(3), Elem(4)]), Elem(5)]),
    List(vec![Elem(6), Elem(7)])
]);

scale_tree(&amp;tree, 10)
// =&gt; (10 (20 (30 40) 50) (60 70))
</pre></div>

<p>This implementation uses pattern matching to handle both leaves (which are scaled
directly) and branches (which recursively scale their children). The iterator&#8217;s
<code class="code">map</code> method applies the scaling transformation to each subtree.
</p>
<p>Many tree operations can be implemented by similar combinations of iterator
methods and recursion.
</p>
<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-2_002e30"></a>Exercise 2.30:</strong> Define a function
<code class="code">square_tree</code> analogous to the <code class="code">square_list</code> function of
<a class="ref" href="#Exercise-2_002e21">Exercise 2.21</a>.  That is, <code class="code">square_tree</code> should behave as follows:
</p>
<div class="example">
<pre class="example-preformatted">// (1 (2 (3 4) 5) (6 7))
square_tree(&amp;tree)
// =&gt; (1 (4 (9 16) 25) (36 49))
</pre></div>

<p>Define <code class="code">square_tree</code> both directly (i.e., without using <code class="code">map</code>)
and also by using <code class="code">map</code> and recursion.
</p></blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-2_002e31"></a>Exercise 2.31:</strong> Abstract your answer to
<a class="ref" href="#Exercise-2_002e30">Exercise 2.30</a> to produce a function <code class="code">tree_map</code> with the property
that <code class="code">square_tree</code> could be defined as
</p>
<div class="example">
<pre class="example-preformatted">fn square_tree(tree: &amp;NestedList) -&gt; NestedList {
    tree_map(|n| n * n, tree)
}
</pre></div>
</blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-2_002e32"></a>Exercise 2.32:</strong> We can represent a set as a vector
of distinct elements, and we can represent the set of all subsets of the set as
a vector of vectors.  For example, if the set is <code class="code">[1, 2, 3]</code>, then the set of
all subsets is <code class="code">[[], [3], [2], [2, 3], [1], [1, 3], [1, 2], [1, 2, 3]]</code>.
Complete the following definition of a function that generates the set of subsets
and give a clear explanation of why it works:
</p>
<div class="example">
<pre class="example-preformatted">fn subsets(s: &amp;[i32]) -&gt; Vec&lt;Vec&lt;i32&gt;&gt; {
    if s.is_empty() {
        vec![vec![]]
    } else {
        let rest = subsets(&amp;s[1..]);
        let with_first: Vec&lt;Vec&lt;i32&gt;&gt; = rest.iter()
            .map(|subset| /* ?? */)
            .collect();
        [rest, with_first].concat()
    }
}
</pre></div>
</blockquote>

<hr />
</div>
<div class="subsection-level-extent" id="g_t2_002e2_002e3">
<h4 class="subsection" id="Sequences-as-Conventional-Interfaces"><span>2.2.3 Sequences as Conventional Interfaces<a class="copiable-link" href="#Sequences-as-Conventional-Interfaces"> &#182;</a></span></h4>

<p>In working with compound data, we&#8217;ve stressed how data abstraction permits us
to design programs without becoming enmeshed in the details of data
representations, and how abstraction preserves for us the flexibility to
experiment with alternative representations.  In this section, we introduce
another powerful design principle for working with data structures&#8212;the use of
<a class="index-entry-id" id="index-conventional-interfaces-1"></a>
<em class="dfn">conventional interfaces</em>.
</p>
<p>In <a class="ref" href="1_002e3.xhtml#g_t1_002e3">Formulating Abstractions with Higher-Order Procedures</a> we saw how program abstractions, implemented as
higher-order procedures, can capture common patterns in programs that deal with
numerical data.  Our ability to formulate analogous operations for working with
compound data depends crucially on the style in which we manipulate our data
structures.  Consider, for example, the following procedure, analogous to the
<code class="code">count-leaves</code> procedure of <a class="ref" href="#g_t2_002e2_002e2">Hierarchical Structures</a>, which takes a tree as
argument and computes the sum of the squares of the leaves that are odd:
</p>
<div class="example">
<pre class="example-preformatted">fn sum_odd_squares(tree: &amp;NestedList) -&gt; i32 {
    match tree {
        Elem(n) =&gt; if n % 2 != 0 { n * n } else { 0 },
        List(items) =&gt; items.iter()
            .map(sum_odd_squares)
            .sum(),
    }
}
</pre></div>

<p>On the surface, this procedure is very different from the following one, which
constructs a list of all the even Fibonacci numbers <em class="math">{\text{Fib}(k)}</em>, where
<em class="math">k</em> is less than or equal to a given integer <em class="math">n</em>:
</p>
<div class="example">
<pre class="example-preformatted">fn even_fibs(n: u32) -&gt; Vec&lt;u64&gt; {
    (0..=n)
        .map(fib)
        .filter(|f| f % 2 == 0)
        .collect()
}
</pre></div>

<p>Despite the fact that these two procedures are structurally very different, a
more abstract description of the two computations reveals a great deal of
similarity.  The first program
</p>
<ul class="itemize mark-bullet">
<li>enumerates the leaves of a tree;

</li><li>filters them, selecting the odd ones;

</li><li>squares each of the selected ones; and

</li><li>accumulates the results using <code class="code">+</code>, starting with 0.

</li></ul>

<p>The second program
</p>
<ul class="itemize mark-bullet">
<li>enumerates the integers from 0 to <em class="math">n</em>;

</li><li>computes the Fibonacci number for each integer;

</li><li>filters them, selecting the even ones; and

</li><li>accumulates the results using <code class="code">cons</code>,  starting with the
empty list.

</li></ul>

<p>A signal-processing engineer would find it natural to conceptualize these
processes in terms of signals flowing through a cascade of stages, each of
which implements part of the program plan, as shown in <a class="ref" href="#Figure-2_002e7">Figure 2.7</a>.  In
<code class="code">sum-odd-squares</code>, we begin with an <a class="index-entry-id" id="index-enumerator"></a>
<em class="dfn">enumerator</em>, which generates
a &#8220;signal&#8221; consisting of the leaves of a given tree.  This signal is passed
through a <a class="index-entry-id" id="index-filter-1"></a>
<em class="dfn">filter</em>, which eliminates all but the odd elements.  The
resulting signal is in turn passed through a <a class="index-entry-id" id="index-map"></a>
<em class="dfn">map</em>, which is a
&#8220;transducer&#8221; that applies the <code class="code">square</code> procedure to each element.  The
output of the map is then fed to an <a class="index-entry-id" id="index-accumulator"></a>
<em class="dfn">accumulator</em>, which combines the
elements using <code class="code">+</code>, starting from an initial 0.  The plan for
<code class="code">even-fibs</code> is analogous.
</p>
<div class="float">
<a class="anchor" id="Figure-2_002e7"></a><img class="image" src="fig/chap2/Fig2.7e.std.svg" alt="fig/chap2/Fig2.7e" /> 
<div class="caption"><p><strong class="strong">Figure 2.7:</strong> The signal-flow plans for the procedures <code class="code">sum-odd-squares</code> (top) and <code class="code">even-fibs</code> (bottom) reveal the commonality between the two programs.</p></div></div>
<p>Unfortunately, the two procedure definitions above fail to exhibit this
signal-flow structure.  For instance, if we examine the <code class="code">sum-odd-squares</code>
procedure, we find that the enumeration is implemented partly by the
<code class="code">null?</code> and <code class="code">pair?</code> tests and partly by the tree-recursive structure
of the procedure.  Similarly, the accumulation is found partly in the tests and
partly in the addition used in the recursion.  In general, there are no
distinct parts of either procedure that correspond to the elements in the
signal-flow description.  Our two procedures decompose the computations in a
different way, spreading the enumeration over the program and mingling it with
the map, the filter, and the accumulation.  If we could organize our programs
to make the signal-flow structure manifest in the procedures we write, this
would increase the conceptual clarity of the resulting code.
</p>
<h4 class="subsubheading" id="Sequence-Operations"><span>Sequence Operations<a class="copiable-link" href="#Sequence-Operations"> &#182;</a></span></h4>

<p>The key to organizing programs so as to more clearly reflect the signal-flow
structure is to concentrate on the &#8220;signals&#8221; that flow from one stage in the
process to the next.  If we represent these signals as lists, then we can use
list operations to implement the processing at each of the stages.  For
instance, we can implement the mapping stages of the signal-flow diagrams using
the <code class="code">map</code> procedure from <a class="ref" href="#g_t2_002e2_002e1">Representing Sequences</a>:
</p>
<div class="example">
<pre class="example-preformatted">vec![1, 2, 3, 4, 5].iter().map(|x| x * x).collect::&lt;Vec&lt;_&gt;&gt;()
// =&gt; [1, 4, 9, 16, 25]
</pre></div>

<p>Filtering a sequence to select only those elements that satisfy a given
predicate is accomplished by
</p>
<div class="example">
<pre class="example-preformatted">// In Rust, filter is a built-in iterator adapter:
// sequence.iter().filter(predicate).collect()

// Here's the explicit recursive version for comparison:
fn filter&lt;T: Clone&gt;(predicate: impl Fn(&amp;T) -&gt; bool, sequence: &amp;[T]) -&gt; Vec&lt;T&gt; {
    match sequence {
        [] =&gt; vec![],
        [first, rest &#160;..] =&gt; {
            let mut result = filter(&amp;predicate, rest);
            if predicate(first) {
                result.insert(0, first.clone());
            }
            result
        }
    }
}
</pre></div>

<p>For example,
</p>
<div class="example">
<pre class="example-preformatted">vec![1, 2, 3, 4, 5].iter().filter(|&amp;x| x % 2 != 0).collect::&lt;Vec&lt;_&gt;&gt;()
// =&gt; [1, 3, 5]
</pre></div>

<p>Accumulations can be implemented by
</p>
<div class="example">
<pre class="example-preformatted">// In Rust, accumulate is called fold (left-fold) or rfold (right-fold).
// The Scheme version above is a right-fold.

fn accumulate&lt;T, R&gt;(
    op: impl Fn(T, R) -&gt; R,
    initial: R,
    sequence: impl DoubleEndedIterator&lt;Item = T&gt;,
) -&gt; R {
    sequence.rfold(initial, |acc, x| op(x, acc))
}

vec![1, 2, 3, 4, 5].iter().fold(0, |acc, x| acc + x)
// =&gt; 15

vec![1, 2, 3, 4, 5].iter().fold(1, |acc, x| acc * x)
// =&gt; 120

// For collect-like behavior, use collect directly:
vec![1, 2, 3, 4, 5].iter().cloned().collect::&lt;Vec&lt;_&gt;&gt;()
// =&gt; [1, 2, 3, 4, 5]
</pre></div>

<p>All that remains to implement signal-flow diagrams is to enumerate the sequence
of elements to be processed.  For <code class="code">even-fibs</code>, we need to generate the
sequence of integers in a given range, which we can do as follows:
</p>
<div class="example">
<pre class="example-preformatted">// In Rust, use range syntax directly:
(2..=7).collect::&lt;Vec&lt;_&gt;&gt;()
// =&gt; [2, 3, 4, 5, 6, 7]

// Or as a function for the explicit pattern:
fn enumerate_interval(low: i32, high: i32) -&gt; Vec&lt;i32&gt; {
    (low..=high).collect()
}
</pre></div>

<p>To enumerate the leaves of a tree, we can use<a class="footnote" id="DOCF73" href="#FOOT73"><sup>73</sup></a>
</p>
<div class="example">
<pre class="example-preformatted">fn enumerate_tree(tree: &amp;NestedList) -&gt; Vec&lt;i32&gt; {
    match tree {
        Elem(n) =&gt; vec![*n],
        List(items) =&gt; items.iter()
            .flat_map(enumerate_tree)
            .collect(),
    }
}

// List(vec![Elem(1), List(vec![Elem(2), List(vec![Elem(3), Elem(4)])]), Elem(5)])
enumerate_tree(&amp;tree)
// =&gt; [1, 2, 3, 4, 5]
</pre></div>

<p>Now we can reformulate <code class="code">sum-odd-squares</code> and <code class="code">even-fibs</code> as in the
signal-flow diagrams.  For <code class="code">sum-odd-squares</code>, we enumerate the sequence of
leaves of the tree, filter this to keep only the odd numbers in the sequence,
square each element, and sum the results:
</p>
<div class="example">
<pre class="example-preformatted">fn sum_odd_squares(tree: &amp;NestedList) -&gt; i32 {
    enumerate_tree(tree)
        .into_iter()
        .filter(|x| x % 2 != 0)
        .map(|x| x * x)
        .sum()
}
</pre></div>

<p>For <code class="code">even-fibs</code>, we enumerate the integers from 0 to <em class="math">n</em>, generate the
Fibonacci number for each of these integers, filter the resulting sequence to
keep only the even elements, and accumulate the results into a list:
</p>
<div class="example">
<pre class="example-preformatted">fn even_fibs(n: u32) -&gt; Vec&lt;u64&gt; {
    (0..=n)
        .map(fib)
        .filter(|f| f % 2 == 0)
        .collect()
}
</pre></div>

<p>The value of expressing programs as sequence operations is that this helps us
make program designs that are modular, that is, designs that are constructed by
combining relatively independent pieces.  We can encourage modular design by
providing a library of standard components together with a conventional
interface for connecting the components in flexible ways.
</p>
<p>Modular construction is a powerful strategy for controlling complexity in
engineering design.  In real signal-processing applications, for example,
designers regularly build systems by cascading elements selected from
standardized families of filters and transducers.  Similarly, sequence
operations provide a library of standard program elements that we can mix and
match.  For instance, we can reuse pieces from the <code class="code">sum-odd-squares</code> and
<code class="code">even-fibs</code> procedures in a program that constructs a list of the squares
of the first <em class="math">{n + 1}</em> Fibonacci numbers:
</p>
<div class="example">
<pre class="example-preformatted">fn list_fib_squares(n: u32) -&gt; Vec&lt;u64&gt; {
    (0..=n)
        .map(fib)
        .map(|f| f * f)
        .collect()
}

list_fib_squares(10)
// =&gt; [0, 1, 1, 4, 9, 25, 64, 169, 441, 1156, 3025]
</pre></div>

<p>We can rearrange the pieces and use them in computing the product of the squares of the odd
integers in a sequence:
</p>
<div class="example">
<pre class="example-preformatted">fn product_of_squares_of_odd_elements(sequence: &amp;[i64]) -&gt; i64 {
    sequence.iter()
        .filter(|&amp;x| x % 2 != 0)
        .map(|x| x * x)
        .product()
}

product_of_squares_of_odd_elements(&amp;[1, 2, 3, 4, 5])
// =&gt; 225  (1*1 * 3*3 * 5*5 = 1 * 9 * 25)
</pre></div>

<p>We can also formulate conventional data-processing applications in terms of
sequence operations.  Suppose we have a sequence of personnel records and we
want to find the salary of the highest-paid programmer.  Assume that we have a
selector <code class="code">salary</code> that returns the salary of a record, and a predicate
<code class="code">programmer?</code> that tests if a record is for a programmer.  Then we can
write
</p>
<div class="example">
<pre class="example-preformatted">fn salary_of_highest_paid_programmer(records: &amp;[Employee]) -&gt; u64 {
    records.iter()
        .filter(|r| r.is_programmer())
        .map(|r| r.salary())
        .max()
        .unwrap_or(0)
}
</pre></div>

<p>These examples give just a hint of the vast range of operations that can be
expressed as sequence operations.<a class="footnote" id="DOCF74" href="#FOOT74"><sup>74</sup></a>
</p>
<p>Sequences, implemented here as lists, serve as a conventional interface that
permits us to combine processing modules.  Additionally, when we uniformly
represent structures as sequences, we have localized the data-structure
dependencies in our programs to a small number of sequence operations.  By
changing these, we can experiment with alternative representations of
sequences, while leaving the overall design of our programs intact.  We will
exploit this capability in <a class="ref" href="3_002e5.xhtml#g_t3_002e5">Streams</a>, when we generalize the
sequence-processing paradigm to admit infinite sequences.
</p>
<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-2_002e33"></a>Exercise 2.33:</strong> Fill in the missing expressions
to complete the following definitions of some basic list-manipulation
operations as accumulations:
</p>
<div class="example">
<pre class="example-preformatted">// Fill in the blanks using fold/rfold:

fn map_via_fold&lt;T, R&gt;(
    p: impl Fn(&amp;T) -&gt; R,
    sequence: &amp;[T],
) -&gt; Vec&lt;R&gt; {
    sequence.iter().rfold(vec![], |mut acc, x| {
        acc.insert(0, p(x));  // ?? = prepend p(x) to result
        acc
    })
}

fn append_via_fold&lt;T: Clone&gt;(seq1: &amp;[T], seq2: &amp;[T]) -&gt; Vec&lt;T&gt; {
    seq1.iter().cloned()
        .rfold(seq2.to_vec(), |mut acc, x| {  // ?? = seq2, seq1
            acc.insert(0, x);
            acc
        })
}

fn length_via_fold&lt;T&gt;(sequence: &amp;[T]) -&gt; usize {
    sequence.iter().fold(0, |acc, _| acc + 1)  // ?? = |acc, _| acc + 1
}
</pre></div>
</blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-2_002e34"></a>Exercise 2.34:</strong> Evaluating a polynomial in <em class="math">x</em>
at a given value of <em class="math">x</em> can be formulated as an accumulation.  We evaluate
the polynomial
\[ % :35:
  {a_n x^n} + {a_{n-1} x^{n-1}} + \dots + {a_1 x} + a_0  \]
using a well-known algorithm called <a class="index-entry-id" id="index-Horner_0027s-rule"></a>
<em class="dfn">Horner&#8217;s rule</em>, which structures
the computation as
\[ % :36:
  {(\dots (a_n x} + {a_{n-1}) x} + \dots + {a_1) x} + {a_0.}  \]
In other words, we start with <em class="math">a_n</em>, multiply by <em class="math">x</em>, add
<em class="math">a_{n-1}</em>, multiply by <em class="math">x</em>, and so on, until we reach
<em class="math">a_0</em>.<a class="footnote" id="DOCF75" href="#FOOT75"><sup>75</sup></a>
</p>
<p>Fill in the following template to produce a procedure that evaluates a
polynomial using Horner&#8217;s rule.  Assume that the coefficients of the polynomial
are arranged in a sequence, from <em class="math">a_0</em> through <em class="math">a_n</em>.
</p>
<div class="example">
<pre class="example-preformatted">fn horner_eval(x: f64, coefficients: &amp;[f64]) -&gt; f64 {
    coefficients.iter().rfold(0.0, |higher_terms, &amp;this_coeff| {
        this_coeff + x * higher_terms  // ??
    })
}
</pre></div>

<p>For example, to compute <em class="math">{1 + 3x} + {5x^3 + x^5}</em> at <em class="math">{x = 2}</em> you
would evaluate
</p>
<div class="example">
<pre class="example-preformatted">horner_eval(2.0, &amp;[1.0, 3.0, 0.0, 5.0, 0.0, 1.0])
// =&gt; 79.0
</pre></div>
</blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-2_002e35"></a>Exercise 2.35:</strong> Redefine <code class="code">count-leaves</code> from
<a class="ref" href="#g_t2_002e2_002e2">Hierarchical Structures</a> as an accumulation:
</p>
<div class="example">
<pre class="example-preformatted">fn count_leaves(t: &amp;NestedList) -&gt; usize {
    // Using iterator combinators:
    enumerate_tree(t).len()  // enumerate flattens, then count

    // Or more explicitly via fold:
    // match t {
    //     Elem(_) =&gt; 1,
    //     List(items) =&gt; items.iter().map(count_leaves).sum(),
    // }
}
</pre></div>
</blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-2_002e36"></a>Exercise 2.36:</strong> The procedure <code class="code">accumulate-n</code>
is similar to <code class="code">accumulate</code> except that it takes as its third argument a
sequence of sequences, which are all assumed to have the same number of
elements.  It applies the designated accumulation procedure to combine all the
first elements of the sequences, all the second elements of the sequences, and
so on, and returns a sequence of the results.  For instance, if <code class="code">s</code> is a
sequence containing four sequences, <code class="code">((1 2 3) (4 5 6) (7 8 9) (10 11
12)),</code> then the value of <code class="code">(accumulate-n + 0 s)</code> should be the sequence
<code class="code">(22 26 30)</code>.  Fill in the missing expressions in the following definition
of <code class="code">accumulate-n</code>:
</p>
<div class="example">
<pre class="example-preformatted">fn accumulate_n&lt;T: Clone + Default&gt;(
    op: impl Fn(T, T) -&gt; T + Copy,
    init: T,
    seqs: &amp;[Vec&lt;T&gt;],
) -&gt; Vec&lt;T&gt; {
    if seqs[0].is_empty() {
        return vec![];
    }
    let firsts: Vec&lt;T&gt; = seqs.iter().map(|s| s[0].clone()).collect();
    let rests: Vec&lt;Vec&lt;T&gt;&gt; = seqs.iter().map(|s| s[1..].to_vec()).collect();

    let mut result = vec![firsts.into_iter().fold(init.clone(), &amp;op)];
    result.extend(accumulate_n(op, init, &amp;rests));
    result
}
// ?? = seqs.iter().map(|s| s[0]) for first elements
// ?? = seqs.iter().map(|s| &amp;s[1..]) for rest of each sequence
</pre></div>
</blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-2_002e37"></a>Exercise 2.37:</strong>
Suppose we represent vectors <b class="b">v</b> = <em class="math">{(v_i)}</em> as sequences of numbers, and
matrices <b class="b">m</b> = <em class="math">{(m_{ij})}</em> as sequences of vectors (the rows of the
matrix).  For example, the matrix
\[ % :37:
  
\left(\matrix{	1 &amp; 2 &amp; 3 &amp; 4 \cr
		4 &amp; 5 &amp; 6 &amp; 6 \cr
		6 &amp; 7 &amp; 8 &amp; 9 \cr }\right)  \]
is represented as the sequence <code class="code">((1 2 3 4) (4 5 6 6) (6 7 8 9))</code>.  With
this representation, we can use sequence operations to concisely express the
basic matrix and vector operations.  These operations (which are described in
any book on matrix algebra) are the following:
\[ % :38:
  
\eqalign{ 
	\text{(dot-product v w)} 	&amp; \text{returns the sum}\;\Sigma_i v_i w_i; \cr
	\text{(matrix-*-vector m v)} 	&amp; \text{returns the vector}\;{\bf t}, \cr
		&amp; \text{where}\; t_i = \Sigma_j m_{ij} v_j; \cr
	\text{(matrix-*-matrix m n)} 	&amp; \text{returns the matrix}\;{\bf p}, \cr
		&amp; \text{where}\; p_{ij} = \Sigma_k m_{ik} n_{kj}; \cr
	\text{(transpose m)} 		&amp; \text{returns the matrix}\;{\bf n}, \cr
		&amp; \text{where}\; n_{ij} = m_{ji}. \cr
}  \]
We can define the dot product as<a class="footnote" id="DOCF76" href="#FOOT76"><sup>76</sup></a>
</p>
<div class="example">
<pre class="example-preformatted">fn dot_product(v: &amp;[f64], w: &amp;[f64]) -&gt; f64 {
    v.iter().zip(w.iter()).map(|(a, b)| a * b).sum()
}
</pre></div>

<p>Fill in the missing expressions in the following procedures for computing the
other matrix operations.  (The procedure <code class="code">accumulate-n</code> is defined in
<a class="ref" href="#Exercise-2_002e36">Exercise 2.36</a>.)
</p>
<div class="example">
<pre class="example-preformatted">type Matrix = Vec&lt;Vec&lt;f64&gt;&gt;;
type Vector = Vec&lt;f64&gt;;

fn matrix_times_vector(m: &amp;Matrix, v: &amp;Vector) -&gt; Vector {
    m.iter()
        .map(|row| dot_product(row, v))  // ?? = |row| dot_product(row, v)
        .collect()
}

fn transpose(mat: &amp;Matrix) -&gt; Matrix {
    (0..mat[0].len())
        .map(|col| mat.iter().map(|row| row[col]).collect())
        .collect()  // ?? = cons, nil (collect columns)
}

fn matrix_times_matrix(m: &amp;Matrix, n: &amp;Matrix) -&gt; Matrix {
    let cols = transpose(n);
    m.iter()
        .map(|row| matrix_times_vector(&amp;cols, row))  // ??
        .map(|v| v.into_iter().collect())
        .collect()
}
</pre></div>
</blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-2_002e38"></a>Exercise 2.38:</strong> The <code class="code">accumulate</code> procedure
is also known as <code class="code">fold-right</code>, because it combines the first element of
the sequence with the result of combining all the elements to the right.  There
is also a <code class="code">fold-left</code>, which is similar to <code class="code">fold-right</code>, except that
it combines elements working in the opposite direction:
</p>
<div class="example">
<pre class="example-preformatted">// In Rust, this is the standard fold method:
fn fold_left&lt;T, R&gt;(
    op: impl Fn(R, T) -&gt; R,
    initial: R,
    sequence: impl Iterator&lt;Item = T&gt;,
) -&gt; R {
    sequence.fold(initial, op)
}

// The standard library provides both:
// .fold()  - left fold, consumes iterator left-to-right
// .rfold() - right fold, consumes iterator right-to-left
</pre></div>

<p>What are the values of
</p>
<div class="example">
<pre class="example-preformatted">// fold-right: 1 / (2 / (3 / 1)) = 1 / (2 / 3) = 1.5
vec![1.0, 2.0, 3.0].iter().rfold(1.0, |acc, &amp;x| x / acc)
// =&gt; 1.5

// fold-left: ((1 / 1) / 2) / 3 = 1/6
vec![1.0, 2.0, 3.0].iter().fold(1.0, |acc, &amp;x| acc / x)
// =&gt; 0.166...

// fold-right with nesting: builds [1, [2, [3, []]]]
// fold-left with nesting:  builds [[[[], 1], 2], 3]
// The operation must be associative for fold-left == fold-right
</pre></div>

<p>Give a property that <code class="code">op</code> should satisfy to guarantee that
<code class="code">fold-right</code> and <code class="code">fold-left</code> will produce the same values for any
sequence.
</p></blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-2_002e39"></a>Exercise 2.39:</strong> Complete the following
definitions of <code class="code">reverse</code> (<a class="ref" href="#Exercise-2_002e18">Exercise 2.18</a>) in terms of
<code class="code">fold-right</code> and <code class="code">fold-left</code> from <a class="ref" href="#Exercise-2_002e38">Exercise 2.38</a>:
</p>
<div class="example">
<pre class="example-preformatted">// Using rfold (fold-right):
fn reverse_rfold&lt;T: Clone&gt;(sequence: &amp;[T]) -&gt; Vec&lt;T&gt; {
    sequence.iter().rfold(vec![], |mut acc, x| {
        acc.insert(0, x.clone());  // ?? = prepend x to y
        acc
    })
}

// Using fold (fold-left) - more natural in Rust:
fn reverse_fold&lt;T: Clone&gt;(sequence: &amp;[T]) -&gt; Vec&lt;T&gt; {
    sequence.iter().fold(vec![], |mut acc, x| {
        acc.insert(0, x.clone());  // ?? = prepend y to x
        acc
    })
}

// Idiomatic Rust: use .rev()
fn reverse&lt;T: Clone&gt;(sequence: &amp;[T]) -&gt; Vec&lt;T&gt; {
    sequence.iter().rev().cloned().collect()
}
</pre></div>
</blockquote>

<h4 class="subsubheading" id="Nested-Mappings"><span>Nested Mappings<a class="copiable-link" href="#Nested-Mappings"> &#182;</a></span></h4>

<p>We can extend the sequence paradigm to include many computations that are
commonly expressed using nested loops.<a class="footnote" id="DOCF77" href="#FOOT77"><sup>77</sup></a> Consider this problem: Given a positive integer <em class="math">n</em>, find all
ordered pairs of distinct positive integers <em class="math">i</em> and <em class="math">j</em>, where 
<em class="math">{1 \le j} &lt; {i \le n}</em>, such that <em class="math">{i + j}</em> is prime.  For example, if <em class="math">n</em> is 6,
then the pairs are the following:
\[ % :39:
 
\begin{array}{c|ccccccc}
i 	&amp; 2 &amp; 3 &amp; 4 &amp; 4 &amp; 5 &amp; 6 &amp; 6 \\
j 	&amp; 1 &amp; 2 &amp; 1 &amp; 3 &amp; 2 &amp; 1 &amp; 5 \\
\hline
i + j	&amp; 3 &amp; 5 &amp; 5 &amp; 7 &amp; 7 &amp; 7 &amp; 11 
\end{array}
\]
A natural way to organize this computation is to generate the sequence of all
ordered pairs of positive integers less than or equal to <em class="math">n</em>, filter to
select those pairs whose sum is prime, and then, for each pair <em class="math">{(i, j)}</em>
that passes through the filter, produce the triple <em class="math">{(i, j, i + j)}</em>.
</p>
<p>Here is a way to generate the sequence of pairs: For each integer <em class="math">{i \le n}</em>, 
enumerate the integers <em class="math">{j &lt; i}</em>, and for each such <em class="math">i</em> and <em class="math">j</em>
generate the pair <em class="math">{(i, j)}</em>.  In terms of sequence operations, we map along
the sequence <code class="code">(enumerate-interval 1 n)</code>.  For each <em class="math">i</em> in this sequence,
we map along the sequence <code class="code">(enumerate-interval 1 (- i 1))</code>.  For each
<em class="math">j</em> in this latter sequence, we generate the pair <code class="code">(list i j)</code>.  This
gives us a sequence of pairs for each <em class="math">i</em>.  Combining all the sequences for
all the <em class="math">i</em> (by accumulating with <code class="code">append</code>) produces the required
sequence of pairs:<a class="footnote" id="DOCF78" href="#FOOT78"><sup>78</sup></a>
</p>
<div class="example">
<pre class="example-preformatted">// Generate all pairs (i, j) where 1 &lt;= j &lt; i &lt;= n
fn pairs_up_to(n: usize) -&gt; Vec&lt;(usize, usize)&gt; {
    (1..=n)
        .flat_map(|i| (1..i).map(move |j| (i, j)))
        .collect()
}
// flat_map = map + flatten, equivalent to Scheme's accumulate + append + map
</pre></div>

<p>The combination of mapping and accumulating with <code class="code">append</code> is so common in
this sort of program that we will isolate it as a separate procedure:
</p>
<div class="example">
<pre class="example-preformatted">// In Rust, flat_map is built into iterators:
// seq.iter().flat_map(proc).collect()

// For explicit implementation:
fn flatmap&lt;T, R&gt;(proc: impl Fn(&amp;T) -&gt; Vec&lt;R&gt;, seq: &amp;[T]) -&gt; Vec&lt;R&gt; {
    seq.iter().flat_map(proc).collect()
}
</pre></div>

<p>Now filter this sequence of pairs to find those whose sum is prime. The filter
predicate is called for each element of the sequence; its argument is a pair
and it must extract the integers from the pair.  Thus, the predicate to apply
to each element in the sequence is
</p>
<div class="example">
<pre class="example-preformatted">fn prime_sum(pair: &amp;(usize, usize)) -&gt; bool {
    is_prime(pair.0 + pair.1)
}
</pre></div>

<p>Finally, generate the sequence of results by mapping over the filtered pairs
using the following procedure, which constructs a triple consisting of the two
elements of the pair along with their sum:
</p>
<div class="example">
<pre class="example-preformatted">fn make_pair_sum(pair: (usize, usize)) -&gt; (usize, usize, usize) {
    (pair.0, pair.1, pair.0 + pair.1)
}
</pre></div>

<p>Combining all these steps yields the complete procedure:
</p>
<div class="example">
<pre class="example-preformatted">fn prime_sum_pairs(n: usize) -&gt; Vec&lt;(usize, usize, usize)&gt; {
    (1..=n)
        .flat_map(|i| (1..i).map(move |j| (i, j)))
        .filter(|pair| is_prime(pair.0 + pair.1))
        .map(make_pair_sum)
        .collect()
}
</pre></div>

<p>Nested mappings are also useful for sequences other than those that enumerate
intervals.  Suppose we wish to generate all the permutations of a set <em class="math">{S;}</em>
that is, all the ways of ordering the items in the set.  For instance, the
permutations of <em class="math">{\{1, 2, 3\}}</em> are <em class="math">{\{1, 2, 3\}}</em>, <em class="math">{\{1, 3, 2\}}</em>, <em class="math">{\{2, 1, 3\}}</em>, <em class="math">{\{2, 3, 1\}}</em>,
<em class="math">{\{3, 1, 2\}}</em>, and <em class="math">{\{3, 2, 1\}}</em>.  Here is a plan for generating the permutations of
<em class="math">S</em>: For each item <em class="math">x</em> in <em class="math">S</em>, recursively generate the sequence of
permutations of <em class="math">{S - x}</em>,<a class="footnote" id="DOCF79" href="#FOOT79"><sup>79</sup></a> and adjoin <em class="math">x</em> to the front of each one.
This yields, for each <em class="math">x</em> in <em class="math">S</em>, the sequence of permutations of <em class="math">S</em>
that begin with <em class="math">x</em>.  Combining these sequences for all <em class="math">x</em> gives all the
permutations of <em class="math">S</em>:<a class="footnote" id="DOCF80" href="#FOOT80"><sup>80</sup></a>
</p>
<div class="example">
<pre class="example-preformatted">fn permutations&lt;T: Clone + PartialEq&gt;(s: Vec&lt;T&gt;) -&gt; Vec&lt;Vec&lt;T&gt;&gt; {
    if s.is_empty() {
        return vec![vec![]];  // sequence containing empty set
    }
    s.iter()
        .flat_map(|x| {
            let rest: Vec&lt;T&gt; = s.iter()
                .filter(|&amp;y| y != x)
                .cloned()
                .collect();
            permutations(rest)
                .into_iter()
                .map(|mut p| {
                    p.insert(0, x.clone());
                    p
                })
                .collect::&lt;Vec&lt;_&gt;&gt;()
        })
        .collect()
}
</pre></div>

<p>Notice how this strategy reduces the problem of generating permutations of
<em class="math">S</em> to the problem of generating the permutations of sets with fewer elements
than <em class="math">S</em>.  In the terminal case, we work our way down to the empty list,
which represents a set of no elements.  For this, we generate <code class="code">(list
nil)</code>, which is a sequence with one item, namely the set with no elements.  The
<code class="code">remove</code> procedure used in <code class="code">permutations</code> returns all the items in a
given sequence except for a given item.  This can be expressed as a simple
filter:
</p>
<div class="example">
<pre class="example-preformatted">fn remove&lt;T: Clone + PartialEq&gt;(item: &amp;T, sequence: &amp;[T]) -&gt; Vec&lt;T&gt; {
    sequence.iter()
        .filter(|&amp;x| x != item)
        .cloned()
        .collect()
}
</pre></div>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-2_002e40"></a>Exercise 2.40:</strong> Define a procedure
<code class="code">unique-pairs</code> that, given an integer <em class="math">n</em>, generates the sequence of
pairs <em class="math">{(i, j)}</em> with <em class="math">{1 \le j} &lt; {i \le n}</em>.  Use <code class="code">unique-pairs</code>
to simplify the definition of <code class="code">prime-sum-pairs</code> given above.
</p></blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-2_002e41"></a>Exercise 2.41:</strong> Write a procedure to find all
ordered triples of distinct positive integers <em class="math">i</em>, <em class="math">j</em>, and <em class="math">k</em> less than
or equal to a given integer <em class="math">n</em> that sum to a given integer <em class="math">s</em>.
</p></blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-2_002e42"></a>Exercise 2.42:</strong> The &#8220;eight-queens puzzle&#8221; asks
how to place eight queens on a chessboard so that no queen is in check from any
other (i.e., no two queens are in the same row, column, or diagonal).  One
possible solution is shown in <a class="ref" href="#Figure-2_002e8">Figure 2.8</a>.  One way to solve the puzzle is
to work across the board, placing a queen in each column.  Once we have placed
<em class="math">{k - 1}</em> queens, we must place the <em class="math">k^{\text{th}}</em> queen in a position where it does
not check any of the queens already on the board.  We can formulate this
approach recursively: Assume that we have already generated the sequence of all
possible ways to place <em class="math">{k - 1}</em> queens in the first <em class="math">{k - 1}</em> columns of the
board.  For each of these ways, generate an extended set of positions by
placing a queen in each row of the <em class="math">k^{\text{th}}</em> column.  Now filter these, keeping
only the positions for which the queen in the <em class="math">k^{\text{th}}</em> column is safe with
respect to the other queens.  This produces the sequence of all ways to place
<em class="math">k</em> queens in the first <em class="math">k</em> columns.  By continuing this process, we will
produce not only one solution, but all solutions to the puzzle.
</p>
<div class="float">
<a class="anchor" id="Figure-2_002e8"></a><img class="image" src="fig/chap2/Fig2.8c.std.svg" alt="fig/chap2/Fig2.8c" />
<div class="caption"><p><strong class="strong">Figure 2.8:</strong> A solution to the eight-queens puzzle.</p></div></div>
<p>We implement this solution as a procedure <code class="code">queens</code>, which returns a
sequence of all solutions to the problem of placing <em class="math">n</em> queens on an
<em class="math">{n \times n}</em> chessboard.  <code class="code">Queens</code> has an internal procedure
<code class="code">queen-cols</code> that returns the sequence of all ways to place queens in the
first <em class="math">k</em> columns of the board.
</p>
<div class="example">
<pre class="example-preformatted">type Board = Vec&lt;usize&gt;;  // row position for each column

fn queens(board_size: usize) -&gt; Vec&lt;Board&gt; {
    fn queen_cols(k: usize, board_size: usize) -&gt; Vec&lt;Board&gt; {
        if k == 0 {
            return vec![vec![]];  // empty board
        }
        queen_cols(k - 1, board_size)
            .into_iter()
            .flat_map(|rest_of_queens| {
                (1..=board_size)
                    .filter_map(|new_row| {
                        let mut positions = rest_of_queens.clone();
                        positions.push(new_row);
                        if safe(k, &amp;positions) {
                            Some(positions)
                        } else {
                            None
                        }
                    })
                    .collect::&lt;Vec&lt;_&gt;&gt;()
            })
            .collect()
    }
    queen_cols(board_size, board_size)
}
</pre></div>

<p>In this procedure <code class="code">rest-of-queens</code> is a way to place <em class="math">{k - 1}</em> queens in
the first <em class="math">{k - 1}</em> columns, and <code class="code">new-row</code> is a proposed row in which to
place the queen for the <em class="math">k^{\text{th}}</em> column.  Complete the program by implementing
the representation for sets of board positions, including the procedure
<code class="code">adjoin-position</code>, which adjoins a new row-column position to a set of
positions, and <code class="code">empty-board</code>, which represents an empty set of positions.
You must also write the procedure <code class="code">safe?</code>, which determines for a set of
positions, whether the queen in the <em class="math">k^{\text{th}}</em> column is safe with respect to the
others.  (Note that we need only check whether the new queen is safe&#8212;the
other queens are already guaranteed safe with respect to each other.)
</p></blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-2_002e43"></a>Exercise 2.43:</strong> Louis Reasoner is having a
terrible time doing <a class="ref" href="#Exercise-2_002e42">Exercise 2.42</a>.  His <code class="code">queens</code> procedure seems to
work, but it runs extremely slowly.  (Louis never does manage to wait long
enough for it to solve even the <em class="math">{6\times6}</em> case.)  When Louis asks Eva Lu Ator for
help, she points out that he has interchanged the order of the nested mappings
in the <code class="code">flatmap</code>, writing it as
</p>
<div class="example">
<pre class="example-preformatted">// Louis's slow version - recomputes queen_cols for EACH row!
(1..=board_size)
    .flat_map(|new_row| {
        queen_cols(k - 1, board_size)  // Called board_size times!
            .into_iter()
            .map(move |mut rest_of_queens| {
                rest_of_queens.push(new_row);
                rest_of_queens
            })
            .collect::&lt;Vec&lt;_&gt;&gt;()
    })
    .collect()
</pre></div>

<p>Explain why this interchange makes the program run slowly.  Estimate how long
it will take Louis&#8217;s program to solve the eight-queens puzzle, assuming that
the program in <a class="ref" href="#Exercise-2_002e42">Exercise 2.42</a> solves the puzzle in time <em class="math">T</em>.
</p></blockquote>

<hr />
</div>
<div class="subsection-level-extent" id="g_t2_002e2_002e4">
<h4 class="subsection" id="Example_003a-A-Picture-Language"><span>2.2.4 Example: A Picture Language<a class="copiable-link" href="#Example_003a-A-Picture-Language"> &#182;</a></span></h4>

<p>This section presents a simple language for drawing pictures that illustrates
the power of data abstraction and closure, and also exploits higher-order
procedures in an essential way.  The language is designed to make it easy to
experiment with patterns such as the ones in <a class="ref" href="#Figure-2_002e9">Figure 2.9</a>, which are
composed of repeated elements that are shifted and scaled.<a class="footnote" id="DOCF81" href="#FOOT81"><sup>81</sup></a> In this language, the data
objects being combined are represented as procedures rather than as list
structure.  Just as <code class="code">cons</code>, which satisfies the closure property, allowed
us to easily build arbitrarily complicated list structure, the operations in
this language, which also satisfy the closure property, allow us to easily
build arbitrarily complicated patterns.
</p>
<div class="float">
<a class="anchor" id="Figure-2_002e9"></a><img class="image" src="fig/chap2/Fig2.9.std.svg" alt="fig/chap2/Fig2.9" />
<div class="caption"><p><strong class="strong">Figure 2.9:</strong> Designs generated with the picture language.</p></div></div>
<h4 class="subsubheading" id="The-picture-language"><span>The picture language<a class="copiable-link" href="#The-picture-language"> &#182;</a></span></h4>

<p>When we began our study of programming in <a class="ref" href="1_002e1.xhtml#g_t1_002e1">The Elements of Programming</a>, we emphasized the
importance of describing a language by focusing on the language&#8217;s primitives,
its means of combination, and its means of abstraction.  We&#8217;ll follow that
framework here.
</p>
<p>Part of the elegance of this picture language is that there is only one kind of
element, called a <a class="index-entry-id" id="index-painter"></a>
<em class="dfn">painter</em>.  A painter draws an image that is shifted
and scaled to fit within a designated parallelogram-shaped frame.  For example,
there&#8217;s a primitive painter we&#8217;ll call <code class="code">wave</code> that makes a crude line
drawing, as shown in <a class="ref" href="#Figure-2_002e10">Figure 2.10</a>.  The actual shape of the drawing
depends on the frame&#8212;all four images in figure 2.10 are produced by the
same <code class="code">wave</code> painter, but with respect to four different frames.  Painters
can be more elaborate than this: The primitive painter called <code class="code">rogers</code>
paints a picture of <abbr class="abbr">MIT</abbr>&#8217;s founder, William Barton Rogers, as shown in
<a class="ref" href="#Figure-2_002e11">Figure 2.11</a>.<a class="footnote" id="DOCF82" href="#FOOT82"><sup>82</sup></a> The four images in figure 2.11 are drawn with respect to the same four
frames as the <code class="code">wave</code> images in figure 2.10.
</p>
<div class="float">
<a class="anchor" id="Figure-2_002e10"></a><img class="image" src="fig/chap2/Fig2.10.std.svg" alt="fig/chap2/Fig2.10" />
<div class="caption"><p><strong class="strong">Figure 2.10:</strong> Images produced by the <code class="code">wave</code> painter, with respect to four different frames.  The frames, shown with dotted lines, are not part of the images.</p></div></div>
<div class="float">
<a class="anchor" id="Figure-2_002e11"></a><img class="image" src="fig/chap2/Fig2.11.std.svg" alt="fig/chap2/Fig2.11" />
<div class="caption"><p><strong class="strong">Figure 2.11:</strong> Images of William Barton Rogers, founder and first president of <abbr class="abbr">MIT</abbr>, painted with respect to the same four frames as in <a class="ref" href="#Figure-2_002e10">Figure 2.10</a> (original image from Wikimedia Commons).</p></div></div>
<p>To combine images, we use various operations that construct new painters from
given painters.  For example, the <code class="code">beside</code> operation takes two painters
and produces a new, compound painter that draws the first painter&#8217;s image in
the left half of the frame and the second painter&#8217;s image in the right half of
the frame.  Similarly, <code class="code">below</code> takes two painters and produces a compound
painter that draws the first painter&#8217;s image below the second painter&#8217;s image.
Some operations transform a single painter to produce a new painter.  For
example, <code class="code">flip_vert</code> takes a painter and produces a painter that draws its
image upside-down, and <code class="code">flip_horiz</code> produces a painter that draws the
original painter&#8217;s image left-to-right reversed.
</p>
<p><a class="ref" href="#Figure-2_002e12">Figure 2.12</a> shows the drawing of a painter called
<code class="code">wave4</code> that is built up in two stages starting from <code class="code">wave</code>:
</p>
<div class="example">
<pre class="example-preformatted">let wave2 = beside(&amp;wave, &amp;flip_vert(&amp;wave));
let wave4 = below(&amp;wave2, &amp;wave2);
</pre></div>

<div class="float">
<a class="anchor" id="Figure-2_002e12"></a><img class="image" src="fig/chap2/Fig2.12.std.svg" alt="fig/chap2/Fig2.12" />
<div class="caption"><p><strong class="strong">Figure 2.12:</strong> Creating a complex figure, starting from the <code class="code">wave</code> painter of <a class="ref" href="#Figure-2_002e10">Figure 2.10</a>.</p></div></div>
<p>In building up a complex image in this manner we are exploiting the fact that
painters are closed under the language&#8217;s means of combination.  The
<code class="code">beside</code> or <code class="code">below</code> of two painters is itself a painter; therefore,
we can use it as an element in making more complex painters.  As with building
up list structure using <code class="code">cons</code>, the closure of our data under the means of
combination is crucial to the ability to create complex structures while using
only a few operations.
</p>
<p>Once we can combine painters, we would like to be able to abstract typical
patterns of combining painters.  We will implement the painter operations as
Scheme procedures.  This means that we don&#8217;t need a special abstraction
mechanism in the picture language: Since the means of combination are ordinary
Scheme procedures, we automatically have the capability to do anything with
painter operations that we can do with procedures.  For example, we can
abstract the pattern in <code class="code">wave4</code> as
</p>
<div class="example">
<pre class="example-preformatted">fn flipped_pairs(painter: &amp;Painter) -&gt; Painter {
    let painter2 = beside(painter, &amp;flip_vert(painter));
    below(&amp;painter2, &amp;painter2)
}
</pre></div>

<p>and define <code class="code">wave4</code> as an instance of this pattern:
</p>
<div class="example">
<pre class="example-preformatted">let wave4 = flipped_pairs(&amp;wave);
</pre></div>

<p>We can also define recursive operations.  Here&#8217;s one that makes painters split
and branch towards the right as shown in <a class="ref" href="#Figure-2_002e13">Figure 2.13</a>
and <a class="ref" href="#Figure-2_002e14">Figure 2.14</a>:
</p>
<div class="example">
<pre class="example-preformatted">fn right_split(painter: &amp;Painter, n: usize) -&gt; Painter {
    if n == 0 {
        painter.clone()
    } else {
        let smaller = right_split(painter, n - 1);
        beside(painter, &amp;below(&amp;smaller, &amp;smaller))
    }
}
</pre></div>

<div class="float">
<a class="anchor" id="Figure-2_002e13"></a><img class="image" src="fig/chap2/Fig2.13a.std.svg" alt="fig/chap2/Fig2.13a" />
<div class="caption"><p><strong class="strong">Figure 2.13:</strong> Recursive plans for <code class="code">right_split</code> and <code class="code">corner_split</code>.</p></div></div>
<p>We can produce balanced patterns by branching upwards as well as towards the
right (see <a class="ref" href="#Exercise-2_002e44">Exercise 2.44</a>, <a class="ref" href="#Figure-2_002e13">Figure 2.13</a> and <a class="ref" href="#Figure-2_002e14">Figure 2.14</a>):
</p>
<div class="example">
<pre class="example-preformatted">fn corner_split(painter: &amp;Painter, n: usize) -&gt; Painter {
    if n == 0 {
        painter.clone()
    } else {
        let up = up_split(painter, n - 1);
        let right = right_split(painter, n - 1);
        let top_left = beside(&amp;up, &amp;up);
        let bottom_right = below(&amp;right, &amp;right);
        let corner = corner_split(painter, n - 1);
        beside(
            &amp;below(painter, &amp;top_left),
            &amp;below(&amp;bottom_right, &amp;corner),
        )
    }
}
</pre></div>

<div class="float">
<a class="anchor" id="Figure-2_002e14"></a><img class="image" src="fig/chap2/Fig2.14b.std.svg" alt="fig/chap2/Fig2.14b" />
<div class="caption"><p><strong class="strong">Figure 2.14:</strong> The recursive operations <code class="code">right_split</code> and <code class="code">corner_split</code> applied to the painters <code class="code">wave</code> and <code class="code">rogers</code>.  Combining four <code class="code">corner_split</code> figures produces symmetric <code class="code">square_limit</code> designs as shown in <a class="ref" href="#Figure-2_002e9">Figure 2.9</a>.</p></div></div>
<p>By placing four copies of a <code class="code">corner_split</code> appropriately, we obtain a
pattern called <code class="code">square_limit</code>, whose application to <code class="code">wave</code> and
<code class="code">rogers</code> is shown in <a class="ref" href="#Figure-2_002e9">Figure 2.9</a>:
</p>
<div class="example">
<pre class="example-preformatted">fn square_limit(painter: &amp;Painter, n: usize) -&gt; Painter {
    let quarter = corner_split(painter, n);
    let half = beside(&amp;flip_horiz(&amp;quarter), &amp;quarter);
    below(&amp;flip_vert(&amp;half), &amp;half)
}
</pre></div>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-2_002e44"></a>Exercise 2.44:</strong> Define the procedure
<code class="code">up_split</code> used by <code class="code">corner_split</code>.  It is similar to
<code class="code">right_split</code>, except that it switches the roles of <code class="code">below</code> and
<code class="code">beside</code>.
</p></blockquote>

<h4 class="subsubheading" id="Higher_002dorder-operations"><span>Higher-order operations<a class="copiable-link" href="#Higher_002dorder-operations"> &#182;</a></span></h4>

<p>In addition to abstracting patterns of combining painters, we can work at a
higher level, abstracting patterns of combining painter operations.  That is,
we can view the painter operations as elements to manipulate and can write
means of combination for these elements&#8212;procedures that take painter
operations as arguments and create new painter operations.
</p>
<p>For example, <code class="code">flipped_pairs</code> and <code class="code">square_limit</code> each arrange four
copies of a painter&#8217;s image in a square pattern; they differ only in how they
orient the copies.  One way to abstract this pattern of painter combination is
with the following procedure, which takes four one-argument painter operations
and produces a painter operation that transforms a given painter with those
four operations and arranges the results in a square.  <code class="code">Tl</code>, <code class="code">tr</code>,
<code class="code">bl</code>, and <code class="code">br</code> are the transformations to apply to the top left copy,
the top right copy, the bottom left copy, and the bottom right copy,
respectively.
</p>
<div class="example">
<pre class="example-preformatted">fn square_of_four&lt;F1, F2, F3, F4&gt;(tl: F1, tr: F2, bl: F3, br: F4)
    -&gt; impl Fn(&amp;Painter) -&gt; Painter
where
    F1: Fn(&amp;Painter) -&gt; Painter,
    F2: Fn(&amp;Painter) -&gt; Painter,
    F3: Fn(&amp;Painter) -&gt; Painter,
    F4: Fn(&amp;Painter) -&gt; Painter,
{
    move |painter| {
        let top = beside(&amp;tl(painter), &amp;tr(painter));
        let bottom = beside(&amp;bl(painter), &amp;br(painter));
        below(&amp;bottom, &amp;top)
    }
}
</pre></div>

<p>Then <code class="code">flipped_pairs</code> can be defined in terms of <code class="code">square_of_four</code> as
follows:<a class="footnote" id="DOCF83" href="#FOOT83"><sup>83</sup></a>
</p>
<div class="example">
<pre class="example-preformatted">fn flipped_pairs(painter: &amp;Painter) -&gt; Painter {
    let combine4 = square_of_four(identity, flip_vert, identity, flip_vert);
    combine4(painter)
}
</pre></div>

<p>and <code class="code">square_limit</code> can be expressed as<a class="footnote" id="DOCF84" href="#FOOT84"><sup>84</sup></a>
</p>
<div class="example">
<pre class="example-preformatted">fn square_limit(painter: &amp;Painter, n: usize) -&gt; Painter {
    let combine4 = square_of_four(flip_horiz, identity, rotate180, flip_vert);
    combine4(&amp;corner_split(painter, n))
}
</pre></div>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-2_002e45"></a>Exercise 2.45:</strong> <code class="code">Right-split</code> and
<code class="code">up_split</code> can be expressed as instances of a general splitting operation.
Define a procedure <code class="code">split</code> with the property that evaluating
</p>
<div class="example">
<pre class="example-preformatted">let right_split = split(beside, below);
let up_split = split(below, beside);
</pre></div>

<p>produces procedures <code class="code">right_split</code> and <code class="code">up_split</code> with the same
behaviors as the ones already defined.
</p></blockquote>

<h4 class="subsubheading" id="Frames"><span>Frames<a class="copiable-link" href="#Frames"> &#182;</a></span></h4>

<p>Before we can show how to implement painters and their means of combination, we
must first consider frames.  A frame can be described by three vectors&#8212;an
origin vector and two edge vectors.  The origin vector specifies the offset of
the frame&#8217;s origin from some absolute origin in the plane, and the edge vectors
specify the offsets of the frame&#8217;s corners from its origin.  If the edges are
perpendicular, the frame will be rectangular.  Otherwise the frame will be a
more general parallelogram.
</p>
<p><a class="ref" href="#Figure-2_002e15">Figure 2.15</a> shows a frame and its associated vectors.
In accordance with data abstraction, we need not be specific yet about how
frames are represented, other than to say that there is a constructor
<code class="code">Frame::new</code>, which takes three vectors and produces a frame, and three
corresponding selectors <code class="code">origin_frame</code>, <code class="code">edge1_frame</code>, and
<code class="code">edge2_frame</code> (see <a class="ref" href="#Exercise-2_002e47">Exercise 2.47</a>).
</p>
<div class="float">
<a class="anchor" id="Figure-2_002e15"></a><img class="image" src="fig/chap2/Fig2.15a.std.svg" alt="fig/chap2/Fig2.15a" />
<div class="caption"><p><strong class="strong">Figure 2.15:</strong> A frame is described by three vectors &#8212; an origin and two edges.</p></div></div>
<p>We will use coordinates in the unit square <em class="math">{(0 \le x, y \le 1)}</em> to specify
images.  With each frame, we associate a <a class="index-entry-id" id="index-frame-coordinate-map"></a>
<em class="dfn">frame coordinate map</em>, which
will be used to shift and scale images to fit the frame.  The map transforms
the unit square into the frame by mapping the vector <em class="math">{{\bf v} = (x, y)}</em> to
the vector sum
\[ % :40:
  {\text{Origin(Frame)}} + {x \cdot \text{Edge}_1\text{(Frame)}} + {y \cdot \text{Edge}_2\text{(Frame)}.} \]
For example, (0, 0) is mapped to the origin of the frame, (1, 1) to the vertex
diagonally opposite the origin, and (0.5, 0.5) to the center of the frame.  We
can create a frame&#8217;s coordinate map with the following
procedure:<a class="footnote" id="DOCF85" href="#FOOT85"><sup>85</sup></a>
</p>
<div class="example">
<pre class="example-preformatted">fn frame_coord_map(frame: &amp;Frame) -&gt; impl Fn(Vec2) -&gt; Vec2 + '_ {
    move |v| {
        frame.origin
            .add(&amp;frame.edge1.scale(v.x))
            .add(&amp;frame.edge2.scale(v.y))
    }
}
</pre></div>

<p>Observe that applying <code class="code">frame_coord_map</code> to a frame returns a procedure
that, given a vector, returns a vector.  If the argument vector is in the unit
square, the result vector will be in the frame.  For example,
</p>
<div class="example">
<pre class="example-preformatted">frame_coord_map(&amp;a_frame)(Vec2 { x: 0.0, y: 0.0 })
</pre></div>

<p>returns the same vector as
</p>
<div class="example">
<pre class="example-preformatted">a_frame.origin
</pre></div>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-2_002e46"></a>Exercise 2.46:</strong> A two-dimensional vector <em class="math">\bf v</em>
running from the origin to a point can be represented as a pair consisting of
an <em class="math">x</em>-coordinate and a <em class="math">y</em>-coordinate.  Implement a data abstraction for
vectors by giving a constructor <code class="code">Vec2::new</code> and corresponding selectors
<code class="code">xcor_vect</code> and <code class="code">ycor_vect</code>.  In terms of your selectors and
constructor, implement procedures <code class="code">add_vect</code>, <code class="code">sub_vect</code>, and
<code class="code">scale_vect</code> that perform the operations vector addition, vector
subtraction, and multiplying a vector by a scalar:
\[ % :41:
  
\begin{eqnarray}
	(x_1, y_1) + (x_2, y_2)  &amp;=&amp;  (x_1 + x_2, y_1 + y_2), \\
	(x_1, y_1) - (x_2, y_2)  &amp;=&amp;  (x_1 - x_2, y_1 - y_2), \\
	s \cdot (x, y) 		 &amp;=&amp;  (sx, sy).
\end{eqnarray}
\]
</p></blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-2_002e47"></a>Exercise 2.47:</strong> Here are two possible
constructors for frames:
</p>
<div class="example">
<pre class="example-preformatted">// In Rust, we use a struct with named fields:
#[derive(Clone)]
struct Frame {
    origin: Vec2,
    edge1: Vec2,
    edge2: Vec2,
}

impl Frame {
    fn new(origin: Vec2, edge1: Vec2, edge2: Vec2) -&gt; Self {
        Self { origin, edge1, edge2 }
    }
}
</pre></div>

<p>For each constructor supply the appropriate selectors to produce an
implementation for frames.
</p></blockquote>

<h4 class="subsubheading" id="Painters"><span>Painters<a class="copiable-link" href="#Painters"> &#182;</a></span></h4>

<p>A painter is represented as a procedure that, given a frame as argument, draws
a particular image shifted and scaled to fit the frame.  That is to say, if
<code class="code">p</code> is a painter and <code class="code">f</code> is a frame, then we produce <code class="code">p</code>&#8217;s image
in <code class="code">f</code> by calling <code class="code">p</code> with <code class="code">f</code> as argument.
</p>
<p>The details of how primitive painters are implemented depend on the particular
characteristics of the graphics system and the type of image to be drawn.  For
instance, suppose we have a procedure <code class="code">draw_line</code> that draws a line on the
screen between two specified points.  Then we can create painters for line
drawings, such as the <code class="code">wave</code> painter in <a class="ref" href="#Figure-2_002e10">Figure 2.10</a>, from lists of
line segments as follows:<a class="footnote" id="DOCF86" href="#FOOT86"><sup>86</sup></a>
</p>
<div class="example">
<pre class="example-preformatted">fn segments_to_painter(segment_list: Vec&lt;Segment&gt;) -&gt; Painter {
    Box::new(move |frame: &amp;Frame| {
        let mapper = frame_coord_map(frame);
        for segment in &amp;segment_list {
            draw_line(
                mapper(segment.start),
                mapper(segment.end),
            );
        }
    })
}
</pre></div>

<p>The segments are given using coordinates with respect to the unit square.  For
each segment in the list, the painter transforms the segment endpoints with the
frame coordinate map and draws a line between the transformed points.
</p>
<p>Representing painters as procedures erects a powerful abstraction barrier in
the picture language.  We can create and intermix all sorts of primitive
painters, based on a variety of graphics capabilities. The details of their
implementation do not matter.  Any procedure can serve as a painter, provided
that it takes a frame as argument and draws something scaled to fit the
frame.<a class="footnote" id="DOCF87" href="#FOOT87"><sup>87</sup></a>
</p>
<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-2_002e48"></a>Exercise 2.48:</strong> A directed line segment in the
plane can be represented as a pair of vectors&#8212;the vector running from the
origin to the start-point of the segment, and the vector running from the
origin to the end-point of the segment.  Use your vector representation from
<a class="ref" href="#Exercise-2_002e46">Exercise 2.46</a> to define a representation for segments with a constructor
<code class="code">Segment::new</code> and selectors <code class="code">start_segment</code> and <code class="code">end_segment</code>.
</p></blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-2_002e49"></a>Exercise 2.49:</strong> Use <code class="code">segments_to_painter</code>
to define the following primitive painters:
</p>
<ol class="enumerate" type="a" start="1">
<li> The painter that draws the outline of the designated frame.

</li><li> The painter that draws an &#8220;X&#8221; by connecting opposite corners of the frame.

</li><li> The painter that draws a diamond shape by connecting the midpoints of the sides
of the frame.

</li><li> The <code class="code">wave</code> painter.

</li></ol>
</blockquote>

<h4 class="subsubheading" id="Transforming-and-combining-painters"><span>Transforming and combining painters<a class="copiable-link" href="#Transforming-and-combining-painters"> &#182;</a></span></h4>

<p>An operation on painters (such as <code class="code">flip_vert</code> or <code class="code">beside</code>) works by
creating a painter that invokes the original painters with respect to frames
derived from the argument frame.  Thus, for example, <code class="code">flip_vert</code> doesn&#8217;t
have to know how a painter works in order to flip it&#8212;it just has to know how
to turn a frame upside down: The flipped painter just uses the original
painter, but in the inverted frame.
</p>
<p>Painter operations are based on the procedure <code class="code">transform_painter</code>, which
takes as arguments a painter and information on how to transform a frame and
produces a new painter.  The transformed painter, when called on a frame,
transforms the frame and calls the original painter on the transformed frame.
The arguments to <code class="code">transform_painter</code> are points (represented as vectors)
that specify the corners of the new frame: When mapped into the frame, the
first point specifies the new frame&#8217;s origin and the other two specify the ends
of its edge vectors.  Thus, arguments within the unit square specify a frame
contained within the original frame.
</p>
<div class="example">
<pre class="example-preformatted">fn transform_painter(
    painter: Painter,
    origin: Vec2,
    corner1: Vec2,
    corner2: Vec2,
) -&gt; Painter {
    Box::new(move |frame: &amp;Frame| {
        let m = frame_coord_map(frame);
        let new_origin = m(origin);
        let new_frame = Frame::new(
            new_origin,
            m(corner1).sub(&amp;new_origin),
            m(corner2).sub(&amp;new_origin),
        );
        painter(&amp;new_frame)
    })
}
</pre></div>

<p>Here&#8217;s how to flip painter images vertically:
</p>
<div class="example">
<pre class="example-preformatted">fn flip_vert(painter: Painter) -&gt; Painter {
    transform_painter(
        painter,
        Vec2 { x: 0.0, y: 1.0 },  // new origin
        Vec2 { x: 1.0, y: 1.0 },  // new end of edge1
        Vec2 { x: 0.0, y: 0.0 },  // new end of edge2
    )
}
</pre></div>

<p>Using <code class="code">transform_painter</code>, we can easily define new transformations.
For example, we can define a painter that shrinks its image to the
upper-right quarter of the frame it is given:
</p>
<div class="example">
<pre class="example-preformatted">fn shrink_to_upper_right(painter: Painter) -&gt; Painter {
    transform_painter(
        painter,
        Vec2 { x: 0.5, y: 0.5 },
        Vec2 { x: 1.0, y: 0.5 },
        Vec2 { x: 0.5, y: 1.0 },
    )
}
</pre></div>

<p>Other transformations rotate images counterclockwise by 90
degrees<a class="footnote" id="DOCF88" href="#FOOT88"><sup>88</sup></a>
</p>
<div class="example">
<pre class="example-preformatted">fn rotate90(painter: Painter) -&gt; Painter {
    transform_painter(
        painter,
        Vec2 { x: 1.0, y: 0.0 },
        Vec2 { x: 1.0, y: 1.0 },
        Vec2 { x: 0.0, y: 0.0 },
    )
}
</pre></div>

<p>or squash images towards the center of the frame:<a class="footnote" id="DOCF89" href="#FOOT89"><sup>89</sup></a>
</p>
<div class="example">
<pre class="example-preformatted">fn squash_inwards(painter: Painter) -&gt; Painter {
    transform_painter(
        painter,
        Vec2 { x: 0.0, y: 0.0 },
        Vec2 { x: 0.65, y: 0.35 },
        Vec2 { x: 0.35, y: 0.65 },
    )
}
</pre></div>

<p>Frame transformation is also the key to defining means of combining two or more
painters.  The <code class="code">beside</code> procedure, for example, takes two painters,
transforms them to paint in the left and right halves of an argument frame
respectively, and produces a new, compound painter.  When the compound painter
is given a frame, it calls the first transformed painter to paint in the left
half of the frame and calls the second transformed painter to paint in the
right half of the frame:
</p>
<div class="example">
<pre class="example-preformatted">fn beside(painter1: Painter, painter2: Painter) -&gt; Painter {
    let split = Vec2 { x: 0.5, y: 0.0 };
    let paint_left = transform_painter(
        painter1,
        Vec2 { x: 0.0, y: 0.0 },
        split,
        Vec2 { x: 0.0, y: 1.0 },
    );
    let paint_right = transform_painter(
        painter2,
        split,
        Vec2 { x: 1.0, y: 0.0 },
        Vec2 { x: 0.5, y: 1.0 },
    );
    Box::new(move |frame: &amp;Frame| {
        paint_left(frame);
        paint_right(frame);
    })
}
</pre></div>

<p>Observe how the painter data abstraction, and in particular the representation
of painters as procedures, makes <code class="code">beside</code> easy to implement.  The
<code class="code">beside</code> procedure need not know anything about the details of the
component painters other than that each painter will draw something in its
designated frame.
</p>
<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-2_002e50"></a>Exercise 2.50:</strong> Define the transformation
<code class="code">flip_horiz</code>, which flips painters horizontally, and transformations that
rotate painters counterclockwise by 180 degrees and 270 degrees.
</p></blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-2_002e51"></a>Exercise 2.51:</strong> Define the <code class="code">below</code> operation
for painters.  <code class="code">Below</code> takes two painters as arguments.  The resulting
painter, given a frame, draws with the first painter in the bottom of the frame
and with the second painter in the top.  Define <code class="code">below</code> in two different
ways&#8212;first by writing a procedure that is analogous to the <code class="code">beside</code>
procedure given above, and again in terms of <code class="code">beside</code> and suitable
rotation operations (from <a class="ref" href="#Exercise-2_002e50">Exercise 2.50</a>).
</p></blockquote>

<h4 class="subsubheading" id="Levels-of-language-for-robust-design"><span>Levels of language for robust design<a class="copiable-link" href="#Levels-of-language-for-robust-design"> &#182;</a></span></h4>

<p>The picture language exercises some of the critical ideas we&#8217;ve introduced
about abstraction with procedures and data.  The fundamental data abstractions,
painters, are implemented using procedural representations, which enables the
language to handle different basic drawing capabilities in a uniform way.  The
means of combination satisfy the closure property, which permits us to easily
build up complex designs.  Finally, all the tools for abstracting procedures
are available to us for abstracting means of combination for painters.
</p>
<p>We have also obtained a glimpse of another crucial idea about languages and
program design.  This is the approach of <a class="index-entry-id" id="index-stratified-design"></a>
<em class="dfn">stratified design</em>, the
notion that a complex system should be structured as a sequence of levels that
are described using a sequence of languages.  Each level is constructed by
combining parts that are regarded as primitive at that level, and the parts
constructed at each level are used as primitives at the next level.  The
language used at each level of a stratified design has primitives, means of
combination, and means of abstraction appropriate to that level of detail.
</p>
<p>Stratified design pervades the engineering of complex systems.  For example, in
computer engineering, resistors and transistors are combined (and described
using a language of analog circuits) to produce parts such as and-gates and
or-gates, which form the primitives of a language for digital-circuit
design.<a class="footnote" id="DOCF90" href="#FOOT90"><sup>90</sup></a> These parts
are combined to build processors, bus structures, and memory systems, which are
in turn combined to form computers, using languages appropriate to computer
architecture.  Computers are combined to form distributed systems, using
languages appropriate for describing network interconnections, and so on.
</p>
<p>As a tiny example of stratification, our picture language uses primitive
elements (primitive painters) that are created using a language that specifies
points and lines to provide the lists of line segments for
<code class="code">segments_to_painter</code>, or the shading details for a painter like
<code class="code">rogers</code>.  The bulk of our description of the picture language focused on
combining these primitives, using geometric combiners such as <code class="code">beside</code> and
<code class="code">below</code>.  We also worked at a higher level, regarding <code class="code">beside</code> and
<code class="code">below</code> as primitives to be manipulated in a language whose operations,
such as <code class="code">square_of_four</code>, capture common patterns of combining geometric
combiners.
</p>
<p>Stratified design helps make programs <a class="index-entry-id" id="index-robust"></a>
<em class="dfn">robust</em>, that is, it makes it
likely that small changes in a specification will require correspondingly small
changes in the program.  For instance, suppose we wanted to change the image
based on <code class="code">wave</code> shown in <a class="ref" href="#Figure-2_002e9">Figure 2.9</a>.  We could work at the lowest
level to change the detailed appearance of the <code class="code">wave</code> element; we could
work at the middle level to change the way <code class="code">corner_split</code> replicates the
<code class="code">wave</code>; we could work at the highest level to change how
<code class="code">square_limit</code> arranges the four copies of the corner.  In general, each
level of a stratified design provides a different vocabulary for expressing the
characteristics of the system, and a different kind of ability to change it.
</p>
<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-2_002e52"></a>Exercise 2.52:</strong> Make changes to the square limit
of <code class="code">wave</code> shown in <a class="ref" href="#Figure-2_002e9">Figure 2.9</a> by working at each of the levels
described above.  In particular:
</p>
<ol class="enumerate" type="a" start="1">
<li> Add some segments to the primitive <code class="code">wave</code> painter of <a class="ref" href="#Exercise-2_002e49">Exercise 2.49</a>
(to add a smile, for example).

</li><li> Change the pattern constructed by <code class="code">corner_split</code> (for example, by using
only one copy of the <code class="code">up_split</code> and <code class="code">right_split</code> images instead of
two).

</li><li> Modify the version of <code class="code">square_limit</code> that uses <code class="code">square_of_four</code> so as
to assemble the corners in a different pattern.  (For example, you might make
the big Mr. Rogers look outward from each corner of the square.)

</li></ol>
</blockquote>
<hr />
</div>
<div class="subsection-level-extent" id="g_t2_002e2_002e5">
<h4 class="subsection" id="Algebraic-Data-Types"><span>2.2.5 Algebraic Data Types<a class="copiable-link" href="#Algebraic-Data-Types"> &#182;</a></span></h4>

<a class="index-entry-id" id="index-algebraic-data-types"></a>
<a class="index-entry-id" id="index-enums"></a>
<a class="index-entry-id" id="index-sum-types"></a>
<a class="index-entry-id" id="index-product-types"></a>
<a class="index-entry-id" id="index-pattern-matching"></a>

<p>In our journey through data abstraction, we have seen how pairs, lists, and
trees allow us to build increasingly sophisticated data structures. In
<a class="ref" href="2_002e1.xhtml#g_t2_002e1">Introduction to Data Abstraction</a>, we introduced the fundamental abstraction barrier between the
representation of data and its use. In this section, we examine Rust&#8217;s most
powerful tool for data abstraction: <a class="index-entry-id" id="index-algebraic-data-types-1"></a>
<em class="dfn">algebraic data types</em>, which
provide a rigorous mathematical foundation for representing data that can take
on different forms.
</p>
<p>The term &#8220;algebraic&#8221; comes from the algebraic operations we can perform on
types. Just as algebra combines numbers through addition and multiplication, we
can combine types through two fundamental operations: <a class="index-entry-id" id="index-product-types-1"></a>
<em class="dfn">product types</em>
(combining multiple values) and <a class="index-entry-id" id="index-sum-types-1"></a>
<em class="dfn">sum types</em> (choosing between
alternatives). Rust&#8217;s <code class="code">struct</code> and tuple types implement products, while
the <code class="code">enum</code> type implements sums.
</p>
<h4 class="subsubheading" id="Product-Types_003a-Combining-Data"><span>Product Types: Combining Data<a class="copiable-link" href="#Product-Types_003a-Combining-Data"> &#182;</a></span></h4>

<p>We have already encountered product types in our work. A <code class="code">struct</code> or tuple
combines multiple values into a single compound value:
</p>
<div class="example">
<pre class="example-preformatted">// Product type: Rational contains BOTH a numerator AND a denominator
struct Rational {
    numer: i64,
    denom: i64,
}

// Tuple product: contains ALL three elements simultaneously
type Point3D = (f64, f64, f64);
</pre></div>

<p>The number of possible values of a product type is the <em class="emph">product</em> of the
number of values of each component. If <code class="code">bool</code> has 2 values and <code class="code">u8</code>
has 256 values, then <code class="code">(bool, u8)</code> has <em class="math">{2 \times 256 = 512}</em> possible
values. This multiplicative property is why we call them product types.
</p>
<h4 class="subsubheading" id="Sum-Types_003a-Choosing-Alternatives"><span>Sum Types: Choosing Alternatives<a class="copiable-link" href="#Sum-Types_003a-Choosing-Alternatives"> &#182;</a></span></h4>

<a class="index-entry-id" id="index-discriminated-union"></a>

<p>In contrast, a <a class="index-entry-id" id="index-sum-type"></a>
<em class="dfn">sum type</em> represents data that can take on one of
several different forms. Rust&#8217;s <code class="code">enum</code> construct provides this capability
through <a class="index-entry-id" id="index-discriminated-unions"></a>
<em class="dfn">discriminated unions</em>&#8212;values that carry a tag indicating
which variant they contain:
</p>
<div class="example">
<pre class="example-preformatted">enum Shape {
    Circle(f64),              // radius
    Rectangle(f64, f64),      // width, height
    Triangle(f64, f64, f64),  // three sides
}
</pre></div>

<p>A <code class="code">Shape</code> value is <em class="emph">either</em> a <code class="code">Circle</code> <em class="emph">or</em> a
<code class="code">Rectangle</code> <em class="emph">or</em> a <code class="code">Triangle</code>&#8212;never more than one
simultaneously. The total number of possible values is the <em class="emph">sum</em> of the
values from each variant, hence &#8220;sum type.&#8221;
</p>
<p>This is fundamentally different from object-oriented subtyping. In traditional
OOP, you might define a <code class="code">Shape</code> interface with multiple implementations.
But those implementations are open-ended&#8212;anyone can add new shapes. With sum
types, the set of variants is <em class="emph">closed</em> and <em class="emph">exhaustively known</em> at
compile time. This seemingly restrictive property is actually a powerful
guarantee that enables the compiler to verify our code&#8217;s correctness.
</p>
<h4 class="subsubheading" id="Enum-Variants_003a-Three-Flavors"><span>Enum Variants: Three Flavors<a class="copiable-link" href="#Enum-Variants_003a-Three-Flavors"> &#182;</a></span></h4>

<p>Rust provides three kinds of enum variants, each suited to different data
representation needs:
</p>
<div class="example">
<pre class="example-preformatted">enum Message {
    // Unit variant: no associated data (like a constant)
    Quit,

    // Tuple variant: unnamed fields (like a tuple struct)
    Move { x: i32, y: i32 },

    // Struct variant: named fields (like a regular struct)
    Write(String),

    // Can mix variant types in one enum
    ChangeColor(u8, u8, u8),
}
</pre></div>

<p>Unit variants like <code class="code">Quit</code> carry no data&#8212;they simply represent a state or
signal. Tuple variants like <code class="code">ChangeColor</code> bundle related data without
naming the fields. Struct variants like <code class="code">Move</code> provide named fields for
clarity when the meaning isn&#8217;t obvious from position alone.
</p>
<p>Each variant is accessed through the enum&#8217;s namespace:
</p>
<div class="example">
<pre class="example-preformatted">let m1 = Message::Quit;
let m2 = Message::Move { x: 10, y: 20 };
let m3 = Message::Write(String::from(&quot;hello&quot;));
let m4 = Message::ChangeColor(255, 0, 0);
</pre></div>

<h4 class="subsubheading" id="Pattern-Matching_003a-Destructuring-Sum-Types"><span>Pattern Matching: Destructuring Sum Types<a class="copiable-link" href="#Pattern-Matching_003a-Destructuring-Sum-Types"> &#182;</a></span></h4>

<a class="index-entry-id" id="index-exhaustive-matching"></a>
<a class="index-entry-id" id="index-match-expression"></a>

<p>The power of sum types emerges when combined with <a class="index-entry-id" id="index-pattern-matching-1"></a>
<em class="dfn">pattern matching</em>.
The <code class="code">match</code> expression allows us to handle each variant and extract its
data in a single, type-safe operation:
</p>
<div class="example">
<pre class="example-preformatted">fn describe_shape(shape: &amp;Shape) -&gt; String {
    match shape {
        Shape::Circle(r) =&gt;
            format!(&quot;Circle with radius {}&quot;, r),
        Shape::Rectangle(w, h) =&gt;
            format!(&quot;Rectangle {} x {}&quot;, w, h),
        Shape::Triangle(a, b, c) =&gt;
            format!(&quot;Triangle with sides {}, {}, {}&quot;, a, b, c),
    }
}
</pre></div>

<p>The <code class="code">match</code> expression has several critical properties:
</p>
<ol class="enumerate">
<li> <strong class="strong">Exhaustiveness:</strong> The compiler verifies that every possible variant is
handled. Forget a case, and your code won&#8217;t compile. This eliminates an entire
class of bugs.

</li><li> <strong class="strong">Pattern binding:</strong> Each arm can bind variables to the variant&#8217;s data
(<code class="code">r</code>, <code class="code">w</code>, <code class="code">h</code>, etc.), making them available in the arm&#8217;s
expression.

</li><li> <strong class="strong">Expression-based:</strong> <code class="code">match</code> is an expression that produces a value,
not just a statement. All arms must return the same type.

</li><li> <strong class="strong">No fallthrough:</strong> Unlike C&#8217;s <code class="code">switch</code>, only the matching arm
executes. No <code class="code">break</code> statements needed.
</li></ol>

<p>The exhaustiveness check is particularly profound. It creates a contract between
the data definition and all code that uses it: when you add a new variant, the
compiler forces you to update <em class="emph">every</em> match expression. This &#8220;compiler as
assistant&#8221; property makes refactoring safe and mechanical.
</p>
<h4 class="subsubheading" id="Option-and-Result_003a-Sum-Types-in-the-Standard-Library"><span>Option and Result: Sum Types in the Standard Library<a class="copiable-link" href="#Option-and-Result_003a-Sum-Types-in-the-Standard-Library"> &#182;</a></span></h4>

<a class="index-entry-id" id="index-Option-type"></a>
<a class="index-entry-id" id="index-Result-type"></a>
<a class="index-entry-id" id="index-null-safety"></a>

<p>The most ubiquitous sum types in Rust are <code class="code">Option&lt;T&gt;</code> and
<code class="code">Result&lt;T, E&gt;</code>, which encode the fundamental patterns of optional values
and error handling:
</p>
<div class="example">
<pre class="example-preformatted">enum Option&lt;T&gt; {
    None,
    Some(T),
}

enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
</pre></div>

<p><code class="code">Option&lt;T&gt;</code> represents a value that might be absent. This replaces the
null pointer of languages like C and Java. Rather than allowing any reference
to be null (and requiring runtime checks everywhere), Rust makes optionality
explicit in the type system:
</p>
<div class="example">
<pre class="example-preformatted">fn find_first_even(numbers: &amp;[i32]) -&gt; Option&lt;i32&gt; {
    numbers.iter()
        .find(|&amp;&amp;n| n % 2 == 0)
        .copied()
}

fn main() {
    let nums = vec![1, 3, 4, 5];

    match find_first_even(&amp;nums) {
        Some(n) =&gt; println!(&quot;Found: {}&quot;, n),
        None =&gt; println!(&quot;No even number found&quot;),
    }
}
</pre></div>

<p>The type <code class="code">Option&lt;i32&gt;</code> clearly indicates &#8220;this function might not find a
value.&#8221; The caller is forced to handle both cases. You cannot accidentally use
a <code class="code">None</code> value as if it were a number&#8212;the type system prevents it.
</p>
<p>Similarly, <code class="code">Result&lt;T, E&gt;</code> makes error handling explicit:
</p>
<div class="example">
<pre class="example-preformatted">use std::fs::File;
use std::io::{self, Read};

fn read_username_from_file(path: &amp;str) -&gt; Result&lt;String, io::Error&gt; {
    let mut file = File::open(path)?;  // ? propagates errors
    let mut username = String::new();
    file.read_to_string(&amp;mut username)?;
    Ok(username)
}
</pre></div>

<p>The return type <code class="code">Result&lt;String, io::Error&gt;</code> documents that this function
can fail with an I/O error. The <code class="code">?</code> operator provides syntactic sugar for
error propagation: if the operation fails, return early with the error;
otherwise, unwrap the success value.
</p>
<h4 class="subsubheading" id="Recursive-Enums_003a-Lists-and-Trees"><span>Recursive Enums: Lists and Trees<a class="copiable-link" href="#Recursive-Enums_003a-Lists-and-Trees"> &#182;</a></span></h4>

<a class="index-entry-id" id="index-recursive-types"></a>
<a class="index-entry-id" id="index-Box-type"></a>

<p>One of the most powerful applications of sum types is defining recursive data
structures. However, a naive attempt fails:
</p>
<div class="example">
<pre class="example-preformatted">// ERROR: infinite size!
enum List {
    Nil,
    Cons(i32, List),  // List contains itself directly
}
</pre></div>

<p>The compiler rejects this because it cannot determine the size of <code class="code">List</code>.
A <code class="code">Cons</code> contains a <code class="code">List</code>, which might be another <code class="code">Cons</code>
containing a <code class="code">List</code>, and so on&#8212;the size is unbounded.
</p>
<p>The solution is <a class="index-entry-id" id="index-indirection"></a>
<em class="dfn">indirection</em>: store the recursive part behind a
pointer. <code class="code">Box&lt;T&gt;</code> provides heap allocation with a fixed-size pointer:
</p>
<div class="example">
<pre class="example-preformatted">enum List {
    Nil,
    Cons(i32, Box&lt;List&gt;),
}

impl List {
    fn new() -&gt; Self {
        List::Nil
    }

    fn cons(head: i32, tail: List) -&gt; Self {
        List::Cons(head, Box::new(tail))
    }

    fn length(&amp;self) -&gt; usize {
        match self {
            List::Nil =&gt; 0,
            List::Cons(_, tail) =&gt; 1 + tail.length(),
        }
    }
}

// Usage
let list = List::cons(1, List::cons(2, List::cons(3, List::new())));
assert_eq!(list.length(), 3);
</pre></div>

<p>Now <code class="code">Cons</code> contains an <code class="code">i32</code> (4 bytes) and a <code class="code">Box&lt;List&gt;</code> (8
bytes on 64-bit systems), giving it a fixed size of 16 bytes (with padding).
The <code class="code">Box</code> owns the next <code class="code">List</code> node on the heap.
</p>
<p>Binary trees follow the same pattern:
</p>
<div class="example">
<pre class="example-preformatted">enum BinaryTree&lt;T&gt; {
    Empty,
    Node {
        value: T,
        left: Box&lt;BinaryTree&lt;T&gt;&gt;,
        right: Box&lt;BinaryTree&lt;T&gt;&gt;,
    },
}

impl&lt;T&gt; BinaryTree&lt;T&gt; {
    fn leaf(value: T) -&gt; Self {
        BinaryTree::Node {
            value,
            left: Box::new(BinaryTree::Empty),
            right: Box::new(BinaryTree::Empty),
        }
    }

    fn node(value: T, left: BinaryTree&lt;T&gt;, right: BinaryTree&lt;T&gt;) -&gt; Self {
        BinaryTree::Node {
            value,
            left: Box::new(left),
            right: Box::new(right),
        }
    }
}

// Usage: representing ((1 + 2) * 3)
let expr = BinaryTree::node(
    '*',
    BinaryTree::node(
        '+',
        BinaryTree::leaf('1'),
        BinaryTree::leaf('2'),
    ),
    BinaryTree::leaf('3'),
);
</pre></div>

<h4 class="subsubheading" id="Enums-vs_002e-Traits_003a-When-to-Use-Each"><span>Enums vs. Traits: When to Use Each<a class="copiable-link" href="#Enums-vs_002e-Traits_003a-When-to-Use-Each"> &#182;</a></span></h4>

<a class="index-entry-id" id="index-trait-objects"></a>
<a class="index-entry-id" id="index-dynamic-dispatch"></a>

<p>Students often ask: when should I use an enum versus a trait? Both can
represent &#8220;different kinds of things,&#8221; but they embody different trade-offs:
</p>
<p><strong class="strong">Use enums when:</strong>
</p>
<ul class="itemize mark-bullet">
<li>The set of variants is <em class="emph">fixed and known</em>. You want exhaustiveness checking.

</li><li>You need to store variants of <em class="emph">different sizes</em> efficiently. The enum&#8217;s
size is the maximum variant size plus a discriminant tag.

</li><li>Performance matters: enums dispatch statically with no indirection.

</li><li>You want to <em class="emph">prevent</em> extension. The enum is closed to new variants.
</li></ul>

<p><strong class="strong">Use traits when:</strong>
</p>
<ul class="itemize mark-bullet">
<li>The set of types is <em class="emph">open-ended</em>. Anyone can implement the trait for new
types.

</li><li>You want separate compilation. Add new implementations without recompiling
existing code.

</li><li>You need <em class="emph">dynamic dispatch</em> (<code class="code">dyn Trait</code>). Store different concrete
types in a collection.

</li><li>You want to <em class="emph">enable</em> extension. The trait is open to new implementations.
</li></ul>

<p>For example, imagine a calculator:
</p>
<div class="example">
<pre class="example-preformatted">// Enum: closed set of operations
enum Expr {
    Number(f64),
    Add(Box&lt;Expr&gt;, Box&lt;Expr&gt;),
    Multiply(Box&lt;Expr&gt;, Box&lt;Expr&gt;),
}

fn eval(expr: &amp;Expr) -&gt; f64 {
    match expr {
        Expr::Number(n) =&gt; *n,
        Expr::Add(l, r) =&gt; eval(l) + eval(r),
        Expr::Multiply(l, r) =&gt; eval(l) * eval(r),
    }
}
</pre></div>

<p>This enum-based design makes it easy to add new operations on expressions (like
<code class="code">print</code>, <code class="code">optimize</code>, <code class="code">type_check</code>) but hard to add new
expression types.
</p>
<p>Contrast with a trait-based design:
</p>
<div class="example">
<pre class="example-preformatted">trait Expr {
    fn eval(&amp;self) -&gt; f64;
}

struct Number(f64);
struct Add(Box&lt;dyn Expr&gt;, Box&lt;dyn Expr&gt;);

impl Expr for Number {
    fn eval(&amp;self) -&gt; f64 { self.0 }
}

impl Expr for Add {
    fn eval(&amp;self) -&gt; f64 { self.0.eval() + self.1.eval() }
}
</pre></div>

<p>The trait design makes it easy to add new expression types (just implement
<code class="code">Expr</code>) but hard to add new operations (must modify the trait and all
implementations).
</p>
<p>This is the classic <a class="index-entry-id" id="index-expression-problem"></a>
<em class="dfn">expression problem</em> from programming language
theory. Enums favor the &#8220;operations&#8221; dimension; traits favor the &#8220;types&#8221;
dimension. Choose based on which dimension is more likely to grow.
</p>
<h4 class="subsubheading" id="Connection-to-Tagged-Dispatch"><span>Connection to Tagged Dispatch<a class="copiable-link" href="#Connection-to-Tagged-Dispatch"> &#182;</a></span></h4>

<p>In <a class="ref" href="2_002e4.xhtml#g_t2_002e4">Multiple Representations for Abstract Data</a>, we will study <a class="index-entry-id" id="index-data_002ddirected-programming-1"></a>
<em class="dfn">data-directed programming</em> and tagged
dispatch&#8212;techniques for operating on data with type tags. Rust&#8217;s enums can be
understood as built-in, type-safe support for tagged dispatch:
</p>
<div class="example">
<pre class="example-preformatted">// Manual tagged dispatch (what you might do in C)
struct TaggedValue {
    tag: u8,
    data: [u8; 16],  // Union represented as raw bytes
}

// Rust enum (compiler-verified tagged dispatch)
enum Value {
    Integer(i64),    // tag = 0, implicitly
    Float(f64),      // tag = 1, implicitly
    Boolean(bool),   // tag = 2, implicitly
}
</pre></div>

<p>The enum provides the same functionality as manual tagging&#8212;storing one of
several types in a fixed-size space&#8212;but with crucial advantages:
</p>
<ol class="enumerate">
<li> <strong class="strong">Type safety:</strong> You cannot access the wrong variant. The <code class="code">match</code>
ensures you only use the data in the active variant.

</li><li> <strong class="strong">Memory safety:</strong> The compiler ensures the data is properly initialized
and prevents use-after-free.

</li><li> <strong class="strong">Exhaustiveness:</strong> The compiler verifies all cases are handled,
preventing the &#8220;forgot to handle tag 3&#8221; class of bugs.
</li></ol>

<p>Enums eliminate the boilerplate and danger of manual tagged dispatch while
providing the same efficiency. They are <em class="emph">zero-cost abstractions</em>&#8212;the
generated machine code is identical to hand-written tagged structures, but with
compile-time verification.
</p>
<h4 class="subsubheading" id="The-Algebra-of-Types"><span>The Algebra of Types<a class="copiable-link" href="#The-Algebra-of-Types"> &#182;</a></span></h4>

<a class="index-entry-id" id="index-type-algebra"></a>

<p>To close, let&#8217;s return to the mathematical perspective. Types form an algebra:
</p>
<ul class="itemize mark-bullet">
<li><strong class="strong">Unit type <code class="code">()</code></strong>: 1 value (the multiplicative identity)

</li><li><strong class="strong">Never type <code class="code">!</code></strong>: 0 values (represents divergence)

</li><li><strong class="strong">Product <code class="code">(A, B)</code></strong>: <em class="math">{|A| \times |B|}</em> values

</li><li><strong class="strong">Sum <code class="code">enum { A, B }</code></strong>: <em class="math">{|A| + |B|}</em> values

</li><li><strong class="strong">Function <code class="code">fn(A) -&gt; B</code></strong>: <em class="math">{|B|^{|A|}}</em> values (exponentials!)
</li></ul>

<p>These algebraic properties have practical implications. For instance, the type
<code class="code">(A, !)</code> has 0 values (since <em class="math">{|A| \times 0 = 0}</em>), making it
uninhabitable. Similarly, <code class="code">(A, ())</code> is isomorphic to <code class="code">A</code> (since
<em class="math">{|A| \times 1 = |A|}</em>).
</p>
<p>More profoundly, we can use algebraic reasoning to derive data structure
properties. The type of a list:
</p>
<div class="example">
<pre class="example-preformatted">List&lt;A&gt; = Nil | Cons(A, List&lt;A&gt;)
</pre></div>

<p>translates to the algebraic equation:
</p>
\[
  L = 1 + A \times L
\]

<p>Solving for <em class="math">L</em>:
</p>
\begin{align*}
  L &amp;= 1 + A \times L \\
  L - A \times L &amp;= 1 \\
  L(1 - A) &amp;= 1 \\
  L &amp;= \frac{1}{1-A} \\
  L &amp;= 1 + A + A^2 + A^3 + \cdots
\end{align*}

<p>This says a list is either empty (1), or one element (<em class="math">A</em>), or two elements
(<em class="math">{A^2}</em>), and so on&#8212;exactly the intuition!
</p>
<p>This algebraic perspective helps us reason about types formally, derive
isomorphisms, and understand when two different representations are
fundamentally equivalent. It is one of the deepest connections between
mathematics and programming.
</p>
<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-2_002e44a"></a>Exercise 2.44a:</strong> The <code class="code">Option&lt;T&gt;</code> type can be
thought of as encoding &#8220;a value of type <code class="code">T</code>, or nothing.&#8221; Define an
enum <code class="code">Either&lt;L, R&gt;</code> that represents &#8220;either a value of type <code class="code">L</code> or
a value of type <code class="code">R</code>.&#8221;
</p>
<p>Then implement these functions:
</p>
<div class="example">
<pre class="example-preformatted">fn map_left&lt;L, R, L2&gt;(either: Either&lt;L, R&gt;, f: impl Fn(L) -&gt; L2)
    -&gt; Either&lt;L2, R&gt;;

fn map_right&lt;L, R, R2&gt;(either: Either&lt;L, R&gt;, f: impl Fn(R) -&gt; R2)
    -&gt; Either&lt;L, R2&gt;;
</pre></div>

<p>The <code class="code">map_left</code> function applies <code class="code">f</code> to the left value if present,
leaving right values unchanged. The <code class="code">map_right</code> function is symmetric.
</p>
<p>How many values does <code class="code">Either&lt;bool, u8&gt;</code> have? How does this compare to
<code class="code">(bool, u8)</code>?
</p></blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-2_002e45a"></a>Exercise 2.45a:</strong> Extend the <code class="code">BinaryTree&lt;T&gt;</code>
type from this section with the following methods:
</p>
<div class="example">
<pre class="example-preformatted">impl&lt;T&gt; BinaryTree&lt;T&gt; {
    fn height(&amp;self) -&gt; usize;
    fn count_leaves(&amp;self) -&gt; usize;
    fn map&lt;U&gt;(self, f: impl Fn(T) -&gt; U) -&gt; BinaryTree&lt;U&gt;;
}
</pre></div>

<p>The <code class="code">height</code> method returns the maximum distance from the root to any
leaf (an empty tree has height 0, a leaf has height 1). The
<code class="code">count_leaves</code> method counts nodes with no children. The <code class="code">map</code>
method transforms every value in the tree using function <code class="code">f</code>.
</p>
<p>Then implement a <code class="code">fold</code> operation:
</p>
<div class="example">
<pre class="example-preformatted">fn fold&lt;T, A&gt;(tree: &amp;BinaryTree&lt;T&gt;,
              empty: A,
              node: impl Fn(&amp;T, A, A) -&gt; A) -&gt; A;
</pre></div>

<p>This should process the tree recursively, using <code class="code">empty</code> for
<code class="code">Empty</code> nodes and calling <code class="code">node(value, left_result, right_result)</code>
for <code class="code">Node</code>s. Verify that you can implement <code class="code">height</code>,
<code class="code">count_leaves</code>, and a summing operation using <code class="code">fold</code>.
</p></blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-2_002e46a"></a>Exercise 2.46a:</strong> In this exercise, we explore
the relationship between enums and the expression problem.
</p>
<p>Define an enum <code class="code">JsonValue</code> representing JSON data:
</p>
<div class="example">
<pre class="example-preformatted">enum JsonValue {
    Null,
    Boolean(bool),
    Number(f64),
    String(String),
    Array(Vec&lt;JsonValue&gt;),
    Object(std::collections::HashMap&lt;String, JsonValue&gt;),
}
</pre></div>

<p>Implement the following operations:
</p>
<ol class="enumerate">
<li> <code class="code">fn pretty_print(value: &amp;JsonValue) -&gt; String</code> &#8212; formats the JSON with
indentation.

</li><li> <code class="code">fn count_values(value: &amp;JsonValue) -&gt; usize</code> &#8212; counts total values
(including nested ones).

</li><li> <code class="code">fn find_strings(value: &amp;JsonValue) -&gt; Vec&lt;&amp;str&gt;</code> &#8212; extracts all string
values.
</li></ol>

<p>Now consider an alternative design using traits instead of enums. Sketch what
the <code class="code">JsonValue</code> trait would look like, and explain:
</p>
<ul class="itemize mark-bullet">
<li>Which approach (enum or trait) makes it easier to add a new operation like
<code class="code">to_yaml</code>?

</li><li>Which approach makes it easier to add a new JSON type like <code class="code">Date</code>?

</li><li>If you needed both extensibility dimensions, how might you combine enums and
traits?
</li></ul>
</blockquote>

</div>
</div>
<div class="footnotes-segment">
<hr />
<h4 class="footnotes-heading">Footnotes</h4>

<h5 class="footnote-body-heading"><a id="FOOT67" href="#DOCF67">(67)</a></h5>
<p>The use of the word &#8220;closure&#8221; here comes from abstract
algebra, where a set of elements is said to be closed under an operation if
applying the operation to elements in the set produces an element that is again
an element of the set.  The Lisp community also (unfortunately) uses the word
&#8220;closure&#8221; to describe a totally unrelated concept: A closure is an
implementation technique for representing procedures with free variables.  We
do not use the word &#8220;closure&#8221; in this second sense in this book.  </p>
<h5 class="footnote-body-heading"><a id="FOOT68" href="#DOCF68">(68)</a></h5>
<p>The notion that a means of combination should satisfy
closure is a straightforward idea.  Unfortunately, the data combiners provided
in many popular programming languages do not satisfy closure, or make closure
cumbersome to exploit.  In Fortran or Basic, one typically combines data
elements by assembling them into arrays&#8212;but one cannot form arrays whose
elements are themselves arrays.  Pascal and C admit structures whose elements
are structures.  However, this requires that the programmer manipulate pointers
explicitly, and adhere to the restriction that each field of a structure can
contain only elements of a prespecified form.  Unlike Lisp with its pairs,
these languages have no built-in general-purpose glue that makes it easy to
manipulate compound data in a uniform way.  This limitation lies behind Alan
Perlis&#8217;s comment in his foreword to this book: &#8220;In Pascal the plethora of
declarable data structures induces a specialization within functions that
inhibits and penalizes casual cooperation.  It is better to have 100 functions
operate on one data structure than to have 10 functions operate on 10 data
structures.&#8221;</p>
<h5 class="footnote-body-heading"><a id="FOOT69" href="#DOCF69">(69)</a></h5>
<p>Rust&#8217;s <code class="code">Vec&lt;T&gt;</code> is a growable array stored on
the heap.  Unlike Scheme&#8217;s linked lists, vectors provide O(1) indexed access
but O(n) insertion at the front.  For linked-list semantics, Rust provides
<code class="code">LinkedList&lt;T&gt;</code>, though vectors are preferred for most use cases due to
better cache locality.</p>
<h5 class="footnote-body-heading"><a id="FOOT70" href="#DOCF70">(70)</a></h5>
<p>In
Rust, indexing a vector or slice is straightforward: <code class="code">list[0]</code> gets the
first element, <code class="code">list[1]</code> gets the second, and so on.  Slicing with
<code class="code">&amp;list[1..]</code> returns a reference to all elements after the first.</p>
<h5 class="footnote-body-heading"><a id="FOOT71" href="#DOCF71">(71)</a></h5>
<p>It&#8217;s remarkable how much energy in the standardization of
Lisp dialects has been dissipated in arguments that are literally over nothing:
Should <code class="code">nil</code> be an ordinary name?  Should the value of <code class="code">nil</code> be a
symbol?  Should it be a list?  Should it be a pair?  In Scheme, <code class="code">nil</code> is
an ordinary name, which we use in this section as a variable whose value is the
end-of-list marker (just as <code class="code">true</code> is an ordinary variable that has a true
value).  Other dialects of Lisp, including Common Lisp, treat <code class="code">nil</code> as a
special symbol.  The authors of this book, who have endured too many language
standardization brawls, would like to avoid the entire issue.  Once we have
introduced quotation in <a class="ref" href="2_002e3.xhtml#g_t2_002e3">Symbolic Data</a>, we will denote the empty list as
<code class="code">'()</code> and dispense with the variable <code class="code">nil</code> entirely.</p>
<h5 class="footnote-body-heading"><a id="FOOT72" href="#DOCF72">(72)</a></h5>
<p>Rust&#8217;s <code class="code">Iterator::map</code> is lazy&#8212;it doesn&#8217;t compute values until consumed.
For parallel mapping over multiple iterators, use <code class="code">zip</code>:
</p>
<div class="example">
<pre class="example-preformatted">let a = [1, 2, 3];
let b = [40, 50, 60];
let c = [700, 800, 900];

a.iter().zip(b.iter()).zip(c.iter())
    .map(|((&amp;x, &amp;y), &amp;z)| x + y + z)
    .collect::&lt;Vec&lt;_&gt;&gt;()
// =&gt; [741, 852, 963]

a.iter().zip(b.iter())
    .map(|(&amp;x, &amp;y)| x + 2 * y)
    .collect::&lt;Vec&lt;_&gt;&gt;()
// =&gt; [9, 12, 15]
</pre></div>
<h5 class="footnote-body-heading"><a id="FOOT73" href="#DOCF73">(73)</a></h5>
<p>This is, in fact,
precisely the <code class="code">fringe</code> procedure from <a class="ref" href="#Exercise-2_002e28">Exercise 2.28</a>.  Here we&#8217;ve
renamed it to emphasize that it is part of a family of general
sequence-manipulation procedures.</p>
<h5 class="footnote-body-heading"><a id="FOOT74" href="#DOCF74">(74)</a></h5>
<p>Richard <a class="ref" href="References.xhtml#Waters-_00281979_0029">Waters (1979)</a> developed a
program that automatically analyzes traditional Fortran programs, viewing them
in terms of maps, filters, and accumulations.  He found that fully 90 percent
of the code in the Fortran Scientific Subroutine Package fits neatly into this
paradigm.  One of the reasons for the success of Lisp as a programming language
is that lists provide a standard medium for expressing ordered collections so
that they can be manipulated using higher-order operations.  The programming
language APL owes much of its power and appeal to a similar choice. In APL all
data are represented as arrays, and there is a universal and convenient set of
generic operators for all sorts of array operations.</p>
<h5 class="footnote-body-heading"><a id="FOOT75" href="#DOCF75">(75)</a></h5>
<p>According to <a class="ref" href="References.xhtml#Knuth-1981">Knuth 1981</a>, this rule was formulated by
W. G. Horner early in the nineteenth century, but the method was actually used
by Newton over a hundred years earlier.  Horner&#8217;s rule evaluates the polynomial
using fewer additions and multiplications than does the straightforward method
of first computing <em class="math">{a_n x^n}</em>, then adding
<em class="math">{a_{n-1}x^{n-1}}</em>, and so on.  In fact, it is possible to prove
that any algorithm for evaluating arbitrary polynomials must use at least as
many additions and multiplications as does Horner&#8217;s rule, and thus Horner&#8217;s
rule is an optimal algorithm for polynomial evaluation.  This was proved (for
the number of additions) by A. M. Ostrowski in a 1954 paper that essentially
founded the modern study of optimal algorithms.  The analogous statement for
multiplications was proved by V. Y. Pan in 1966.  The book by <a class="ref" href="References.xhtml#Borodin-and-Munro-_00281975_0029">Borodin and Munro (1975)</a> 
provides an overview of these and other results about optimal
algorithms.</p>
<h5 class="footnote-body-heading"><a id="FOOT76" href="#DOCF76">(76)</a></h5>
<p>This definition uses the extended
version of <code class="code">map</code> that takes multiple sequences, as described in
<a class="ref" href="#g_t2_002e2_002e1">Representing Sequences</a>.  In Rust, we achieve this with the <code class="code">zip</code> iterator adapter.</p>
<h5 class="footnote-body-heading"><a id="FOOT77" href="#DOCF77">(77)</a></h5>
<p>This approach to nested
mappings was shown to us by David Turner, whose languages KRC and Miranda
provide elegant formalisms for dealing with these constructs.  The examples in
this section (see also <a class="ref" href="#Exercise-2_002e42">Exercise 2.42</a>) are adapted from <a class="ref" href="References.xhtml#Turner-1981">Turner 1981</a>.  In
<a class="ref" href="3_002e5.xhtml#g_t3_002e5_002e3">Exploiting the Stream Paradigm</a>, we&#8217;ll see how this approach generalizes to infinite
sequences.</p>
<h5 class="footnote-body-heading"><a id="FOOT78" href="#DOCF78">(78)</a></h5>
<p>We&#8217;re representing a pair here as a list of two
elements rather than as a Lisp pair.  Thus, the &#8220;pair&#8221; <em class="math">{(i, j)}</em> is
represented as <code class="code">(list i j)</code>, not <code class="code">(cons i j)</code>.</p>
<h5 class="footnote-body-heading"><a id="FOOT79" href="#DOCF79">(79)</a></h5>
<p>The set <em class="math">{S - x}</em> is the set of all
elements of <em class="math">S</em>, excluding <em class="math">x</em>.</p>
<h5 class="footnote-body-heading"><a id="FOOT80" href="#DOCF80">(80)</a></h5>
<p>Semicolons in Scheme code are used to introduce
<a class="index-entry-id" id="index-comments"></a>
<em class="dfn">comments</em>.  Everything from the semicolon to the end of the line is
ignored by the interpreter.  In this book we don&#8217;t use many comments; we try to
make our programs self-documenting by using descriptive names.</p>
<h5 class="footnote-body-heading"><a id="FOOT81" href="#DOCF81">(81)</a></h5>
<p>The picture
language is based on the language Peter Henderson created to construct images
like M.C. Escher&#8217;s &#8220;Square Limit&#8221; woodcut (see <a class="ref" href="References.xhtml#Henderson-1982">Henderson 1982</a>).  The woodcut
incorporates a repeated scaled pattern, similar to the arrangements drawn using
the <code class="code">square_limit</code> procedure in this section.</p>
<h5 class="footnote-body-heading"><a id="FOOT82" href="#DOCF82">(82)</a></h5>
<p>William Barton Rogers (1804-1882) was the founder
and first president of <abbr class="abbr">MIT</abbr>.  A geologist and talented teacher, he
taught at William and Mary College and at the University of Virginia.  In 1859
he moved to Boston, where he had more time for research, worked on a plan for
establishing a &#8220;polytechnic institute,&#8221; and served as Massachusetts&#8217;s first
State Inspector of Gas Meters.
</p>
<p>When <abbr class="abbr">MIT</abbr> was established in 1861, Rogers was elected its first
president.  Rogers espoused an ideal of &#8220;useful learning&#8221; that was different
from the university education of the time, with its overemphasis on the
classics, which, as he wrote, &#8220;stand in the way of the broader, higher and
more practical instruction and discipline of the natural and social sciences.&#8221;
This education was likewise to be different from narrow trade-school education.
In Rogers&#8217;s words:
</p>
<blockquote class="quotation">
<p>The world-enforced distinction between the practical and the scientific worker
is utterly futile, and the whole experience of modern times has demonstrated
its utter worthlessness.
</p></blockquote>

<p>Rogers served as president of <abbr class="abbr">MIT</abbr> until 1870, when he resigned due to
ill health.  In 1878 the second president of <abbr class="abbr">MIT</abbr>, John Runkle,
resigned under the pressure of a financial crisis brought on by the Panic of
1873 and strain of fighting off attempts by Harvard to take over <abbr class="abbr">MIT</abbr>.
Rogers returned to hold the office of president until 1881.
</p>
<p>Rogers collapsed and died while addressing <abbr class="abbr">MIT</abbr>&#8217;s graduating class at
the commencement exercises of 1882.  Runkle quoted Rogers&#8217;s last words in a
memorial address delivered that same year:
</p>
<blockquote class="quotation">
<p>&#8220;As I stand here today and see what the Institute is, &#8230; I call to mind
the beginnings of science.  I remember one hundred and fifty years ago Stephen
Hales published a pamphlet on the subject of illuminating gas, in which he
stated that his researches had demonstrated that 128 grains of bituminous coal
&#8211; &#8221; &#8220;Bituminous coal,&#8221; these were his last words on earth.  Here he bent
forward, as if consulting some notes on the table before him, then slowly
regaining an erect position, threw up his hands, and was translated from the
scene of his earthly labors and triumphs to &#8220;the tomorrow of death,&#8221; where
the mysteries of life are solved, and the disembodied spirit finds unending
satisfaction in contemplating the new and still unfathomable mysteries of the
infinite future.
</p></blockquote>

<p>In the words of Francis A. Walker (<abbr class="abbr">MIT</abbr>&#8217;s third president):
</p>
<blockquote class="quotation">
<p>All his life he had borne himself most faithfully and heroically, and he died
as so good a knight would surely have wished, in harness, at his post, and in
the very part and act of public duty.
</p></blockquote>
<h5 class="footnote-body-heading"><a id="FOOT83" href="#DOCF83">(83)</a></h5>
<p>Equivalently, we could write
</p>
<div class="example">
<pre class="example-preformatted">let flipped_pairs = square_of_four(identity, flip_vert, identity, flip_vert);
</pre></div>
<h5 class="footnote-body-heading"><a id="FOOT84" href="#DOCF84">(84)</a></h5>
<p><code class="code">Rotate180</code> rotates a
painter by 180 degrees (see <a class="ref" href="#Exercise-2_002e50">Exercise 2.50</a>).  Instead of <code class="code">rotate180</code>
we could say <code class="code">(compose flip-vert flip-horiz)</code>, using the <code class="code">compose</code>
procedure from <a class="ref" href="1_002e3.xhtml#Exercise-1_002e42">Exercise 1.42</a>.</p>
<h5 class="footnote-body-heading"><a id="FOOT85" href="#DOCF85">(85)</a></h5>
<p><code class="code">Frame-coord-map</code> uses the vector operations described
in <a class="ref" href="#Exercise-2_002e46">Exercise 2.46</a> below, which we assume have been implemented using some
representation for vectors.  Because of data abstraction, it doesn&#8217;t matter
what this vector representation is, so long as the vector operations behave
correctly.</p>
<h5 class="footnote-body-heading"><a id="FOOT86" href="#DOCF86">(86)</a></h5>
<p><code class="code">Segments-&gt;painter</code> uses the
representation for line segments described in <a class="ref" href="#Exercise-2_002e48">Exercise 2.48</a> below.  It
also uses the <code class="code">for-each</code> procedure described in <a class="ref" href="#Exercise-2_002e23">Exercise 2.23</a>.</p>
<h5 class="footnote-body-heading"><a id="FOOT87" href="#DOCF87">(87)</a></h5>
<p>For example, the <code class="code">rogers</code> painter of <a class="ref" href="#Figure-2_002e11">Figure 2.11</a> was
constructed from a gray-level image.  For each point in a given frame, the
<code class="code">rogers</code> painter determines the point in the image that is mapped to it
under the frame coordinate map, and shades it accordingly.  By allowing
different types of painters, we are capitalizing on the abstract data idea
discussed in <a class="ref" href="2_002e1.xhtml#g_t2_002e1_002e3">What Is Meant by Data?</a>, where we argued that a rational-number
representation could be anything at all that satisfies an appropriate
condition.  Here we&#8217;re using the fact that a painter can be implemented in any
way at all, so long as it draws something in the designated frame.  
<a class="ref" href="2_002e1.xhtml#g_t2_002e1_002e3">What Is Meant by Data?</a> also showed how pairs could be implemented as procedures.  Painters
are our second example of a procedural representation for data.</p>
<h5 class="footnote-body-heading"><a id="FOOT88" href="#DOCF88">(88)</a></h5>
<p><code class="code">Rotate90</code> is a pure rotation only for square frames,
because it also stretches and shrinks the image to fit into the rotated frame.</p>
<h5 class="footnote-body-heading"><a id="FOOT89" href="#DOCF89">(89)</a></h5>
<p>The diamond-shaped
images in <a class="ref" href="#Figure-2_002e10">Figure 2.10</a> and <a class="ref" href="#Figure-2_002e11">Figure 2.11</a> were created with
<code class="code">squash_inwards</code> applied to <code class="code">wave</code> and <code class="code">rogers</code>.</p>
<h5 class="footnote-body-heading"><a id="FOOT90" href="#DOCF90">(90)</a></h5>
<p>Section <a class="ref" href="3_002e3.xhtml#g_t3_002e3_002e4">A Simulator for Digital Circuits</a> describes one such language.</p>
</div>
<hr />
<div class="nav-panel">
<p>
Next: <a href="2_002e3.xhtml#g_t2_002e3" accesskey="n" rel="next">Symbolic Data</a>, Previous: <a href="2_002e1.xhtml#g_t2_002e1" accesskey="p" rel="prev">Introduction to Data Abstraction</a>, Up: <a href="Chapter-2.xhtml" accesskey="u" rel="up">Building Abstractions with Data</a> &#160; [<a href="index.xhtml#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Term-Index.xhtml" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
