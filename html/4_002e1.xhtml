<!DOCTYPE html>
<html>
<!-- Created by GNU Texinfo 7.1, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>4.1 (Structure and Interpretation of Computer Programs, 2e)</title>

<meta name="description" content="4.1 (Structure and Interpretation of Computer Programs, 2e)">
<meta name="keywords" content="4.1 (Structure and Interpretation of Computer Programs, 2e)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2any">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="index.xhtml" rel="start" title="Top">
<link href="Term-Index.xhtml" rel="index" title="Term Index">
<link href="index.xhtml#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Chapter-4.xhtml" rel="up" title="Chapter 4">
<link href="4_002e2.xhtml#g_t4_002e2" rel="next" title="4.2">
<link href="Chapter-4.xhtml" rel="prev" title="Chapter 4">
<style type="text/css">
<!--
a.copiable-link {visibility: hidden; text-decoration: none; line-height: 0em}
div.example {margin-left: 3.2em}
span.r {font-family: initial; font-weight: normal; font-style: normal}
span:hover a.copiable-link {visibility: visible}
ul.mark-bullet {list-style-type: disc}
-->
</style>


</head>

<body lang="en">
<div class="section-level-extent" id="g_t4_002e1">
<div class="nav-panel">
<p>
Next: <a href="4_002e2.xhtml#g_t4_002e2" accesskey="n" rel="next">Variations on a Scheme &mdash; Lazy Evaluation</a>, Previous: <a href="Chapter-4.xhtml" accesskey="p" rel="prev">Metalinguistic Abstraction</a>, Up: <a href="Chapter-4.xhtml" accesskey="u" rel="up">Metalinguistic Abstraction</a> &nbsp; [<a href="index.xhtml#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Term-Index.xhtml" title="Index" rel="index">Index</a>]</p>
</div>
<h3 class="section" id="The-Metacircular-Evaluator"><span>4.1 The Metacircular Evaluator<a class="copiable-link" href="#The-Metacircular-Evaluator"> &para;</a></span></h3>

<p>Our evaluator for Lisp will be implemented as a Lisp program.  It may seem
circular to think about evaluating Lisp programs using an evaluator that is
itself implemented in Lisp.  However, evaluation is a process, so it is
appropriate to describe the evaluation process using Lisp, which, after all, is
our tool for describing processes.<a class="footnote" id="DOCF198" href="#FOOT198"><sup>198</sup></a>
An evaluator that is written in the same language that it evaluates is said to
be <a class="index-entry-id" id="index-metacircular"></a>
<em class="dfn">metacircular</em>.
</p>
<p>The metacircular evaluator is essentially a Scheme formulation of the
environment model of evaluation described in <a class="ref" href="3_002e2.xhtml#g_t3_002e2">The Environment Model of Evaluation</a>.  Recall that
the model has two basic parts:
</p>
<ol class="enumerate">
<li> To evaluate a combination (a compound expression other than a special form),
evaluate the subexpressions and then apply the value of the operator
subexpression to the values of the operand subexpressions.

</li><li> To apply a compound procedure to a set of arguments, evaluate the body of the
procedure in a new environment.  To construct this environment, extend the
environment part of the procedure object by a frame in which the formal
parameters of the procedure are bound to the arguments to which the procedure
is applied.

</li></ol>

<p>These two rules describe the essence of the evaluation process, a basic cycle
in which expressions to be evaluated in environments are reduced to procedures
to be applied to arguments, which in turn are reduced to new expressions to be
evaluated in new environments, and so on, until we get down to symbols, whose
values are looked up in the environment, and to primitive procedures, which are
applied directly (see <a class="ref" href="#Figure-4_002e1">Figure 4.1</a>).<a class="footnote" id="DOCF199" href="#FOOT199"><sup>199</sup></a> 
This evaluation cycle will be embodied by the interplay between the two
critical procedures in the evaluator, <code class="code">eval</code> and <code class="code">apply</code>, which are
described in <a class="ref" href="#g_t4_002e1_002e1">The Core of the Evaluator</a> (see <a class="ref" href="#Figure-4_002e1">Figure 4.1</a>).
</p>
<div class="float">
<a class="anchor" id="Figure-4_002e1"></a><img class="image" src="fig/chap4/Fig4.1a.std.svg" alt="fig/chap4/Fig4.1a">
<div class="caption"><p><strong class="strong">Figure 4.1:</strong> The <code class="code">eval</code>-<code class="code">apply</code> cycle exposes the essence of a computer language.</p></div></div>
<p>The implementation of the evaluator will depend upon procedures that define the
<a class="index-entry-id" id="index-syntax"></a>
<em class="dfn">syntax</em> of the expressions to be evaluated.  We will use data
abstraction to make the evaluator independent of the representation of the
language.  For example, rather than committing to a choice that an assignment
is to be represented by a list beginning with the symbol <code class="code">set!</code> we use an
abstract predicate <code class="code">is_assignment</code> to test for an assignment, and we use
abstract selectors <code class="code">assignment_variable</code> and <code class="code">assignment_value</code> to
access the parts of an assignment.  Implementation of expressions will be
described in detail in <a class="ref" href="#g_t4_002e1_002e2">Representing Expressions</a>.  There are also operations,
described in <a class="ref" href="#g_t4_002e1_002e3">Evaluator Data Structures</a>, that specify the representation of procedures
and environments.  For example, <code class="code">make_procedure</code> constructs compound
procedures, <code class="code">lookup_variable_value</code> accesses the values of variables, and
<code class="code">apply_primitive_procedure</code> applies a primitive procedure to a given list
of arguments.
</p>

<hr>
<div class="subsection-level-extent" id="g_t4_002e1_002e1">
<h4 class="subsection" id="The-Core-of-the-Evaluator"><span>4.1.1 The Core of the Evaluator<a class="copiable-link" href="#The-Core-of-the-Evaluator"> &para;</a></span></h4>

<p>The evaluation process can be described as the interplay between two
procedures: <code class="code">eval</code> and <code class="code">apply</code>.
</p>
<h4 class="subsubheading" id="Eval"><span>Eval<a class="copiable-link" href="#Eval"> &para;</a></span></h4>

<p><code class="code">Eval</code> takes as arguments an expression and an environment.  It classifies
the expression and directs its evaluation.  <code class="code">Eval</code> is structured as a case
analysis of the syntactic type of the expression to be evaluated.  In order to
keep the procedure general, we express the determination of the type of an
expression abstractly, making no commitment to any particular representation
for the various types of expressions.  Each type of expression has a predicate
that tests for it and an abstract means for selecting its parts.  This
<a class="index-entry-id" id="index-abstract-syntax"></a>
<em class="dfn">abstract syntax</em> makes it easy to see how we can change the syntax of
the language by using the same evaluator, but with a different collection of
syntax procedures.
</p>
<p><b class="b">Primitive expressions</b>
</p>
<ul class="itemize mark-bullet">
<li>For self-evaluating expressions, such as numbers, <code class="code">eval</code> returns the
expression itself.

</li><li><code class="code">Eval</code> must look up variables in the environment to find their values.

</li></ul>

<p><b class="b">Special forms</b>
</p>
<ul class="itemize mark-bullet">
<li>For quoted expressions, <code class="code">eval</code> returns the expression that was quoted.

</li><li>An assignment to (or a definition of) a variable must recursively call
<code class="code">eval</code> to compute the new value to be associated with the variable.  The
environment must be modified to change (or create) the binding of the variable.

</li><li>An <code class="code">if</code> expression requires special processing of its parts, so as to
evaluate the consequent if the predicate is true, and otherwise to evaluate the
alternative.

</li><li>A <code class="code">lambda</code> expression must be transformed into an applicable procedure by
packaging together the parameters and body specified by the <code class="code">lambda</code>
expression with the environment of the evaluation.

</li><li>A <code class="code">begin</code> expression requires evaluating its sequence of expressions in
the order in which they appear.

</li><li>A case analysis (<code class="code">cond</code>) is transformed into a nest of <code class="code">if</code>
expressions and then evaluated.

</li></ul>

<p><b class="b">Combinations</b>
</p>
<ul class="itemize mark-bullet">
<li>For a procedure application, <code class="code">eval</code> must recursively evaluate the operator
part and the operands of the combination.  The resulting procedure and
arguments are passed to <code class="code">apply</code>, which handles the actual procedure
application.

</li></ul>

<p>Here is the definition of <code class="code">eval</code>:
</p>
<p><b class="b">Rust:</b> Pattern matching on an enum provides exhaustive dispatch. Evaluation
returns both a value and a potentially updated environment (threading state
functionally):
</p><div class="example">
<pre class="example-preformatted">pub fn eval(
    expr: &amp;Expr,
    env: Environment&lt;Value&gt;,
) -&gt; Result&lt;(Value, Environment&lt;Value&gt;), EvalError&gt; {
    match expr {
        // Self-evaluating expressions
        Expr::Number(n) =&gt; Ok((Value::Number(*n), env)),
        Expr::String(s) =&gt; Ok((Value::String(s.clone()), env)),

        // Variable lookup
        Expr::Symbol(name) =&gt; {
            let value = env
                .lookup(name)
                .ok_or_else(|| EvalError::UnboundVariable(name.clone()))?
                .clone();
            Ok((value, env))
        }

        // Quote: return the expression unevaluated
        Expr::Quote(quoted) =&gt; {
            let value = expr_to_value(quoted)?;
            Ok((value, env))
        }

        // If: evaluate predicate, then consequent or alternative
        Expr::If { predicate, consequent, alternative } =&gt; {
            let (pred_value, env) = eval(predicate, env)?;
            if is_true(&amp;pred_value) {
                eval(consequent, env)
            } else {
                eval(alternative, env)
            }
        }

        // Lambda: create a closure capturing the current environment
        Expr::Lambda { params, body } =&gt; {
            let closure = Value::Closure {
                params: params.clone(),
                body: body.clone(),
                env: env.clone(), // Captured by O(1) clone
                self_name: None,
            };
            Ok((closure, env))
        }

        // Define: evaluate value and bind in a new environment
        Expr::Define { name, value } =&gt; {
            let (val, env) = eval(value, env)?;
            let new_env = env.define(name.clone(), val);
            Ok((Value::Void, new_env))
        }

        // Application: evaluate operator and operands, then apply
        Expr::Application { operator, operands } =&gt; {
            let (proc, env) = eval(operator, env)?;
            let (args, env) = eval_list(operands, env)?;
            let result = apply(proc, args)?;
            Ok((result, env))
        }
        _ =&gt; Err(EvalError::InvalidSyntax(format!(&quot;Unknown: {:?}&quot;, expr))),
    }
}
</pre></div>

<p>For clarity, <code class="code">eval</code> has been implemented as a case analysis using
<code class="code">match</code>.  The disadvantage of this is that our procedure handles only a few
distinguishable types of expressions, and no new ones can be defined without
editing the definition of <code class="code">eval</code>.  In most Lisp implementations,
dispatching on the type of an expression is done in a data-directed style.
This allows a user to add new types of expressions that <code class="code">eval</code> can
distinguish, without modifying the definition of <code class="code">eval</code> itself.  (See
<a class="ref" href="#Exercise-4_002e3">Exercise 4.3</a>.)
</p>
<h4 class="subsubheading" id="Apply"><span>Apply<a class="copiable-link" href="#Apply"> &para;</a></span></h4>

<p><code class="code">Apply</code> takes two arguments, a procedure and a list of arguments to which
the procedure should be applied.  <code class="code">Apply</code> classifies procedures into two
kinds: It calls <code class="code">apply_primitive_procedure</code> to apply primitives; it
applies compound procedures by sequentially evaluating the expressions that
make up the body of the procedure.  The environment for the evaluation of the
body of a compound procedure is constructed by extending the base environment
carried by the procedure to include a frame that binds the parameters of the
procedure to the arguments to which the procedure is to be applied.  Here is
the definition of <code class="code">apply</code>:
</p>
<p><b class="b">Rust:</b>
</p><div class="example">
<pre class="example-preformatted">pub fn apply(procedure: Value, args: Vec&lt;Value&gt;) -&gt; Result&lt;Value, EvalError&gt; {
    match procedure {
        Value::Primitive(_, func) =&gt; func(&amp;args),
        Value::Closure { params, body, env, .. } =&gt; {
            // Extend with parameter bindings
            let bindings: Vec&lt;(String, Value)&gt; =
                params.into_iter().zip(args).collect();
            let new_env = env.extend(bindings);

            // Evaluate body; ignore final environment in apply
            let (result, _) = eval_sequence(&amp;body, new_env)?;
            Ok(result)
        }
        _ =&gt; Err(EvalError::TypeError(format!(&quot;Not a procedure: {:?}&quot;, procedure))),
    }
}
</pre></div>

<h4 class="subsubheading" id="Procedure-arguments"><span>Procedure arguments<a class="copiable-link" href="#Procedure-arguments"> &para;</a></span></h4>

<p>When <code class="code">eval</code> processes a procedure application, it uses
<code class="code">eval_list</code> to produce the list of arguments to which the procedure
is to be applied. <code class="code">Eval_list</code> takes as an argument the operands of
the combination.  It evaluates each operand in turn, threading the
environment through the evaluations, and returns a list of the
corresponding values:
</p>
<div class="example">
<pre class="example-preformatted">fn eval_list(
    exprs: &amp;[Expr],
    mut env: Environment&lt;Value&gt;,
) -&gt; Result&lt;(Vec&lt;Value&gt;, Environment&lt;Value&gt;), EvalError&gt; {
    let mut values = Vec::with_capacity(exprs.len());
    for expr in exprs {
        let (val, new_env) = eval(expr, env)?;
        values.push(val);
        env = new_env;
    }
    Ok((values, env))
}
</pre></div>

<h4 class="subsubheading" id="Conditionals"><span>Conditionals<a class="copiable-link" href="#Conditionals"> &para;</a></span></h4>

<p><code class="code">Eval_if</code> evaluates the predicate part of an <code class="code">if</code> expression in the
given environment.  If the result is true, <code class="code">eval_if</code> evaluates the
consequent, otherwise it evaluates the alternative. Notice how the
environment is threaded through the evaluations:
</p>
<div class="example">
<pre class="example-preformatted">fn eval_if(
    predicate: &amp;Expr,
    consequent: &amp;Expr,
    alternative: &amp;Expr,
    env: Environment&lt;Value&gt;,
) -&gt; Result&lt;(Value, Environment&lt;Value&gt;), EvalError&gt; {
    let (pred_value, env) = eval(predicate, env)?;
    if is_true(&amp;pred_value) {
        eval(consequent, env)
    } else {
        eval(alternative, env)
    }
}
</pre></div>

<p>The use of <code class="code">is_true</code> in <code class="code">eval_if</code> highlights the issue of the
connection between an implemented language and an implementation language.  The
<code class="code">predicate</code> is evaluated in the language being implemented and thus
yields a value in that language.  The interpreter predicate <code class="code">is_true</code>
translates that value into a value that can be tested by the <code class="code">if</code> in the
implementation language: The metacircular representation of truth might not be
the same as that of the underlying Rust.<a class="footnote" id="DOCF200" href="#FOOT200"><sup>200</sup></a>
</p>
<h4 class="subsubheading" id="Sequences"><span>Sequences<a class="copiable-link" href="#Sequences"> &para;</a></span></h4>

<p><code class="code">Eval_sequence</code> is used by <code class="code">apply</code> to evaluate the sequence of
expressions in a procedure body and by <code class="code">eval</code> to evaluate the sequence of
expressions in a <code class="code">begin</code> expression.  It takes as arguments a sequence of
expressions and an environment, and evaluates the expressions in the order in
which they occur.  Each evaluation may return a new environment which is
passed to the next step:
</p>
<div class="example">
<pre class="example-preformatted">fn eval_sequence(
    exprs: &amp;[Expr],
    mut env: Environment&lt;Value&gt;,
) -&gt; Result&lt;(Value, Environment&lt;Value&gt;), EvalError&gt; {
    if exprs.is_empty() {
        return Ok((Value::Void, env));
    }

    let mut result = Value::Void;
    for expr in exprs {
        let (val, new_env) = eval(expr, env)?;
        result = val;
        env = new_env;
    }
    Ok((result, env))
}
</pre></div>

<h4 class="subsubheading" id="Assignments-and-definitions"><span>Assignments and definitions<a class="copiable-link" href="#Assignments-and-definitions"> &para;</a></span></h4>

<p>The following procedure handles definitions of variables.  It calls <code class="code">eval</code>
to find the value to be assigned and returns a new environment with the
binding installed:
</p>
<div class="example">
<pre class="example-preformatted">fn eval_definition(
    var: String,
    value_expr: &amp;Expr,
    env: Environment&lt;Value&gt;,
) -&gt; Result&lt;(Value, Environment&lt;Value&gt;), EvalError&gt; {
    let (value, env) = eval(value_expr, env)?;
    let new_env = env.define(var, value);
    Ok((Value::Void, new_env))
}
</pre></div>

<p>We have chosen here to return <code class="code">Value::Void</code> as the value of a
definition.<a class="footnote" id="DOCF201" href="#FOOT201"><sup>201</sup></a>
Since we are using a functional state threading model, we do not provide a
traditional mutable <code class="code">eval_assignment</code> here; instead, the updated
environment returned by <code class="code">eval_definition</code> (or a similar <code class="code">set!</code>
implementation) would be used by subsequent evaluations.
</p>
<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-4_002e1"></a>Exercise 4.1:</strong> Notice that in our Rust
implementation of <code class="code">eval_list</code>, we have explicitly chosen a left-to-right
evaluation order by threading the environment through the evaluations of the
operands.
</p>
<p>If we were using an environment model with mutation (and thus not threading the
environment), we might have written <code class="code">eval_list</code> using <code class="code">map</code> or a
similar construct.  Write a version of <code class="code">eval_list</code> that evaluates operands
from left to right regardless of the underlying language&rsquo;s evaluation order for
arguments.  Also write a version of <code class="code">eval_list</code> that evaluates operands
from right to left.
</p></blockquote>

<hr>
</div>
<div class="subsection-level-extent" id="g_t4_002e1_002e2">
<h4 class="subsection" id="Representing-Expressions"><span>4.1.2 Representing Expressions<a class="copiable-link" href="#Representing-Expressions"> &para;</a></span></h4>

<p>The evaluator is reminiscent of the symbolic differentiation program discussed
in <a class="ref" href="2_002e3.xhtml#g_t2_002e3_002e2">Example: Symbolic Differentiation</a>.  Both programs operate on symbolic expressions.  In
both programs, the result of operating on a compound expression is determined
by operating recursively on the pieces of the expression and combining the
results in a way that depends on the type of the expression.  In both programs
we used data abstraction to decouple the general rules of operation from the
details of how expressions are represented.  In the differentiation program
this meant that the same differentiation procedure could deal with algebraic
expressions in prefix form, in infix form, or in some other form.  For the
evaluator, this means that the syntax of the language being evaluated is
determined solely by the procedures that classify and extract pieces of
expressions.
</p>
<p>Here is the specification of the syntax of our language:
</p>
<ul class="itemize mark-bullet">
<li>The self-evaluating items are numbers, strings, and booleans:

<div class="example">
<pre class="example-preformatted">enum Expr {
    Number(i64),
    String(String),
    Bool(bool),
    // ...
}
</pre></div>

</li><li>Variables are represented by symbols:

<div class="example">
<pre class="example-preformatted">enum Expr {
    Symbol(String),
    // ...
}
</pre></div>

</li><li>Quotations have the form <code class="code">(quote ⟨<var class="var">text_of_quotation</var>⟩)</code>:

<div class="example">
<pre class="example-preformatted">enum Expr {
    Quote(Box&lt;Expr&gt;),
    // ...
}
</pre></div>

</li><li>Definitions have the form <code class="code">let ⟨<var class="var">var</var>⟩ = ⟨<var class="var">value</var>⟩;</code> (desugared from
<code class="code">(define ⟨<var class="var">var</var>⟩ ⟨<var class="var">value</var>⟩)</code>):
<div class="example">
<pre class="example-preformatted">enum Expr {
    Define { name: String, value: Box&lt;Expr&gt; },
    // ...
}
</pre></div>

</li><li><code class="code">Lambda</code> expressions represent anonymous functions <code class="code">|⟨<var class="var">params</var>⟩| { ⟨<var class="var">body</var>⟩ }</code>:

<div class="example">
<pre class="example-preformatted">enum Expr {
    Lambda { params: Vec&lt;String&gt;, body: Vec&lt;Expr&gt; },
    // ...
}
</pre></div>

</li><li>Conditionals begin with <code class="code">if</code> and have a predicate, a consequent, and an
alternative:

<div class="example">
<pre class="example-preformatted">enum Expr {
    If {
        predicate: Box&lt;Expr&gt;,
        consequent: Box&lt;Expr&gt;,
        alternative: Box&lt;Expr&gt;,
    },
    // ...
}
</pre></div>

</li><li><code class="code">Begin</code> packages a sequence of expressions into a single expression:

<div class="example">
<pre class="example-preformatted">enum Expr {
    Begin(Vec&lt;Expr&gt;),
    // ...
}
</pre></div>

</li><li>A procedure application consists of an operator and operands:

<div class="example">
<pre class="example-preformatted">enum Expr {
    Application {
        operator: Box&lt;Expr&gt;,
        operands: Vec&lt;Expr&gt;,
    },
}
</pre></div>

</li></ul>

<h4 class="subsubheading" id="Derived-expressions"><span>Derived expressions<a class="copiable-link" href="#Derived-expressions"> &para;</a></span></h4>

<p>Some special forms in our language can be defined in terms of expressions
involving other special forms, rather than being implemented directly.  One
example is <code class="code">cond</code>, which can be implemented as a nest of <code class="code">if</code>
expressions.  In Rust, we represent this with a <code class="code">Cond</code> variant that
contains a list of clauses:
</p>
<div class="example">
<pre class="example-preformatted">enum Expr {
    Cond(Vec&lt;CondClause&gt;),
    // ...
}

struct CondClause {
    predicate: Expr,
    actions: Vec&lt;Expr&gt;,
}
</pre></div>

<p>The procedure <code class="code">cond_to_if</code> transforms these clauses into a chain of
<code class="code">if</code> expressions:
</p>
<div class="example">
<pre class="example-preformatted">fn cond_to_if(clauses: &amp;[CondClause]) -&gt; Result&lt;Expr, EvalError&gt; {
    if clauses.is_empty() {
        return Ok(Expr::Bool(false));
    }
    let first = &amp;clauses[0];
    let rest = &amp;clauses[1..];
    if let Expr::Symbol(s) = &amp;first.predicate &amp;&amp; s == &quot;else&quot; {
        return Ok(make_sequence(&amp;first.actions));
    }
    Ok(Expr::If {
        predicate: Box::new(first.predicate.clone()),
        consequent: Box::new(make_sequence(&amp;first.actions)),
        alternative: Box::new(cond_to_if(rest)?),
    })
}
</pre></div>
<p>Implementing the evaluation of <code class="code">cond</code> in this way simplifies the evaluator
because it reduces the number of special forms for which the evaluation process
must be explicitly specified.
</p>
<p>We include syntax procedures that extract the parts of a <code class="code">cond</code>
expression, and a procedure <code class="code">cond_to_if</code> that transforms <code class="code">cond</code>
expressions into <code class="code">if</code> expressions.  A case analysis begins with
<code class="code">cond</code> and has a list of predicate-action clauses.  A clause is an
<code class="code">else</code> clause if its predicate is the symbol <code class="code">else</code>.<a class="footnote" id="DOCF202" href="#FOOT202"><sup>202</sup></a>
</p>
<div class="example">
<pre class="example-preformatted">// In Rust, cond is typically replaced by match expressions.
// If we need to desugar cond to if in an interpreter:
fn cond_to_if(clauses: &amp;[(Expr, Vec&lt;Expr&gt;)]) -&gt; Expr {
    clauses.iter().rev().fold(
        Expr::Bool(false),  // No else clause returns false
        |acc, (pred, actions)| {
            if matches!(pred, Expr::Symbol(s) if s == &quot;else&quot;) {
                sequence_to_exp(actions.clone())
            } else {
                make_if(pred.clone(), sequence_to_exp(actions.clone()), acc)
            }
        }
    )
}
</pre></div>

<p>Expressions (such as <code class="code">cond</code>) that we choose to implement as syntactic
transformations are called <a class="index-entry-id" id="index-derived-expressions"></a>
<em class="dfn">derived expressions</em>.  <code class="code">Let</code>
expressions are also derived expressions (see 
<a class="ref" href="#Exercise-4_002e6">Exercise 4.6</a>).<a class="footnote" id="DOCF203" href="#FOOT203"><sup>203</sup></a>
</p>
<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-4_002e2"></a>Exercise 4.2:</strong> Louis Reasoner plans to reorder the
<code class="code">cond</code> clauses in <code class="code">eval</code> so that the clause for procedure
applications appears before the clause for assignments.  He argues that this
will make the interpreter more efficient: Since programs usually contain more
applications than assignments, definitions, and so on, his modified <code class="code">eval</code>
will usually check fewer clauses than the original <code class="code">eval</code> before
identifying the type of an expression.
</p>
<ol class="enumerate" type="a" start="1">
<li> What is wrong with Louis&rsquo;s plan?  (Hint: What will Louis&rsquo;s evaluator do with
the expression <code class="code">let x = 3;</code>?)

</li><li> Louis is upset that his plan didn&rsquo;t work.  He is willing to go to any lengths
to make his evaluator recognize procedure applications before it checks for
most other kinds of expressions.  Help him by changing the syntax of the
evaluated language so that procedure applications start with <code class="code">call</code>.  For
example, instead of <code class="code">(factorial 3)</code> we will now have to write <code class="code">(call
factorial 3)</code> and instead of <code class="code">(+ 1 2)</code> we will have to write <code class="code">(call +
1 2)</code>.

</li></ol>
</blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-4_002e3"></a>Exercise 4.3:</strong> Rewrite <code class="code">eval</code> so that the
dispatch is done in data-directed style.  Compare this with the data-directed
differentiation procedure of <a class="ref" href="2_002e4.xhtml#Exercise-2_002e73">Exercise 2.73</a>.  (You may use the <code class="code">car</code>
of a compound expression as the type of the expression, as is appropriate for
the syntax implemented in this section.)
</p></blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-4_002e4"></a>Exercise 4.4:</strong> Recall the definitions of the
special forms <code class="code">and</code> and <code class="code">or</code> from <a class="ref" href="Chapter-1.xhtml">Building Abstractions with Procedures</a>:
</p>
<ul class="itemize mark-bullet">
<li><code class="code">and</code>: The expressions are evaluated from left to right.  If any
expression evaluates to false, false is returned; any remaining expressions are
not evaluated.  If all the expressions evaluate to true values, the value of
the last expression is returned.  If there are no expressions then true is
returned.

</li><li><code class="code">or</code>: The expressions are evaluated from left to right.  If any expression
evaluates to a true value, that value is returned; any remaining expressions
are not evaluated.  If all expressions evaluate to false, or if there are no
expressions, then false is returned.

</li></ul>

<p>Install <code class="code">and</code> and <code class="code">or</code> as new special forms for the evaluator by
defining appropriate syntax procedures and evaluation procedures
<code class="code">eval-and</code> and <code class="code">eval-or</code>.  Alternatively, show how to implement
<code class="code">and</code> and <code class="code">or</code> as derived expressions.
</p></blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-4_002e5"></a>Exercise 4.5:</strong> Scheme allows an additional syntax
for <code class="code">cond</code> clauses, <code class="code">(⟨<var class="var">test</var>⟩ =&gt; ⟨<var class="var">recipient</var>⟩)</code>.  If
<code class="code">⟨</code><var class="var">test</var><code class="code">⟩</code> evaluates to a true value, then <code class="code">⟨</code><var class="var">recipient</var><code class="code">⟩</code> is evaluated.
Its value must be a procedure of one argument; this procedure is then invoked
on the value of the <code class="code">⟨</code><var class="var">test</var><code class="code">⟩</code>, and the result is returned as the value of
the <code class="code">cond</code> expression.  For example
</p>
<div class="example">
<pre class="example-preformatted">match assoc(&quot;b&quot;, list(list(&quot;a&quot;, 1), list(&quot;b&quot;, 2))) {
    Some(val) =&gt; cadr(val),
    None =&gt; false,
}
</pre></div>

<p>returns 2.  Modify the handling of <code class="code">cond</code> so that it supports this
extended syntax.
</p></blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-4_002e6"></a>Exercise 4.6:</strong> <code class="code">Let</code> expressions are derived
expressions, because
</p>
<div class="example">
<pre class="example-preformatted">{
    let <var class="var">var1</var> = <var class="var">exp1</var>;
    // ...
    let <var class="var">varn</var> = <var class="var">expn</var>;
    <var class="var">body</var>
}
</pre></div>

<p>is equivalent to
</p>
<div class="example">
<pre class="example-preformatted">// Immediately-invoked closure:
(|<var class="var">var1</var>, ..., <var class="var">varn</var>| {
    <var class="var">body</var>
})(<var class="var">exp1</var>, ..., <var class="var">expn</var>)
</pre></div>

<p>Implement a syntactic transformation <code class="code">let_to_combination</code> that reduces
evaluating <code class="code">let</code> expressions to evaluating combinations of the type shown
above, and add the appropriate clause to <code class="code">eval</code> to handle <code class="code">let</code>
expressions.
</p></blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-4_002e7"></a>Exercise 4.7:</strong> <code class="code">Let*</code> is similar to
<code class="code">let</code>, except that the bindings of the <code class="code">let*</code> variables are performed
sequentially from left to right, and each binding is made in an environment in
which all of the preceding bindings are visible.  For example
</p>
<div class="example">
<pre class="example-preformatted">// let* is just sequential let bindings in Rust:
{
    let x = 3;
    let y = x + 2;      // Can use x
    let z = x + y + 5;  // Can use x and y
    x * z               // =&gt; 39
}
</pre></div>

<p>returns 39.  Explain how a <code class="code">let*</code> expression can be rewritten as a set of
nested <code class="code">let</code> expressions, and write a procedure <code class="code">let*-&gt;nested-lets</code>
that performs this transformation.  If we have already implemented <code class="code">let</code>
(<a class="ref" href="#Exercise-4_002e6">Exercise 4.6</a>) and we want to extend the evaluator to handle <code class="code">let*</code>,
is it sufficient to add a clause to <code class="code">eval</code> whose action is
</p>
<div class="example">
<pre class="example-preformatted">eval(&amp;let_star_to_nested_lets(exp), env)
</pre></div>

<p>or must we explicitly expand <code class="code">let*</code> in terms of non-derived expressions?
</p></blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-4_002e8"></a>Exercise 4.8:</strong> &ldquo;Named <code class="code">let</code>&rdquo; is a variant
of <code class="code">let</code> that has the form 
</p>
<div class="example">
<pre class="example-preformatted">// Named let in Rust is a loop with initial values:
loop {
    // bindings become mutable loop variables
    // body can recursively call with new values via continue
}
</pre></div>

<p>The <code class="code">⟨</code><var class="var">bindings</var><code class="code">⟩</code> and <code class="code">⟨</code><var class="var">body</var><code class="code">⟩</code> are just as in ordinary <code class="code">let</code>,
except that <code class="code">⟨</code><var class="var">var</var><code class="code">⟩</code> is bound within <code class="code">⟨</code><var class="var">body</var><code class="code">⟩</code> to a procedure whose body
is <code class="code">⟨</code><var class="var">body</var><code class="code">⟩</code> and whose parameters are the variables in the <code class="code">⟨</code><var class="var">bindings</var><code class="code">⟩</code>.
Thus, one can repeatedly execute the <code class="code">⟨</code><var class="var">body</var><code class="code">⟩</code> by invoking the procedure
named <code class="code">⟨</code><var class="var">var</var><code class="code">⟩</code>.  For example, the iterative Fibonacci procedure 
(<a class="ref" href="1_002e2.xhtml#g_t1_002e2_002e2">Tree Recursion</a>) can be rewritten using named <code class="code">let</code> as follows:
</p>
<div class="example">
<pre class="example-preformatted">fn fib(n: u64) -&gt; u64 {
    let (mut a, mut b, mut count) = (1, 0, n);
    loop {
        if count == 0 {
            return b;
        }
        (a, b, count) = (a + b, a, count - 1);
    }
}
</pre></div>

<p>Modify <code class="code">let-&gt;combination</code> of <a class="ref" href="#Exercise-4_002e6">Exercise 4.6</a> to also support named
<code class="code">let</code>.
</p></blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-4_002e9"></a>Exercise 4.9:</strong> Many languages support a variety of
iteration constructs, such as <code class="code">do</code>, <code class="code">for</code>, <code class="code">while</code>, and
<code class="code">until</code>.  In Scheme, iterative processes can be expressed in terms of
ordinary procedure calls, so special iteration constructs provide no essential
gain in computational power.  On the other hand, such constructs are often
convenient.  Design some iteration constructs, give examples of their use, and
show how to implement them as derived expressions.
</p></blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-4_002e10"></a>Exercise 4.10:</strong> By using data abstraction, we
were able to write an <code class="code">eval</code> procedure that is independent of the
particular syntax of the language to be evaluated.  To illustrate this, design
and implement a new syntax for Scheme by modifying the procedures in this
section, without changing <code class="code">eval</code> or <code class="code">apply</code>.
</p></blockquote>

<hr>
</div>
<div class="subsection-level-extent" id="g_t4_002e1_002e3">
<h4 class="subsection" id="Evaluator-Data-Structures"><span>4.1.3 Evaluator Data Structures<a class="copiable-link" href="#Evaluator-Data-Structures"> &para;</a></span></h4>

<p>In addition to defining the external syntax of the language, the evaluator
implementation must also define the data structures that the evaluator
manipulates internally, such as the representation of procedures and
environments, as well as the representation of true and false.
</p>
<h4 class="subsubheading" id="Testing-of-predicates"><span>Testing of predicates<a class="copiable-link" href="#Testing-of-predicates"> &para;</a></span></h4>

<p>For conditionals, we accept any value to be true except the boolean constant
<code class="code">false</code>.
</p>
<div class="example">
<pre class="example-preformatted">fn is_true(value: &amp;Value) -&gt; bool {
    !matches!(value, Value::Bool(false))
}
</pre></div>

<h4 class="subsubheading" id="Representing-procedures"><span>Representing procedures<a class="copiable-link" href="#Representing-procedures"> &para;</a></span></h4>

<p>To handle primitives, we assume that we have available the following
procedures:
</p>
<ul class="itemize mark-bullet">
<li><code class="code">apply_primitive_procedure(⟨<var class="var">proc</var>⟩, ⟨<var class="var">args</var>⟩)</code>

<p>applies the given primitive procedure to the argument values in the list
<code class="code">⟨</code><var class="var">args</var><code class="code">⟩</code> and returns the result of the application.
</p>
</li><li><code class="code">is_primitive_procedure(⟨<var class="var">proc</var>⟩)</code>

<p>tests whether <code class="code">⟨</code><var class="var">proc</var><code class="code">⟩</code> is a primitive procedure.
</p>
</li></ul>

<p>These mechanisms for handling primitives are further described in 
<a class="ref" href="#g_t4_002e1_002e4">Running the Evaluator as a Program</a>.
</p>
<p>Compound procedures are constructed from parameters, procedure bodies, and
environments. In Rust, we represent these as variants of a <code class="code">Value</code> enum:
</p>
<div class="example">
<pre class="example-preformatted">#[derive(Clone)]
pub enum Value {
    Number(i64),
    Bool(bool),
    String(String),
    Symbol(String),
    Closure {
        params: Vec&lt;String&gt;,
        body: Vec&lt;Expr&gt;,
        env: Environment&lt;Value&gt;,
        self_name: Option&lt;String&gt;,
    },
    Primitive(String, fn(&amp;[Value]) -&gt; Result&lt;Value, EvalError&gt;),
    Pair(Box&lt;Value&gt;, Box&lt;Value&gt;),
    Nil,
    Void,
}
</pre></div>

<h4 class="subsubheading" id="Operations-on-Environments"><span>Operations on Environments<a class="copiable-link" href="#Operations-on-Environments"> &para;</a></span></h4>

<p>The evaluator needs operations for manipulating environments.  As explained in
<a class="ref" href="3_002e2.xhtml#g_t3_002e2">The Environment Model of Evaluation</a>, an environment is a sequence of frames, where each frame is
a table of bindings that associate variables with their corresponding values.
We use a persistent <code class="code">Environment</code> struct that uses structural sharing
for efficiency:
</p>
<div class="example">
<pre class="example-preformatted">use im::HashMap as ImHashMap;

#[derive(Clone)]
pub struct Environment&lt;V&gt; {
    bindings: ImHashMap&lt;String, V&gt;,
    parent: Option&lt;Box&lt;Environment&lt;V&gt;&gt;&gt;,
}

impl&lt;V: Clone&gt; Environment&lt;V&gt; {
    pub fn new() -&gt; Self {
        Self { bindings: ImHashMap::new(), parent: None }
    }

    pub fn lookup(&amp;self, name: &amp;str) -&gt; Option&lt;&amp;V&gt; {
        self.bindings.get(name)
            .or_else(|| self.parent.as_ref().and_then(|p| p.lookup(name)))
    }

    pub fn define(&amp;self, name: String, value: V) -&gt; Self {
        Self {
            bindings: self.bindings.update(name, value),
            parent: self.parent.clone(),
        }
    }

    pub fn extend(&amp;self, bindings: impl IntoIterator&lt;Item = (String, V)&gt;) -&gt; Self {
        Self {
            bindings: bindings.into_iter().collect(),
            parent: Some(Box::new(self.clone())),
        }
    }
}
</pre></div>

<p>The method described here uses <code class="code">im::HashMap</code> to provide <em class="math">O(\log n)</em>
operations with structural sharing.  This replaces the traditional Lisp
representation of environments as lists of frames, which would require
linear-time lookups. In Rust, this functional approach allows closures to own
a snapshot of their environment without the need for reference counting or
interior mutability.
</p>
<p>The use of <code class="code">im::HashMap</code> ensures that when we &ldquo;define&rdquo; or &ldquo;extend&rdquo; an
environment, we are not mutating existing data but creating a new version that
shares most of its structure with the previous one. This is crucial for
implementing the environment model correctly in a language with strict
ownership rules like Rust.
</p>
<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-4_002e11"></a>Exercise 4.11:</strong> Our <code class="code">Environment</code> struct uses
a <code class="code">HashMap</code> for each frame.  Compare this to the original Lisp
representation of a frame as a pair of lists.  What are the advantages and
disadvantages of using a hash map in terms of performance and memory usage,
especially when creating many small environments (as in procedure calls)?
</p></blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-4_002e12"></a>Exercise 4.12:</strong> The procedures <code class="code">define</code> and
<code class="code">lookup</code> can be expressed in terms of more abstract procedures for
traversing the environment structure.  In our Rust implementation, we rely on
the <code class="code">parent</code> link and <code class="code">HashMap</code> methods. Redefine <code class="code">lookup</code> to
use a functional fold or a recursive helper that makes the traversal explicit.
</p></blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-4_002e13"></a>Exercise 4.13:</strong> Scheme allows us to create new
bindings for variables by means of definition, but provides no way to get
rid of bindings.  Implement for the evaluator a special form
<code class="code">make_unbound</code> that returns a new environment with the binding of a given
symbol removed from the current frame.  (Hint: Use <code class="code">HashMap::without</code>).
</p></blockquote>

<hr>
</div>
<div class="subsection-level-extent" id="g_t4_002e1_002e4">

<h4 class="subsection" id="Running-the-Evaluator-as-a-Program"><span>4.1.4 Running the Evaluator as a Program<a class="copiable-link" href="#Running-the-Evaluator-as-a-Program"> &para;</a></span></h4>



<p>Given the evaluator, we have in our hands a description (expressed in Rust) of
</p>
<p>the process by which expressions are evaluated.  One advantage of
</p>
<p>expressing the evaluator as a program is that we can run the program.  This
</p>
<p>gives us, running within Rust, a working model of how the language itself
</p>
<p>evaluates expressions.  This can serve as a framework for experimenting with
</p>
<p>evaluation rules, as we shall do later in this chapter.
</p>


<p>Our evaluator program reduces expressions ultimately to the application of
</p>
<p>primitive procedures.  Therefore, all that we need to run the evaluator is to
</p>
<p>create a mechanism that calls on the underlying Rust system to model the
</p>
<p>application of primitive procedures.
</p>


<p>There must be a binding for each primitive procedure name, so that when
</p>
<p><code class="code">eval</code> evaluates the operator of an application of a primitive, it will
</p>
<p>find an object to pass to <code class="code">apply</code>.  We thus set up a global environment
</p>
<p>that associates unique objects with the names of the primitive procedures that
</p>
<p>can appear in the expressions we will be evaluating.  The global environment
</p>
<p>also includes bindings for the symbols <code class="code">true</code> and <code class="code">false</code>.
</p>


<div class="example">
<pre class="example-preformatted">

pub fn setup_environment() -&gt; Environment&lt;Value&gt; {

    let env = Environment::new();



    // Arithmetic primitives

    let env = env.define(&quot;+&quot;.to_string(), 

                         Value::Primitive(&quot;+&quot;.into(), prim_add));

    let env = env.define(&quot;-&quot;.to_string(), 

                         Value::Primitive(&quot;-&quot;.into(), prim_sub));

    let env = env.define(&quot;*&quot;.to_string(), 

                         Value::Primitive(&quot;*&quot;.into(), prim_mul));

    let env = env.define(&quot;/&quot;.to_string(), 

                         Value::Primitive(&quot;/&quot;.into(), prim_div));



    // Boolean constants

    let env = env.define(&quot;true&quot;.to_string(), Value::Bool(true));

    let env = env.define(&quot;false&quot;.to_string(), Value::Bool(false));



    env

}

</pre></div>




<p>It does not matter how we represent the primitive procedure objects, so long as
</p>
<p><code class="code">apply</code> can identify and apply them. In our <code class="code">Value</code> enum, we represent
</p>
<p>a primitive procedure as a function pointer along with its name:
</p>


<div class="example">
<pre class="example-preformatted">

// Value::Primitive(String, fn(&amp;[Value]) -&gt; Result&lt;Value, EvalError&gt;)

</pre></div>

<p>For convenience in running the metacircular evaluator, we provide a
<a class="index-entry-id" id="index-driver-loop"></a>
<em class="dfn">driver loop</em> that models the read-eval-print loop. It prints a
<a class="index-entry-id" id="index-prompt"></a>
<em class="dfn">prompt</em>, reads an input expression, evaluates it in the global
environment, and prints the result. Notice that the <code class="code">driver_loop</code>
threads the environment through each iteration to allow for definitions:
</p>
<div class="example">
<pre class="example-preformatted">const INPUT_PROMPT: &amp;str = &quot;;;; Eval input:&quot;;
const OUTPUT_PROMPT: &amp;str = &quot;;;; Eval value:&quot;;

fn driver_loop(mut env: Environment&lt;Value&gt;) {
    loop {
        println!(&quot;\n{}&quot;, INPUT_PROMPT);
        let input = read_and_parse(); // Hypothetical parser
        match eval(&amp;input, env) {
            Ok((output, new_env)) =&gt; {
                env = new_env;
                println!(&quot;{}&quot;, OUTPUT_PROMPT);
                user_print(&amp;output);
            }
            Err(e) =&gt; eprintln!(&quot;Error: {:?}&quot;, e),
        }
    }
}
</pre></div>

<p>We use a special printing procedure, <code class="code">user_print</code>, to avoid printing the
entire environment part of a compound procedure:
</p>
<div class="example">
<pre class="example-preformatted">fn user_print(object: &amp;Value) {
    match object {
        Value::Closure { params, .. } =&gt; {
            println!(&quot;#&lt;procedure ({})&gt;&quot;, params.join(&quot; &quot;));
        }
        other =&gt; println!(&quot;{}&quot;, other),
    }
}
</pre></div>

<p>Now all we need to do to run the evaluator is to initialize the global
environment and start the driver loop.  Here is a sample interaction:
</p>
<div class="example">
<pre class="example-preformatted">fn main() {
    let env = setup_environment();
    driver_loop(env);
}

// ;;; Eval input:
// fn append(x, y) { if x.is_null() { y } else { cons(x.car(), append(x.cdr(), y)) } }
// ;;; Eval value:
// #&lt;procedure (x y)&gt;

// ;;; Eval input:
// append(list(1, 2, 3), list(4, 5, 6))
// ;;; Eval value:
// (1 2 3 4 5 6)
</pre></div>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-4_002e14"></a>Exercise 4.14:</strong> Eva Lu Ator and Louis Reasoner
are each experimenting with the metacircular evaluator.  Eva types in the
definition of <code class="code">map</code>, and runs some test programs that use it.  They work
fine.  Louis, in contrast, has installed the system version of <code class="code">map</code> as a
primitive for the metacircular evaluator.  When he tries it, things go terribly
wrong.  Explain why Louis&rsquo;s <code class="code">map</code> fails even though Eva&rsquo;s works.
</p></blockquote>

<hr>
</div>
<div class="subsection-level-extent" id="g_t4_002e1_002e5">
<h4 class="subsection" id="Data-as-Programs"><span>4.1.5 Data as Programs<a class="copiable-link" href="#Data-as-Programs"> &para;</a></span></h4>

<p>In thinking about a Lisp program that evaluates Lisp expressions, an analogy
might be helpful.  One operational view of the meaning of a program is that a
program is a description of an abstract (perhaps infinitely large) machine.
For example, consider the familiar program to compute factorials:
</p>
<div class="example">
<pre class="example-preformatted">fn factorial(n: i64) -&gt; i64 {
    if n == 1 {
        1
    } else {
        factorial(n - 1) * n
    }
}
</pre></div>

<p>We may regard this program as the description of a machine containing parts
that decrement, multiply, and test for equality, together with a two-position
switch and another factorial machine. (The factorial machine is infinite
because it contains another factorial machine within it.)  <a class="ref" href="#Figure-4_002e2">Figure 4.2</a> is
a flow diagram for the factorial machine, showing how the parts are wired
together.
</p>
<div class="float">
<a class="anchor" id="Figure-4_002e2"></a><img class="image" src="fig/chap4/Fig4.2a.std.svg" alt="fig/chap4/Fig4.2a">
<div class="caption"><p><strong class="strong">Figure 4.2:</strong> The factorial program, viewed as an abstract machine.</p></div></div>
<p>In a similar way, we can regard the evaluator as a very special machine that
takes as input a description of a machine.  Given this input, the evaluator
configures itself to emulate the machine described.  For example, if we feed
our evaluator the definition of <code class="code">factorial</code>, as shown in <a class="ref" href="#Figure-4_002e3">Figure 4.3</a>,
the evaluator will be able to compute factorials.
</p>
<div class="float">
<a class="anchor" id="Figure-4_002e3"></a><img class="image" src="fig/chap4/Fig4.3.std.svg" alt="fig/chap4/Fig4.3">
<div class="caption"><p><strong class="strong">Figure 4.3:</strong> The evaluator emulating a factorial machine.</p></div></div>
<p>From this perspective, our evaluator is seen to be a <a class="index-entry-id" id="index-universal-machine"></a>
<em class="dfn">universal machine</em>.  
It mimics other machines when these are described as Rust
programs.<a class="footnote" id="DOCF204" href="#FOOT204"><sup>204</sup></a> This is striking. Try to imagine an analogous evaluator
for electrical circuits.  This would be a circuit that takes as input a signal
encoding the plans for some other circuit, such as a filter.  Given this input,
the circuit evaluator would then behave like a filter with the same
description.  Such a universal electrical circuit is almost unimaginably
complex.  It is remarkable that the program evaluator is a rather simple
program.<a class="footnote" id="DOCF205" href="#FOOT205"><sup>205</sup></a>
</p>
<p>Another striking aspect of the evaluator is that it acts as a bridge between
the data objects that are manipulated by our programming language and the
programming language itself.  Imagine that the evaluator program (implemented
in Rust) is running, and that a user is typing expressions to the evaluator and
observing the results.  From the perspective of the user, an input expression
such as <code class="code">x * x</code> is an expression in the programming language, which the
evaluator should execute.  From the perspective of the evaluator, however, the
expression is simply a data structure (in our case, an <code class="code">Application</code>
variant of the <code class="code">Expr</code> enum) that is to be manipulated according to a
well-defined set of rules.
</p>
<p>That the user&rsquo;s programs are the evaluator&rsquo;s data need not be a source of
confusion.  In fact, it is sometimes convenient to ignore this distinction, and
to give the user the ability to explicitly evaluate a data object as an
expression, by making <code class="code">eval</code> available for use in programs.  Many
languages provide a primitive <code class="code">eval</code> procedure that takes as arguments an
expression and an environment and evaluates the expression relative to the
environment.<a class="footnote" id="DOCF206" href="#FOOT206"><sup>206</sup></a> Thus,
</p>
<div class="example">
<pre class="example-preformatted">// In Rust, eval takes an expression and environment reference
let expr = Expr::Application {
    operator: Box::new(Expr::Symbol(&quot;*&quot;.into())),
    operands: vec![Expr::Number(5), Expr::Number(5)],
};
let result = eval(&amp;expr, &amp;global_env)?;
// =&gt; Value::Number(25)
</pre></div>

<p>and
</p>
<div class="example">
<pre class="example-preformatted">// Building the expression programmatically
let op = Expr::Symbol(&quot;*&quot;.into());
let args = vec![Expr::Number(5), Expr::Number(5)];
let expr = Expr::Application {
    operator: Box::new(op),
    operands: args,
};
eval(&amp;expr, &amp;global_env)?
// =&gt; Value::Number(25)
</pre></div>

<p>will both return 25.<a class="footnote" id="DOCF207" href="#FOOT207"><sup>207</sup></a>
</p>
<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-4_002e15"></a>Exercise 4.15:</strong> Given a one-argument procedure
<code class="code">p</code> and an object <code class="code">a</code>, <code class="code">p</code> is said to &ldquo;halt&rdquo; on <code class="code">a</code> if
evaluating the expression <code class="code">(p a)</code> returns a value (as opposed to
terminating with an error message or running forever).  Show that it is
impossible to write a procedure <code class="code">halts?</code> that correctly determines whether
<code class="code">p</code> halts on <code class="code">a</code> for any procedure <code class="code">p</code> and object <code class="code">a</code>.  Use
the following reasoning: If you had such a procedure <code class="code">halts?</code>, you could
implement the following program:
</p>
<div class="example">
<pre class="example-preformatted">fn run_forever() -&gt; ! {
    loop {}  // Infinite loop, never returns
}

fn try_halting&lt;F&gt;(p: F) -&gt; &amp;'static str
where
    F: Fn(&amp;F) -&gt; bool,
{
    if halts(&amp;p, &amp;p) {
        run_forever()  // If p halts on p, loop forever
    } else {
        &quot;halted&quot;       // If p doesn't halt, return
    }
}
</pre></div>

<p>Now consider evaluating the expression <code class="code">(try try)</code> and show that any
possible outcome (either halting or running forever) violates the intended
behavior of <code class="code">halts?</code>.<a class="footnote" id="DOCF208" href="#FOOT208"><sup>208</sup></a>
</p></blockquote>

<hr>
</div>
<div class="subsection-level-extent" id="g_t4_002e1_002e6">
<h4 class="subsection" id="Internal-Definitions-1"><span>4.1.6 Internal Definitions<a class="copiable-link" href="#Internal-Definitions-1"> &para;</a></span></h4>

<p>Our environment model of evaluation and our metacircular evaluator execute
definitions in sequence, extending the environment frame one definition at a
time.  This is particularly convenient for interactive program development, in
which the programmer needs to freely mix the application of procedures with the
definition of new procedures.  However, if we think carefully about the
internal definitions used to implement block structure (introduced in 
<a class="ref" href="1_002e1.xhtml#g_t1_002e1_002e8">Procedures as Black-Box Abstractions</a>), we will find that name-by-name extension of the environment may
not be the best way to define local variables.
</p>
<p>Consider a procedure with internal definitions, such as
</p>
<div class="example">
<pre class="example-preformatted">fn f(x: i64) -&gt; /* result */ {
    // Rust allows mutually recursive inner functions
    fn is_even(n: i64) -&gt; bool {
        if n == 0 {
            true
        } else {
            is_odd(n - 1)
        }
    }
    fn is_odd(n: i64) -&gt; bool {
        if n == 0 {
            false
        } else {
            is_even(n - 1)
        }
    }
    // <span class="r">rest of body of <code class="code">f</code></span>
}
</pre></div>

<p>Our intention here is that the name <code class="code">is_odd</code> in the body of the procedure
<code class="code">is_even</code> should refer to the procedure <code class="code">is_odd</code> that is defined after
<code class="code">is_even</code>.  The scope of the name <code class="code">is_odd</code> is the entire body of
<code class="code">f</code>, not just the portion of the body of <code class="code">f</code> starting at the point
where the definition for <code class="code">is_odd</code> occurs.  Indeed, when we consider that
<code class="code">is_odd</code> is itself defined in terms of <code class="code">is_even</code>&mdash;so that <code class="code">is_even</code>
and <code class="code">is_odd</code> are mutually recursive procedures&mdash;we see that the only
satisfactory interpretation of the two definitions is to regard them as if
the names <code class="code">is_even</code> and <code class="code">is_odd</code> were being added to the environment
simultaneously.  More generally, in block structure, the scope of a local name
is the entire procedure body in which the definition is evaluated.
</p>
<p>As it happens, our interpreter will evaluate calls to <code class="code">f</code> correctly, but
for an &ldquo;accidental&rdquo; reason: Since the definitions of the internal procedures
come first, no calls to these procedures will be evaluated until all of them
have been defined.  Hence, <code class="code">is_odd</code>  will have been defined by the time
<code class="code">is_even</code> is executed.  In fact, our sequential evaluation mechanism will
give the same result as a mechanism that directly implements simultaneous
definition for any procedure in which the internal definitions come first in a
body and evaluation of the value expressions for the defined variables doesn&rsquo;t
actually use any of the defined variables.  (For an example of a procedure that
doesn&rsquo;t obey these restrictions, so that sequential definition isn&rsquo;t equivalent
to simultaneous definition, see <a class="ref" href="#Exercise-4_002e19">Exercise 4.19</a>.)<a class="footnote" id="DOCF209" href="#FOOT209"><sup>209</sup></a>
</p>
<p>There is, however, a simple way to treat definitions so that internally defined
names have truly simultaneous scope&mdash;just create all local variables that will
be in the current environment before evaluating any of the value expressions.
One way to do this is by a syntax transformation on <code class="code">lambda</code> expressions.
Before evaluating the body of a <code class="code">lambda</code> expression, we &ldquo;scan out&rdquo; and
eliminate all the internal definitions in the body.  The internally defined
variables will be created with a <code class="code">let</code> and then set to their values by
assignment.  For example, the procedure
</p>
<div class="example">
<pre class="example-preformatted">|<var class="var">vars</var>| {
    let u = <var class="var">e1</var>;
    let v = <var class="var">e2</var>;
    <var class="var">e3</var>
}
</pre></div>

<p>would be transformed into
</p>
<div class="example">
<pre class="example-preformatted">|<var class="var">vars</var>| {
    // Conceptual transformation to support simultaneous scope:
    let u = &quot;*unassigned*&quot;;
    let v = &quot;*unassigned*&quot;;
    u = <var class="var">e1</var>;
    v = <var class="var">e2</var>;
    <var class="var">e3</var>
}
</pre></div>

<p>where <code class="code">&quot;*unassigned*&quot;</code> is a special value that causes looking up a variable
to signal an error if an attempt is made to use the value of the
not-yet-assigned variable. In our functional evaluator, this assignment
would be implemented by returning updated environments during the evaluation
of the body.
</p>
<p>An alternative strategy for scanning out internal definitions is shown in
<a class="ref" href="#Exercise-4_002e18">Exercise 4.18</a>.  Unlike the transformation shown above, this enforces the
restriction that the defined variables&rsquo; values can be evaluated without using
any of the variables&rsquo; values.<a class="footnote" id="DOCF210" href="#FOOT210"><sup>210</sup></a>
</p>
<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-4_002e16"></a>Exercise 4.16:</strong> In this exercise we implement the
method just described for interpreting internal definitions.  We assume that
the evaluator supports <code class="code">let</code> (see <a class="ref" href="#Exercise-4_002e6">Exercise 4.6</a>).
</p>
<ol class="enumerate" type="a" start="1">
<li> Change <code class="code">lookup_variable_value</code> (<a class="ref" href="#g_t4_002e1_002e3">Evaluator Data Structures</a>) to signal an error if
the value it finds is the symbol <code class="code">*unassigned*</code>.

</li><li> Write a procedure <code class="code">scan_out_defines</code> that takes a procedure body and
returns an equivalent one that has no internal definitions, by making the
transformation described above.

</li><li> Install <code class="code">scan_out_defines</code> in the interpreter, either in
<code class="code">make_procedure</code> or in <code class="code">procedure_body</code> (see <a class="ref" href="#g_t4_002e1_002e3">Evaluator Data Structures</a>).
Which place is better?  Why?

</li></ol>
</blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-4_002e17"></a>Exercise 4.17:</strong> Draw diagrams of the environment
in effect when evaluating the expression <code class="code">⟨</code><var class="var">e3</var><code class="code">⟩</code> in the procedure in the
text, comparing how this will be structured when definitions are interpreted
sequentially with how it will be structured if definitions are scanned out as
described.  Why is there an extra frame in the transformed program?  Explain
why this difference in environment structure can never make a difference in the
behavior of a correct program.  Design a way to make the interpreter implement
the &ldquo;simultaneous&rdquo; scope rule for internal definitions without constructing
the extra frame.
</p></blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-4_002e18"></a>Exercise 4.18:</strong> Consider an alternative strategy
for scanning out definitions that translates the example in the text to
</p>
<div class="example">
<pre class="example-preformatted">// Alternative transformation with temporary bindings:
|<var class="var">vars</var>| {
    let u;
    let v;
    {
        // Evaluate expressions before any assignment
        let a = <var class="var">e1</var>;  // Neither u nor v visible here
        let b = <var class="var">e2</var>;  // Neither u nor v visible here
        u = a;
        v = b;
    }
    <var class="var">e3</var>
}
</pre></div>

<p>Here <code class="code">a</code> and <code class="code">b</code> are meant to represent new variable names, created
by the interpreter, that do not appear in the user&rsquo;s program.  Consider the
<code class="code">solve</code> procedure from <a class="ref" href="3_002e5.xhtml#g_t3_002e5_002e4">Streams and Delayed Evaluation</a>:
</p>
<div class="example">
<pre class="example-preformatted">fn solve&lt;F&gt;(f: F, y0: f64, dt: f64) -&gt; impl Iterator&lt;Item = f64&gt;
where
    F: Fn(f64) -&gt; f64,
{
    // In Rust, we use std::iter::successors for self-referential iteration
    std::iter::successors(Some(y0), move |&amp;y| {
        Some(y + f(y) * dt)
    })
}
</pre></div>

<p>Will this procedure work if internal definitions are scanned out as shown in
this exercise?  What if they are scanned out as shown in the text?  Explain.
</p></blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-4_002e19"></a>Exercise 4.19:</strong> Ben Bitdiddle, Alyssa P. Hacker,
and Eva Lu Ator are arguing about the desired result of evaluating the
expression
</p>
<div class="example">
<pre class="example-preformatted">{
    let a = 1;
    fn f(x: i64) -&gt; i64 {
        // In Rust, inner 'a' shadows outer 'a'
        // Order of let bindings matters
        let b = a + x;  // Which 'a' does this refer to?
        let a = 5;      // This 'a' shadows outer 'a'
        a + b
    }
    f(10)
}
// Rust's shadowing rules: b uses outer a (1), result = 5 + 11 = 16
</pre></div>

<p>Ben asserts that the result should be obtained using the sequential rule for
definition: <code class="code">b</code> is defined to be 11, then <code class="code">a</code> is defined to be 5,
so the result is 16.  Alyssa objects that mutual recursion requires the
simultaneous scope rule for internal procedure definitions, and that it is
unreasonable to treat procedure names differently from other names.  Thus, she
argues for the mechanism implemented in <a class="ref" href="#Exercise-4_002e16">Exercise 4.16</a>.  This would lead
to <code class="code">a</code> being unassigned at the time that the value for <code class="code">b</code> is to be
computed.  Hence, in Alyssa&rsquo;s view the procedure should produce an error.  Eva
has a third opinion.  She says that if the definitions of <code class="code">a</code> and <code class="code">b</code>
are truly meant to be simultaneous, then the value 5 for <code class="code">a</code> should be
used in evaluating <code class="code">b</code>.  Hence, in Eva&rsquo;s view <code class="code">a</code> should be 5,
<code class="code">b</code> should be 15, and the result should be 20.  Which (if any) of these
viewpoints do you support?  Can you devise a way to implement internal
definitions so that they behave as Eva prefers?<a class="footnote" id="DOCF211" href="#FOOT211"><sup>211</sup></a>
</p></blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-4_002e20"></a>Exercise 4.20:</strong> Because internal definitions look
sequential but are actually simultaneous, some people prefer to avoid them
entirely, and use the special form <code class="code">letrec</code> instead.  <code class="code">Letrec</code> looks
like <code class="code">let</code>, so it is not surprising that the variables it binds are bound
simultaneously and have the same scope as each other.  The sample procedure
<code class="code">f</code> above can be written without internal definitions, but with exactly
the same meaning, as
</p>
<div class="example">
<pre class="example-preformatted">fn f(x: i64) -&gt; /* result */ {
    // Rust's inner functions are naturally mutually recursive
    fn is_even(n: i64) -&gt; bool {
        if n == 0 {
            true
        } else {
            is_odd(n - 1)
        }
    }
    fn is_odd(n: i64) -&gt; bool {
        if n == 0 {
            false
        } else {
            is_even(n - 1)
        }
    }
    // <span class="r">rest of body of <code class="code">f</code></span>
}
</pre></div>

<p><code class="code">Letrec</code> expressions, which have the form
</p>
<div class="example">
<pre class="example-preformatted">// Rust equivalent: inner functions with mutual recursion
fn <var class="var">var_1</var>(...) -&gt; T { <var class="var">exp_1</var> }
...
fn <var class="var">var_n</var>(...) -&gt; T { <var class="var">exp_n</var> }
<var class="var">body</var>
</pre></div>

<p>are a variation on <code class="code">let</code> in which the expressions
<em class="math">{⟨\kern0.1em exp_k⟩}</em> that provide the initial values for the
variables <em class="math">{⟨\kern0.06em var_k⟩}</em> are evaluated in an environment
that includes all the <code class="code">letrec</code> bindings.  This permits recursion in the
bindings, such as the mutual recursion of <code class="code">is_even</code> and <code class="code">is_odd</code> in the
example above, or the evaluation of 10 factorial with
</p>
<div class="example">
<pre class="example-preformatted">{
    // Recursive local function
    fn fact(n: i64) -&gt; i64 {
        if n == 1 {
            1
        } else {
            n * fact(n - 1)
        }
    }
    fact(10)
}
// =&gt; 3628800
</pre></div>

<ol class="enumerate" type="a" start="1">
<li> Implement <code class="code">letrec</code> as a derived expression, by transforming a
<code class="code">letrec</code> expression into a <code class="code">let</code> expression as shown in the text
above or in <a class="ref" href="#Exercise-4_002e18">Exercise 4.18</a>.  That is, the <code class="code">letrec</code> variables should
be created with a <code class="code">let</code> and then be assigned their values with
<code class="code">set!</code>.

</li><li> Louis Reasoner is confused by all this fuss about internal definitions.  The
way he sees it, if you don&rsquo;t like to use definition inside a procedure, you
can just use <code class="code">let</code>.  Illustrate what is loose about his reasoning by
drawing an environment diagram that shows the environment in which the
<code class="code">⟨</code><var class="var">rest of body of <code class="code">f</code></var><code class="code">⟩</code> is evaluated during evaluation of the
expression <code class="code">f(5)</code>, with <code class="code">f</code> defined as in this exercise.  Draw an
environment diagram for the same evaluation, but with <code class="code">let</code> in place of
<code class="code">letrec</code> in the definition of <code class="code">f</code>.

</li></ol>
</blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-4_002e21"></a>Exercise 4.21:</strong> Amazingly, Louis&rsquo;s intuition in
<a class="ref" href="#Exercise-4_002e20">Exercise 4.20</a> is correct.  It is indeed possible to specify recursive
procedures without using <code class="code">letrec</code> (or even definition), although the
method for accomplishing this is much more subtle than Louis imagined.  The
following expression computes 10 factorial by applying a recursive factorial
procedure:<a class="footnote" id="DOCF212" href="#FOOT212"><sup>212</sup></a>
</p>
<div class="example">
<pre class="example-preformatted">// Y combinator style: passing the function to itself
(|n: i64| {
    // fact takes itself as first argument
    let fact = |ft: &amp;dyn Fn(&amp;dyn Fn(&amp;dyn Fn(&amp;_, i64) -&gt; i64, i64) -&gt; i64, i64) -&gt; i64,
                k: i64| -&gt; i64 {
        if k == 1 {
            1
        } else {
            k * ft(ft, k - 1)
        }
    };
    // Simpler approach using a recursive closure via Cell
    fn factorial(n: i64) -&gt; i64 {
        if n == 1 { 1 } else { n * factorial(n - 1) }
    }
    factorial(n)
})(10)
// =&gt; 3628800
</pre></div>

<ol class="enumerate" type="a" start="1">
<li> Check (by evaluating the expression) that this really does compute factorials.
Devise an analogous expression for computing Fibonacci numbers.

</li><li> Consider the following procedure, which includes mutually recursive internal
definitions:

<div class="example">
<pre class="example-preformatted">fn f(x: i64) -&gt; bool {
    fn is_even(n: i64) -&gt; bool {
        if n == 0 {
            true
        } else {
            is_odd(n - 1)
        }
    }
    fn is_odd(n: i64) -&gt; bool {
        if n == 0 {
            false
        } else {
            is_even(n - 1)
        }
    }
    is_even(x)
}
</pre></div>

<p>Fill in the missing expressions to complete an alternative definition of
<code class="code">f</code>, which uses neither internal definitions nor <code class="code">letrec</code>:
</p>
<div class="example">
<pre class="example-preformatted">fn f(x: i64) -&gt; bool {
    // Pass functions to themselves for recursion
    type EvenOdd = fn(fn(i64) -&gt; bool, fn(i64) -&gt; bool, i64) -&gt; bool;

    let is_even: EvenOdd = |ev, od, n| {
        if n == 0 { true } else { od(ev, od, n - 1) }
    };
    let is_odd: EvenOdd = |ev, od, n| {
        if n == 0 { false } else { ev(ev, od, n - 1) }
    };

    is_even(is_even, is_odd, x)
}
</pre></div>
</li></ol>
</blockquote>

<hr>
</div>
<div class="subsection-level-extent" id="g_t4_002e1_002e7">
<h4 class="subsection" id="Separating-Syntactic-Analysis-from-Execution"><span>4.1.7 Separating Syntactic Analysis from Execution<a class="copiable-link" href="#Separating-Syntactic-Analysis-from-Execution"> &para;</a></span></h4>

<p>The evaluator implemented above is simple, but it is very inefficient, because
the syntactic analysis of expressions is interleaved with their execution.
Thus if a program is executed many times, its syntax is analyzed many times.
Consider, for example, evaluating <code class="code">(factorial 4)</code> using the following
definition of <code class="code">factorial</code>:
</p>
<div class="example">
<pre class="example-preformatted">fn factorial(n: i64) -&gt; i64 {
    if n == 1 {
        1
    } else {
        factorial(n - 1) * n
    }
}
</pre></div>

<p>Each time <code class="code">factorial</code> is called, the evaluator must determine that the
body is an <code class="code">if</code> expression and extract the predicate.  Only then can it
evaluate the predicate and dispatch on its value.  Each time it evaluates the
expression <code class="code">(* (factorial (- n 1)) n)</code>, or the subexpressions
<code class="code">(factorial (- n 1))</code> and <code class="code">(- n 1)</code>, the evaluator must perform the
case analysis in <code class="code">eval</code> to determine that the expression is an
application, and must extract its operator and operands.  This analysis is
expensive.  Performing it repeatedly is wasteful.
</p>
<p>We can transform the evaluator to be significantly more efficient by arranging
things so that syntactic analysis is performed only once.<a class="footnote" id="DOCF213" href="#FOOT213"><sup>213</sup></a> We split <code class="code">eval</code>, which takes an expression and an
environment, into two parts.  The procedure <code class="code">analyze</code> takes only the
expression.  It performs the syntactic analysis and returns a new procedure,
the <a class="index-entry-id" id="index-execution-procedure"></a>
<em class="dfn">execution procedure</em>, that encapsulates the work to be done in
executing the analyzed expression.  The execution procedure takes an
environment as its argument and completes the evaluation.  This saves work
because <code class="code">analyze</code> will be called only once on an expression, while the
execution procedure may be called many times.
</p>
<p>With the separation into analysis and execution, <code class="code">eval</code> now becomes
</p>
<div class="example">
<pre class="example-preformatted">// Analyze returns a closure that takes and returns an environment
fn eval(exp: &amp;Expr, env: Environment&lt;Value&gt;) 
    -&gt; Result&lt;(Value, Environment&lt;Value&gt;), EvalError&gt; 
{
    let executor = analyze(exp)?;
    executor(env)
}
</pre></div>

<p>The result of calling <code class="code">analyze</code> is the execution procedure to be applied
to the environment.  The <code class="code">analyze</code> procedure is the same case analysis as
performed by the original <code class="code">eval</code> of <a class="ref" href="#g_t4_002e1_002e1">The Core of the Evaluator</a>, except that the
procedures to which we dispatch perform only analysis, not full evaluation.
The <code class="code">Executor</code> type now threads the environment functionally:
</p>
<div class="example">
<pre class="example-preformatted">type Executor = Box&lt;dyn Fn(Environment&lt;Value&gt;) 
    -&gt; Result&lt;(Value, Environment&lt;Value&gt;), EvalError&gt;&gt;;

fn analyze(exp: &amp;Expr) -&gt; Result&lt;Executor, EvalError&gt; {
    match exp {
        Expr::Number(n) =&gt; analyze_self_evaluating(*n),
        Expr::String(s) =&gt; analyze_self_evaluating_string(s.clone()),
        Expr::Quote(quoted) =&gt; analyze_quoted(quoted),
        Expr::Symbol(var) =&gt; analyze_variable(var.clone()),
        Expr::Define { name, value } =&gt; 
            analyze_definition(name.clone(), value),
        Expr::If { predicate, consequent, alternative } =&gt;
            analyze_if(predicate, consequent, alternative),
        Expr::Lambda { params, body } =&gt;
            analyze_lambda(params.clone(), body),
        Expr::Begin(actions) =&gt; analyze_sequence(actions),
        Expr::Application { operator, operands } =&gt;
            analyze_application(operator, operands),
        _ =&gt; Err(EvalError::InvalidSyntax(format!(&quot;Unknown: {:?}&quot;, exp))),
    }
}
</pre></div>

<p>Here is the simplest syntactic analysis procedure, which handles
self-evaluating expressions.  It returns an execution procedure that 
passes the environment through unchanged:
</p>
<div class="example">
<pre class="example-preformatted">fn analyze_self_evaluating(n: i64) -&gt; Result&lt;Executor, EvalError&gt; {
    Ok(Box::new(move |env| Ok((Value::Number(n), env))))
}
</pre></div>

<p>For a quoted expression, we can gain a little efficiency by extracting the 
data once, in the analysis phase:
</p>
<div class="example">
<pre class="example-preformatted">fn analyze_quoted(quoted: &amp;Expr) -&gt; Result&lt;Executor, EvalError&gt; {
    let val = expr_to_value(quoted)?;
    Ok(Box::new(move |env| Ok((val.clone(), env))))
}
</pre></div>

<p>Looking up a variable value must still be done in the execution phase, since
this depends upon knowing the environment.<a class="footnote" id="DOCF214" href="#FOOT214"><sup>214</sup></a>
</p>
<div class="example">
<pre class="example-preformatted">use std::sync::Arc;

type Executor = Arc&lt;dyn Fn(Environment&lt;Value&gt;) 
    -&gt; Result&lt;(Value, Environment&lt;Value&gt;), EvalError&gt; + Send + Sync&gt;;

fn analyze_variable(name: String) -&gt; Result&lt;Executor, EvalError&gt; {
    Ok(Arc::new(move |env| {
        let val = env.lookup(&amp;name)
            .ok_or_else(|| EvalError::UnboundVariable(name.clone()))?
            .clone();
        Ok((val, env))
    }))
}

fn analyze_definition(name: String, value: &amp;Expr) -&gt; Result&lt;Executor, EvalError&gt; {
    let val_proc = analyze(value)?;
    Ok(Arc::new(move |env| {
        let (val, env) = val_proc(env)?;
        let new_env = env.define(name.clone(), val);
        Ok((Value::Void, new_env))
    }))
}

fn analyze_if(
    predicate: &amp;Expr,
    consequent: &amp;Expr,
    alternative: &amp;Expr,
) -&gt; Result&lt;Executor, EvalError&gt; {
    let pred_proc = analyze(predicate)?;
    let cons_proc = analyze(consequent)?;
    let alt_proc = analyze(alternative)?;
    Ok(Arc::new(move |env| {
        let (pred_val, env) = pred_proc(env)?;
        if is_true(&amp;pred_val) {
            cons_proc(env)
        } else {
            alt_proc(env)
        }
    }))
}

fn analyze_lambda(
    params: Vec&lt;String&gt;,
    body: &amp;[Expr],
) -&gt; Result&lt;Executor, EvalError&gt; {
    let body_proc = analyze_sequence(body)?;
    Ok(Arc::new(move |env| {
        let closure = Value::Closure {
            params: params.clone(),
            body: vec![], // In analyzed version, we might store body_proc
            env: env.clone(),
            self_name: None,
        };
        Ok((closure, env))
    }))
}
</pre></div>

<p>Analysis of a sequence of expressions (as in a <code class="code">begin</code> or the body of a
<code class="code">lambda</code> expression) is more involved.<a class="footnote" id="DOCF215" href="#FOOT215"><sup>215</sup></a> Each expression in the
sequence is analyzed, yielding an execution procedure.  These execution
procedures are combined to produce an execution procedure that takes an
environment as argument and sequentially calls each individual execution
procedure, threading the environment through:
</p>
<div class="example">
<pre class="example-preformatted">fn analyze_sequence(exps: &amp;[Expr]) -&gt; Result&lt;Executor, EvalError&gt; {
    if exps.is_empty() {
        return Err(EvalError::InvalidSyntax(&quot;Empty sequence&quot;.into()));
    }

    let procs: Vec&lt;Executor&gt; = exps
        .iter()
        .map(analyze)
        .collect::&lt;Result&lt;_, _&gt;&gt;()?;

    Ok(Arc::new(move |mut env| {
        let mut last_val = Value::Void;
        for proc in &amp;procs {
            let (val, next_env) = proc(env)?;
            last_val = val;
            env = next_env;
        }
        Ok((last_val, env))
    }))
}
</pre></div>

<p>To analyze an application, we analyze the operator and operands and construct
an execution procedure that calls the operator execution procedure (to obtain
the actual procedure to be applied) and the operand execution procedures (to
obtain the actual arguments).
</p>
<div class="example">
<pre class="example-preformatted">fn analyze_application(
    operator: &amp;Expr,
    operands: &amp;[Expr],
) -&gt; Result&lt;Executor, EvalError&gt; {
    let op_proc = analyze(operator)?;
    let arg_procs: Vec&lt;Executor&gt; = operands
        .iter()
        .map(analyze)
        .collect::&lt;Result&lt;_, _&gt;&gt;()?;

    Ok(Arc::new(move |env| {
        let (proc, env) = op_proc(env)?;
        let mut args = Vec::with_capacity(arg_procs.len());
        let mut current_env = env;
        for arg_proc in &amp;arg_procs {
            let (val, next_env) = arg_proc(current_env)?;
            args.push(val);
            current_env = next_env;
        }
        // In analyzed version, apply might need to be different
        let result = apply(proc, args)?;
        Ok((result, current_env))
    }))
}
</pre></div>

<p>Our new evaluator uses the same data structures, syntax procedures, and
run-time support procedures as in <a class="ref" href="#g_t4_002e1_002e2">Representing Expressions</a>, <a class="ref" href="#g_t4_002e1_002e3">Evaluator Data Structures</a>, and
<a class="ref" href="#g_t4_002e1_002e4">Running the Evaluator as a Program</a>.
</p>
<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-4_002e22"></a>Exercise 4.22:</strong> Extend the evaluator in this
section to support the special form <code class="code">let</code>.  (See <a class="ref" href="#Exercise-4_002e6">Exercise 4.6</a>.)
</p></blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-4_002e23"></a>Exercise 4.23:</strong> Alyssa P. Hacker doesn&rsquo;t
understand why <code class="code">analyze_sequence</code> needs to be so complicated.  All the
other analysis procedures are straightforward transformations of the
corresponding evaluation procedures (or <code class="code">eval</code> clauses) in 
<a class="ref" href="#g_t4_002e1_002e1">The Core of the Evaluator</a>.  She expected <code class="code">analyze_sequence</code> to look like this:
</p>
<div class="example">
<pre class="example-preformatted">// Alyssa's simpler version - loops at execution time
fn analyze_sequence(exps: &amp;[Expr]) -&gt; Result&lt;Executor, EvalError&gt; {
    fn execute_sequence(
        procs: &amp;[Executor],
        env: &amp;Environment,
    ) -&gt; Result&lt;Value, EvalError&gt; {
        if procs.len() == 1 {
            procs[0](env)
        } else {
            procs[0](env)?;
            execute_sequence(&amp;procs[1..], env)
        }
    }

    let procs: Vec&lt;Executor&gt; = exps
        .iter()
        .map(analyze)
        .collect::&lt;Result&lt;_, _&gt;&gt;()?;

    if procs.is_empty() {
        return Err(EvalError::EmptySequence);
    }

    Ok(Box::new(move |env| execute_sequence(&amp;procs, env)))
}
</pre></div>

<p>Eva Lu Ator explains to Alyssa that the version in the text does more of the
work of evaluating a sequence at analysis time.  Alyssa&rsquo;s sequence-execution
procedure, rather than having the calls to the individual execution procedures
built in, loops through the procedures in order to call them: In effect,
although the individual expressions in the sequence have been analyzed, the
sequence itself has not been.
</p>
<p>Compare the two versions of <code class="code">analyze_sequence</code>.  For example, consider the
common case (typical of procedure bodies) where the sequence has just one
expression.  What work will the execution procedure produced by Alyssa&rsquo;s
program do?  What about the execution procedure produced by the program in the
text above?  How do the two versions compare for a sequence with two
expressions?
</p></blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-4_002e24"></a>Exercise 4.24:</strong> Design and carry out some
experiments to compare the speed of the original metacircular evaluator with
the version in this section.  Use your results to estimate the fraction of time
that is spent in analysis versus execution for various procedures.
</p></blockquote>
<hr>
</div>
<div class="subsection-level-extent" id="g_t4_002e1_002e8">
<h4 class="subsection" id="Declarative-Macros_003a-Code-that-Generates-Code"><span>4.1.8 Declarative Macros: Code that Generates Code<a class="copiable-link" href="#Declarative-Macros_003a-Code-that-Generates-Code"> &para;</a></span></h4>

<a class="index-entry-id" id="index-declarative-macros"></a>
<a class="index-entry-id" id="index-macro_005frules_0021"></a>
<a class="index-entry-id" id="index-metaprogramming"></a>
<a class="index-entry-id" id="index-compile_002dtime-code-generation"></a>

<p>In our exploration of metalinguistic abstraction, we have seen how an evaluator
for a language can be implemented in another language. But what if we want to
extend the syntax of our implementation language itself? Rust provides a
powerful mechanism for this: <a class="index-entry-id" id="index-declarative-macros-1"></a>
<em class="dfn">declarative macros</em>, defined using the
<code class="code">macro_rules!</code> construct.
</p>
<p>Macros are fundamentally different from functions. While functions operate on
<em class="emph">values</em> at runtime, macros operate on <em class="emph">syntax</em> at compile time.
A macro takes code as input and produces new code as output, which is then
compiled as if you had written it by hand. This makes macros a true form of
metalinguistic abstraction&mdash;they allow you to extend the language itself.
</p>
<h4 class="subsubheading" id="What-Are-Macros_003f"><span>What Are Macros?<a class="copiable-link" href="#What-Are-Macros_003f"> &para;</a></span></h4>

<a class="index-entry-id" id="index-hygiene-_0028macro_0029"></a>
<a class="index-entry-id" id="index-compile_002dtime-expansion"></a>

<p>A macro is a pattern-matching and code-generation facility. When the Rust
compiler encounters a macro invocation (recognized by the trailing <code class="code">!</code>),
it <a class="index-entry-id" id="index-expands"></a>
<em class="dfn">expands</em> the macro by matching the input against the macro&rsquo;s
patterns and generating new code according to the corresponding template.
</p>
<p>Consider the built-in <code class="code">vec!</code> macro:
</p>
<div class="example">
<pre class="example-preformatted">let numbers = vec![1, 2, 3, 4, 5];
</pre></div>

<p>This is syntactic sugar that expands to:
</p>
<div class="example">
<pre class="example-preformatted">let numbers = {
    let mut temp_vec = Vec::new();
    temp_vec.push(1);
    temp_vec.push(2);
    temp_vec.push(3);
    temp_vec.push(4);
    temp_vec.push(5);
    temp_vec
};
</pre></div>

<p>The macro saved us from writing repetitive code and provided a cleaner syntax.
More importantly, this expansion happens at <em class="emph">compile time</em>, so there is
no runtime cost.
</p>
<h4 class="subsubheading" id="Basic-Macro-Syntax"><span>Basic Macro Syntax<a class="copiable-link" href="#Basic-Macro-Syntax"> &para;</a></span></h4>

<a class="index-entry-id" id="index-pattern-matching-_0028macros_0029"></a>
<a class="index-entry-id" id="index-transcription-_0028macros_0029"></a>

<p>A declarative macro is defined using <code class="code">macro_rules!</code> followed by a name
and a set of <em class="emph">rules</em>. Each rule has a <em class="emph">pattern</em> (the matcher) and a
<em class="emph">template</em> (the transcriber):
</p>
<p><b class="b">Rust:</b>
</p><div class="example">
<pre class="example-preformatted">macro_rules! say_hello {
    // Pattern =&gt; Template
    () =&gt; {
        println!(&quot;Hello, world!&quot;);
    };
}

// Usage:
say_hello!();  // Expands to: println!(&quot;Hello, world!&quot;);
</pre></div>

<p>The pattern <code class="code">()</code> matches an empty invocation. The template specifies what
code to generate. The macro above has a single rule, but macros can have
multiple rules that are tried in order:
</p>
<div class="example">
<pre class="example-preformatted">macro_rules! create_function {
    // Pattern matching a function name
    ($func_name:ident) =&gt; {
        fn $func_name() {
            println!(&quot;You called {:?}()&quot;, stringify!($func_name));
        }
    };
}

// Usage:
create_function!(foo);
create_function!(bar);

foo();  // Prints: You called &quot;foo&quot;()
bar();  // Prints: You called &quot;bar&quot;()
</pre></div>

<p>Here, <code class="code">$func_name:ident</code> is a <a class="index-entry-id" id="index-metavariable"></a>
<em class="dfn">metavariable</em> that captures an
identifier. The <code class="code">:ident</code> part is a <a class="index-entry-id" id="index-fragment-specifier"></a>
<em class="dfn">fragment specifier</em> that tells
the macro what kind of syntax to expect.
</p>
<h4 class="subsubheading" id="Fragment-Specifiers"><span>Fragment Specifiers<a class="copiable-link" href="#Fragment-Specifiers"> &para;</a></span></h4>

<a class="index-entry-id" id="index-fragment-specifiers"></a>
<a class="index-entry-id" id="index-metavariables"></a>

<p>Rust macros can capture different kinds of syntax elements:
</p>
<ul class="itemize mark-bullet">
<li><code class="code">ident</code> &mdash; An identifier (variable name, function name, etc.)

</li><li><code class="code">expr</code> &mdash; An expression (<code class="code">1 + 2</code>, <code class="code">foo()</code>, etc.)

</li><li><code class="code">stmt</code> &mdash; A statement (<code class="code">let x = 5;</code>, etc.)

</li><li><code class="code">ty</code> &mdash; A type (<code class="code">i32</code>, <code class="code">Vec&lt;String&gt;</code>, etc.)

</li><li><code class="code">pat</code> &mdash; A pattern (match arm pattern)

</li><li><code class="code">path</code> &mdash; A path (<code class="code">std::collections::HashMap</code>)

</li><li><code class="code">tt</code> &mdash; A single token tree (any single balanced token)

</li><li><code class="code">block</code> &mdash; A block of code (<code class="code">{ ... }</code>)

</li><li><code class="code">item</code> &mdash; An item (function, struct, etc.)

</li><li><code class="code">meta</code> &mdash; Attribute contents

</li><li><code class="code">literal</code> &mdash; A literal expression (<code class="code">42</code>, <code class="code">&quot;hello&quot;</code>, etc.)

</li></ul>

<p><b class="b">Rust:</b>
</p><div class="example">
<pre class="example-preformatted">macro_rules! create_variable {
    // Capture a variable name and an expression
    ($var_name:ident = $value:expr) =&gt; {
        let $var_name = $value;
    };
}

// Usage:
create_variable!(x = 42);
create_variable!(message = &quot;Hello&quot;.to_string());
</pre></div>

<h4 class="subsubheading" id="Repetition-Patterns"><span>Repetition Patterns<a class="copiable-link" href="#Repetition-Patterns"> &para;</a></span></h4>

<a class="index-entry-id" id="index-repetition-_0028macros_0029"></a>
<a class="index-entry-id" id="index-variadic-macros"></a>

<p>One of the most powerful features of declarative macros is the ability to
handle variable numbers of arguments through <a class="index-entry-id" id="index-repetition-patterns"></a>
<em class="dfn">repetition patterns</em>.
These are specified using <code class="code">$(...)</code>, followed by a repetition operator:
</p>
<ul class="itemize mark-bullet">
<li><code class="code">$(...)*</code> &mdash; Zero or more repetitions

</li><li><code class="code">$(...)+</code> &mdash; One or more repetitions

</li><li><code class="code">$(...){,}</code> &mdash; Zero or more repetitions separated by a specific token
(here, a comma)

</li></ul>

<p>Here&rsquo;s how we might implement our own simplified <code class="code">vec!</code> macro:
</p>
<p><b class="b">Rust:</b>
</p><div class="example">
<pre class="example-preformatted">macro_rules! my_vec {
    // Match zero or more comma-separated expressions
    ( $( $element:expr ),* ) =&gt; {
        {
            let mut temp_vec = Vec::new();
            $(
                temp_vec.push($element);
            )*
            temp_vec
        }
    };
}

// Usage:
let v = my_vec![1, 2, 3, 4, 5];
let empty: Vec&lt;i32&gt; = my_vec![];
</pre></div>

<p>The pattern <code class="code">$( $element:expr ),*</code> matches zero or more comma-separated
expressions. The template <code class="code">$( temp_vec.push($element); )*</code> repeats the
push statement once for each captured element.
</p>
<h4 class="subsubheading" id="Macro-Hygiene"><span>Macro Hygiene<a class="copiable-link" href="#Macro-Hygiene"> &para;</a></span></h4>

<a class="index-entry-id" id="index-hygiene-_0028macro_0029-1"></a>
<a class="index-entry-id" id="index-name-collision-_0028macros_0029"></a>

<p>A critical property of Rust macros is <a class="index-entry-id" id="index-hygiene"></a>
<em class="dfn">hygiene</em>. Unlike C preprocessor
macros, Rust macros are hygienic, meaning they avoid accidental name collisions
between macro-generated code and the surrounding context.
</p>
<p>Consider this C preprocessor macro (which Rust does <em class="emph">not</em> use):
</p>
<div class="example">
<pre class="example-preformatted">// C preprocessor (NOT Rust!)
#define SWAP(a, b) { int temp = a; a = b; b = temp; }

int temp = 1;
int x = 2;
SWAP(temp, x);  // BUG! The macro's temp shadows our variable
</pre></div>

<p>In Rust, macros are hygienic by default:
</p>
<p><b class="b">Rust:</b>
</p><div class="example">
<pre class="example-preformatted">macro_rules! swap {
    ($a:expr, $b:expr) =&gt; {
        {
            let temp = $a;  // This 'temp' won't collide with outside scope
            $a = $b;
            $b = temp;
        }
    };
}
</pre></div>

<p>However, there&rsquo;s a subtlety here: the <code class="code">$a</code> and <code class="code">$b</code> in the template
refer to the <em class="emph">expressions</em> passed in, which must be assignable (lvalues).
A better implementation would use <code class="code">std::mem::swap</code> or require mutable
references:
</p>
<div class="example">
<pre class="example-preformatted">macro_rules! swap {
    ($a:expr, $b:expr) =&gt; {
        std::mem::swap(&amp;mut $a, &amp;mut $b);
    };
}
</pre></div>

<p>Hygiene means that variables introduced inside a macro won&rsquo;t interfere with
variables in the calling context, and vice versa. This is a significant
improvement over C-style text substitution.
</p>
<h4 class="subsubheading" id="Building-a-Domain_002dSpecific-Language"><span>Building a Domain-Specific Language<a class="copiable-link" href="#Building-a-Domain_002dSpecific-Language"> &para;</a></span></h4>

<a class="index-entry-id" id="index-domain_002dspecific-language"></a>
<a class="index-entry-id" id="index-DSL"></a>
<a class="index-entry-id" id="index-embedded-DSL"></a>

<p>Macros excel at creating domain-specific languages (<abbr class="abbr">DSL</abbr>s) embedded
within Rust. Let&rsquo;s build a simple <abbr class="abbr">DSL</abbr> for defining hash maps with
a clean syntax:
</p>
<p><b class="b">Rust:</b>
</p><div class="example">
<pre class="example-preformatted">use std::collections::HashMap;

macro_rules! hashmap {
    // Empty map
    () =&gt; {
        HashMap::new()
    };

    // Map with key-value pairs
    ( $( $key:expr =&gt; $value:expr ),+ $(,)? ) =&gt; {
        {
            let mut map = HashMap::new();
            $(
                map.insert($key, $value);
            )+
            map
        }
    };
}

// Usage:
let capitals = hashmap! {
    &quot;France&quot; =&gt; &quot;Paris&quot;,
    &quot;Germany&quot; =&gt; &quot;Berlin&quot;,
    &quot;Italy&quot; =&gt; &quot;Rome&quot;,
};

let empty: HashMap&lt;&amp;str, i32&gt; = hashmap!();
</pre></div>

<p>Notice the <code class="code">$(,)?</code> at the end of the pattern&mdash;this matches an optional
trailing comma, which is idiomatic in Rust.
</p>
<p>Here&rsquo;s a more sophisticated example that creates a mini-DSL for assertion
messages:
</p>
<p><b class="b">Rust:</b>
</p><div class="example">
<pre class="example-preformatted">macro_rules! assert_bounds {
    ($value:expr, $min:expr, $max:expr) =&gt; {
        assert!(
            $value &gt;= $min &amp;&amp; $value &lt;= $max,
            &quot;{} (value: {}) must be between {} and {}&quot;,
            stringify!($value),
            $value,
            $min,
            $max
        );
    };
}

// Usage:
let x = 150;
assert_bounds!(x, 0, 100);
// Panics with: &quot;x (value: 150) must be between 0 and 100&quot;
</pre></div>

<p>The <code class="code">stringify!</code> macro (built into Rust) converts a syntax tree fragment
to a string literal, allowing us to show the variable name in error messages.
</p>
<h4 class="subsubheading" id="Multiple-Macro-Rules"><span>Multiple Macro Rules<a class="copiable-link" href="#Multiple-Macro-Rules"> &para;</a></span></h4>

<a class="index-entry-id" id="index-pattern-matching-_0028macros_0029-1"></a>
<a class="index-entry-id" id="index-rule-priority-_0028macros_0029"></a>

<p>Macros can have multiple rules that are tried in order from top to bottom.
The first matching rule is used:
</p>
<p><b class="b">Rust:</b>
</p><div class="example">
<pre class="example-preformatted">macro_rules! calculate {
    // Single number
    ($value:expr) =&gt; {
        $value
    };

    // Addition
    (add $a:expr, $b:expr) =&gt; {
        $a + $b
    };

    // Multiplication
    (mul $a:expr, $b:expr) =&gt; {
        $a * $b
    };

    // Nested expressions
    (eval $($t:tt)*) =&gt; {
        {
            calculate!($($t)*)
        }
    };
}

// Usage:
let x = calculate!(5);              // =&gt; 5
let y = calculate!(add 3, 4);       // =&gt; 7
let z = calculate!(mul 2, 10);      // =&gt; 20
</pre></div>

<p>The <code class="code">tt</code> (token tree) specifier matches any single token, and
<code class="code">$($t:tt)*</code> captures all tokens. This is useful for recursive macros or
when you want to pass through arbitrary syntax.
</p>
<h4 class="subsubheading" id="Debugging-Macros"><span>Debugging Macros<a class="copiable-link" href="#Debugging-Macros"> &para;</a></span></h4>

<a class="index-entry-id" id="index-cargo-expand"></a>
<a class="index-entry-id" id="index-macro-debugging"></a>
<a class="index-entry-id" id="index-rustc-_002d_002dpretty_003dexpanded"></a>

<p>Since macros operate at compile time and transform code, debugging them can be
challenging. Rust provides tools to help:
</p>
<ol class="enumerate">
<li> <b class="b">cargo expand</b> &mdash; A cargo subcommand that shows the expanded version of
your code. Install it with <code class="code">cargo install cargo-expand</code>, then run:

<div class="example">
<pre class="example-preformatted">cargo expand
</pre></div>

<p>This shows your source code with all macros expanded, making it clear what
code is actually being generated.
</p>
</li><li> <b class="b">rustc &ndash;pretty=expanded</b> &mdash; The compiler can also show expanded code:

<div class="example">
<pre class="example-preformatted">rustc src/main.rs -Z unpretty=expanded
</pre></div>

</li><li> <b class="b">Compiler error messages</b> &mdash; The Rust compiler will show you where a macro
expansion failed and often indicates which rule it was trying to match.

</li></ol>

<p>For example, if we expand our <code class="code">my_vec!</code> macro:
</p>
<div class="example">
<pre class="example-preformatted">// Source:
let v = my_vec![1, 2, 3];

// Expanded (approximately):
let v = {
    let mut temp_vec = Vec::new();
    temp_vec.push(1);
    temp_vec.push(2);
    temp_vec.push(3);
    temp_vec
};
</pre></div>

<h4 class="subsubheading" id="When-to-Use-Macros-vs-Functions-vs-Generics"><span>When to Use Macros vs Functions vs Generics<a class="copiable-link" href="#When-to-Use-Macros-vs-Functions-vs-Generics"> &para;</a></span></h4>

<a class="index-entry-id" id="index-when-to-use-macros"></a>
<a class="index-entry-id" id="index-macros-vs-functions"></a>
<a class="index-entry-id" id="index-design-decisions"></a>

<p>Rust offers multiple abstraction mechanisms: functions, generics, trait objects,
and macros. Here&rsquo;s when to use each:
</p>
<p><b class="b">Use functions when:</b>
</p>
<ul class="itemize mark-bullet">
<li>You&rsquo;re operating on <em class="emph">values</em>, not syntax

</li><li>The operation is well-defined and type-checkable

</li><li>You don&rsquo;t need to generate boilerplate code

</li></ul>

<p><b class="b">Use generics when:</b>
</p>
<ul class="itemize mark-bullet">
<li>You want compile-time polymorphism over types

</li><li>You can express the abstraction with trait bounds

</li><li>Type inference can help reduce verbosity

</li></ul>

<p><b class="b">Use macros when:</b>
</p>
<ul class="itemize mark-bullet">
<li>You need to generate repetitive code

</li><li>You want to create custom syntax or a <abbr class="abbr">DSL</abbr>

</li><li>You need compile-time computation that generics can&rsquo;t express

</li><li>You want to avoid runtime overhead completely

</li><li>You need to operate on identifiers, types, or other syntax elements

</li><li>You want variadic arguments (before variadic generics are stable)

</li></ul>

<p><b class="b">Example:</b> Consider implementing a function that takes a variable number of
arguments. In most languages, you&rsquo;d use variadic functions. In Rust (without
macros), you&rsquo;d need to pass a slice:
</p>
<div class="example">
<pre class="example-preformatted">// Without macros:
fn print_all(items: &amp;[&amp;str]) {
    for item in items {
        println!(&quot;{}&quot;, item);
    }
}

print_all(&amp;[&quot;hello&quot;, &quot;world&quot;]);  // Need to create a slice
</pre></div>

<p>With macros, we can create a more ergonomic interface:
</p>
<div class="example">
<pre class="example-preformatted">macro_rules! print_all {
    ($($item:expr),*) =&gt; {
        $(
            println!(&quot;{}&quot;, $item);
        )*
    };
}

print_all!(&quot;hello&quot;, &quot;world&quot;, &quot;!&quot;);  // No slice needed
</pre></div>

<h4 class="subsubheading" id="Connection-to-Metalinguistic-Abstraction"><span>Connection to Metalinguistic Abstraction<a class="copiable-link" href="#Connection-to-Metalinguistic-Abstraction"> &para;</a></span></h4>

<a class="index-entry-id" id="index-metalinguistic-abstraction"></a>
<a class="index-entry-id" id="index-meta_002dcircular-evaluator"></a>

<p>Declarative macros embody the principle of <a class="index-entry-id" id="index-metalinguistic-abstraction-1"></a>
<em class="dfn">metalinguistic abstraction</em>
that is central to Chapter 4. Just as we built an evaluator for Scheme <em class="emph">in</em>
Scheme (a meta-circular evaluator), Rust macros allow us to extend Rust <em class="emph">in</em>
Rust.
</p>
<p>The parallel is deep:
</p>
<ul class="itemize mark-bullet">
<li><b class="b">Pattern matching:</b> Just as our evaluator uses pattern matching to classify
expressions (<code class="code">if</code>, <code class="code">lambda</code>, <code class="code">define</code>, etc.), macros use pattern
matching to recognize syntax structures.

</li><li><b class="b">Syntax transformation:</b> Our evaluator transforms source code into evaluated
results. Macros transform source code into other source code.

</li><li><b class="b">Hygiene and scope:</b> Just as our evaluator maintains environment frames to
avoid variable capture, Rust macros maintain hygiene to avoid name collisions.

</li><li><b class="b">Compile-time vs runtime:</b> Macros operate at compile time, producing code
that runs later. This is analogous to partial evaluation or staging in
programming language theory.

</li></ul>

<p>In fact, macros are a form of <em class="emph">syntactic abstraction</em>, while functions
provide <em class="emph">procedural abstraction</em>. Both are essential tools for managing
complexity in large systems.
</p>
<h4 class="subsubheading" id="A-Complete-Example_003a-Testing-DSL"><span>A Complete Example: Testing DSL<a class="copiable-link" href="#A-Complete-Example_003a-Testing-DSL"> &para;</a></span></h4>

<a class="index-entry-id" id="index-test-macro"></a>
<a class="index-entry-id" id="index-DSL-example"></a>

<p>Let&rsquo;s build a practical macro that creates a mini-DSL for property-based
testing, similar to what the <code class="code">proptest</code> crate provides:
</p>
<p><b class="b">Rust:</b>
</p><div class="example">
<pre class="example-preformatted">macro_rules! property_test {
    (
        $test_name:ident:
        forall $var:ident in $range:expr =&gt;
        $property:expr
    ) =&gt; {
        #[test]
        fn $test_name() {
            for $var in $range {
                assert!(
                    $property,
                    &quot;Property failed for {} = {}&quot;,
                    stringify!($var),
                    $var
                );
            }
        }
    };
}

// Usage:
property_test! {
    test_square_non_negative:
    forall x in -100..100 =&gt;
    (x * x &gt;= 0)
}

property_test! {
    test_double_is_even:
    forall n in 0..1000 =&gt;
    ((n * 2) % 2 == 0)
}
</pre></div>

<p>This macro generates complete test functions with clear failure messages,
demonstrating how macros can reduce boilerplate while maintaining expressiveness.
</p>
<h4 class="subsubheading" id="Limitations-and-Caveats"><span>Limitations and Caveats<a class="copiable-link" href="#Limitations-and-Caveats"> &para;</a></span></h4>

<a class="index-entry-id" id="index-macro-limitations"></a>
<a class="index-entry-id" id="index-procedural-macros"></a>

<p>While powerful, declarative macros have limitations:
</p>
<ol class="enumerate">
<li> <b class="b">Complexity:</b> Large macros can become hard to understand and maintain.

</li><li> <b class="b">Error messages:</b> When a macro expansion fails, error messages can be
cryptic.

</li><li> <b class="b">Debugging:</b> Stepping through macro-generated code with a debugger is
difficult.

</li><li> <b class="b">Compile time:</b> Heavy macro use can slow compilation.

</li><li> <b class="b">Pattern limitations:</b> Some syntactic transformations are impossible with
<code class="code">macro_rules!</code> and require procedural macros (which operate on the
<abbr class="abbr">AST</abbr> directly).

</li></ol>

<p>For more complex metaprogramming tasks, Rust offers <a class="index-entry-id" id="index-procedural-macros-1"></a>
<em class="dfn">procedural macros</em>,
which are functions that operate on token streams or syntax trees. These include
custom <code class="code">#[derive]</code> macros, attribute macros, and function-like procedural
macros. Declarative macros are simpler and sufficient for most use cases.
</p>
<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-4_002e16a"></a>Exercise 4.16a:</strong> Define a macro <code class="code">unless!</code>
that works like an inverted <code class="code">if</code> statement&mdash;it executes a block of code
only when a condition is <em class="emph">false</em>:
</p>
<div class="example">
<pre class="example-preformatted">unless!(x &gt; 10) {
    println!(&quot;x is not greater than 10&quot;);
}
</pre></div>

<p>Your macro should support both forms:
</p>
<div class="example">
<pre class="example-preformatted">// Without else
unless!(condition) {
    // executed if condition is false
}

// With else
unless!(condition) {
    // executed if condition is false
} else {
    // executed if condition is true
}
</pre></div>
</blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-4_002e17a"></a>Exercise 4.17a:</strong> Write a <code class="code">calc!</code> macro that
implements a simple calculator <abbr class="abbr">DSL</abbr>. It should support basic arithmetic
with infix notation:
</p>
<div class="example">
<pre class="example-preformatted">let result = calc!({
    2 + 3 * 4
});  // Should evaluate to 14

let x = 5;
let y = calc!({
    x * 2 + 10
});  // Should evaluate to 20
</pre></div>

<p><em class="emph">Hint:</em> You may need to use the <code class="code">tt</code> fragment specifier and recursive
macro rules. Start with a simpler version that only handles two operands:
<code class="code">calc!(2 + 3)</code>, then extend it.
</p>
<p>For a greater challenge, implement proper operator precedence (multiplication
before addition).
</p></blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-4_002e18a"></a>Exercise 4.18a:</strong> The <code class="code">hashmap!</code> macro we
defined earlier creates a new <code class="code">HashMap</code> and inserts elements one by one.
However, if we know the number of elements at compile time, we can pre-allocate
the hash map&rsquo;s capacity for better performance.
</p>
<ol class="enumerate" type="a" start="1">
<li> Modify the <code class="code">hashmap!</code> macro to count the number of key-value pairs and
use <code class="code">HashMap::with_capacity</code> instead of <code class="code">HashMap::new</code>.

</li><li> The standard library&rsquo;s <code class="code">vec!</code> macro supports both <code class="code">vec![1, 2, 3]</code>
and <code class="code">vec![0; 100]</code> (create a vector with 100 zeros). Extend your
<code class="code">hashmap!</code> macro to support a similar syntax for creating maps with
repeated values:

<div class="example">
<pre class="example-preformatted">// Creates a map: {&quot;a&quot; =&gt; 0, &quot;b&quot; =&gt; 0, &quot;c&quot; =&gt; 0}
let map = hashmap!(&quot;a&quot;, &quot;b&quot;, &quot;c&quot; =&gt; 0);
</pre></div>

</li><li> Explain why this kind of API design (providing multiple convenient syntaxes)
is particularly well-suited to macros rather than functions.

</li></ol>
</blockquote>


</div>
</div>
<div class="footnotes-segment">
<hr>
<h4 class="footnotes-heading">Footnotes</h4>

<h5 class="footnote-body-heading"><a id="FOOT198" href="#DOCF198">(198)</a></h5>
<p>Even so, there will remain
important aspects of the evaluation process that are not elucidated by our
evaluator.  The most important of these are the detailed mechanisms by which
procedures call other procedures and return values to their callers.  We will
address these issues in <a class="ref" href="Chapter-5.xhtml">Computing with Register Machines</a>, where we take a closer look at the
evaluation process by implementing the evaluator as a simple register machine.</p>
<h5 class="footnote-body-heading"><a id="FOOT199" href="#DOCF199">(199)</a></h5>
<p>If we grant ourselves the
ability to apply primitives, then what remains for us to implement in the
evaluator?  The job of the evaluator is not to specify the primitives of the
language, but rather to provide the connective tissue&mdash;the means of
combination and the means of abstraction&mdash;that binds a collection of
primitives to form a language. Specifically:
</p>
<ul class="itemize mark-bullet">
<li>The evaluator enables us to deal with nested expressions.  For example,
although simply applying primitives would suffice for evaluating the expression
<code class="code">(+ 1 6)</code>, it is not adequate for handling <code class="code">(+ 1 (* 2 3))</code>.  As far
as the primitive procedure <code class="code">+</code> is concerned, its arguments must be
numbers, and it would choke if we passed it the expression <code class="code">(* 2 3)</code> as an
argument.  One important role of the evaluator is to choreograph procedure
composition so that <code class="code">(* 2 3)</code> is reduced to 6 before being passed as an
argument to <code class="code">+</code>.

</li><li>The evaluator allows us to use variables.  For example, the primitive procedure
for addition has no way to deal with expressions such as <code class="code">(+ x 1)</code>.  We
need an evaluator to keep track of variables and obtain their values before
invoking the primitive procedures.

</li><li>The evaluator allows us to define compound procedures.  This involves keeping
track of procedure definitions, knowing how to use these definitions in
evaluating expressions, and providing a mechanism that enables procedures to
accept arguments.

</li><li>The evaluator provides the special forms, which must be evaluated differently
from procedure calls.

</li></ul>
<h5 class="footnote-body-heading"><a id="FOOT200" href="#DOCF200">(200)</a></h5>
<p>In this case, the language
being implemented and the implementation language are the same.  Contemplation
of the meaning of <code class="code">is_true</code> here yields expansion of consciousness without
the abuse of substance.</p>
<h5 class="footnote-body-heading"><a id="FOOT201" href="#DOCF201">(201)</a></h5>
<p>As we said when we introduced
definition and <code class="code">set!</code>, these values are implementation-dependent in
Scheme&mdash;that is, the implementor can choose what value to return.</p>
<h5 class="footnote-body-heading"><a id="FOOT202" href="#DOCF202">(202)</a></h5>
<p>The
value of a <code class="code">cond</code> expression when all the predicates are false and there
is no <code class="code">else</code> clause is unspecified in Scheme; we have chosen here to make
it false.</p>
<h5 class="footnote-body-heading"><a id="FOOT203" href="#DOCF203">(203)</a></h5>
<p>Practical Lisp systems provide a mechanism that allows a user
to add new derived expressions and specify their implementation as syntactic
transformations without modifying the evaluator.  Such a user-defined
transformation is called a <a class="index-entry-id" id="index-macro"></a>
<em class="dfn">macro</em>.  Although it is easy to add an
elementary mechanism for defining macros, the resulting language has subtle
name-conflict problems.  There has been much research on mechanisms for macro
definition that do not cause these difficulties.  See, for example, <a class="ref" href="References.xhtml#Kohlbecker-1986">Kohlbecker 1986</a>, 
<a class="ref" href="References.xhtml#Clinger-and-Rees-1991">Clinger and Rees 1991</a>, and <a class="ref" href="References.xhtml#Hanson-1991">Hanson 1991</a>.</p>
<h5 class="footnote-body-heading"><a id="FOOT204" href="#DOCF204">(204)</a></h5>
<p>The fact that the machines are described in Rust is
inessential.  If we give our evaluator a Rust program that behaves as an
evaluator for some other language, say C, the Rust evaluator will emulate the C
evaluator, which in turn can emulate any machine described as a C program.
Similarly, writing a Rust evaluator in C produces a C program that can execute
any Rust program.  The deep idea here is that any evaluator can emulate any
other.  Thus, the notion of &ldquo;what can in principle be computed&rdquo; (ignoring
practicalities of time and memory required) is independent of the language or
the computer, and instead reflects an underlying notion of
<a class="index-entry-id" id="index-computability"></a>
<em class="dfn">computability</em>.  This was first demonstrated in a clear way by Alan
M. Turing (1912-1954), whose 1936 paper laid the foundations for theoretical
computer science.  In the paper, Turing presented a simple computational
model&mdash;now known as a <a class="index-entry-id" id="index-Turing-machine"></a>
<em class="dfn">Turing machine</em>&mdash;and argued that any
&ldquo;effective process&rdquo; can be formulated as a program for such a machine.  (This
argument is known as the <a class="index-entry-id" id="index-Church_002dTuring-thesis"></a>
<em class="dfn">Church-Turing thesis</em>.)  Turing then
implemented a universal machine, i.e., a Turing machine that behaves as an
evaluator for Turing-machine programs.  He used this framework to demonstrate
that there are well-posed problems that cannot be computed by Turing machines
(see <a class="ref" href="#Exercise-4_002e15">Exercise 4.15</a>), and so by implication cannot be formulated as
&ldquo;effective processes.&rdquo;  Turing went on to make fundamental contributions to
practical computer science as well.  For example, he invented the idea of
structuring programs using general-purpose subroutines.  See <a class="ref" href="References.xhtml#Hodges-1983">Hodges 1983</a> for a
biography of Turing.</p>
<h5 class="footnote-body-heading"><a id="FOOT205" href="#DOCF205">(205)</a></h5>
<p>Some people find it counterintuitive that an evaluator, which
is implemented by a relatively simple procedure, can emulate programs that are
more complex than the evaluator itself.  The existence of a universal evaluator
machine is a deep and wonderful property of computation.  <a class="index-entry-id" id="index-Recursion-theory"></a>
<em class="dfn">Recursion theory</em>, 
a branch of mathematical logic, is concerned with logical limits of
computation.  Douglas Hofstadter&rsquo;s beautiful book <cite class="cite">G&ouml;del, Escher, Bach</cite>
explores some of these ideas (<a class="ref" href="References.xhtml#Hofstadter-1979">Hofstadter 1979</a>).</p>
<h5 class="footnote-body-heading"><a id="FOOT206" href="#DOCF206">(206)</a></h5>
<p>Warning: This <code class="code">eval</code> primitive is not identical to
the <code class="code">eval</code> procedure we implemented in <a class="ref" href="#g_t4_002e1_002e1">The Core of the Evaluator</a>, because it
uses <em class="emph">actual</em> language environments rather than the sample environment
structures we built in <a class="ref" href="#g_t4_002e1_002e3">Evaluator Data Structures</a>.  Similarly, the <code class="code">apply</code> primitive
we saw earlier is not identical to the metacircular <code class="code">apply</code>, because it
uses actual Rust procedures rather than the procedure objects we constructed
in <a class="ref" href="#g_t4_002e1_002e3">Evaluator Data Structures</a> and <a class="ref" href="#g_t4_002e1_002e4">Running the Evaluator as a Program</a>.</p>
<h5 class="footnote-body-heading"><a id="FOOT207" href="#DOCF207">(207)</a></h5>
<p>The <abbr class="abbr">MIT</abbr> implementation of Scheme
includes <code class="code">eval</code>, as well as a symbol <code class="code">user_initial_environment</code> that
is bound to the initial environment in which the user&rsquo;s input expressions are
evaluated.</p>
<h5 class="footnote-body-heading"><a id="FOOT208" href="#DOCF208">(208)</a></h5>
<p>Although we stipulated that <code class="code">halts?</code>
is given a procedure object, notice that this reasoning still applies even if
<code class="code">halts?</code> can gain access to the procedure&rsquo;s text and its environment.
This is Turing&rsquo;s celebrated <a class="index-entry-id" id="index-Halting-Theorem"></a>
<em class="dfn">Halting Theorem</em>, which gave the first
clear example of a <a class="index-entry-id" id="index-non_002dcomputable"></a>
<em class="dfn">non-computable</em> problem, i.e., a well-posed task
that cannot be carried out as a computational procedure.</p>
<h5 class="footnote-body-heading"><a id="FOOT209" href="#DOCF209">(209)</a></h5>
<p>Wanting programs
to not depend on this evaluation mechanism is the reason for the &ldquo;management
is not responsible&rdquo; remark in <a class="ref" href="1_002e1.xhtml#Footnote-28">Footnote 28</a> of <a class="ref" href="Chapter-1.xhtml">Building Abstractions with Procedures</a>.  By
insisting that internal definitions come first and do not use each other while
the definitions are being evaluated, the <abbr class="abbr">IEEE</abbr> standard for Scheme
leaves implementors some choice in the mechanism used to evaluate these
definitions.  The choice of one evaluation rule rather than another here may
seem like a small issue, affecting only the interpretation of &ldquo;badly formed&rdquo;
programs.  However, we will see in <a class="ref" href="5_002e5.xhtml#g_t5_002e5_002e6">Lexical Addressing</a> that moving to a model
of simultaneous scoping for internal definitions avoids some nasty difficulties
that would otherwise arise in implementing a compiler.</p>
<h5 class="footnote-body-heading"><a id="FOOT210" href="#DOCF210">(210)</a></h5>
<p>The <abbr class="abbr">IEEE</abbr> standard for Scheme
allows for different implementation strategies by specifying that it is up to
the programmer to obey this restriction, not up to the implementation to
enforce it.</p>
<h5 class="footnote-body-heading"><a id="FOOT211" href="#DOCF211">(211)</a></h5>
<p>The <abbr class="abbr">MIT</abbr>
implementors of Scheme support Alyssa on the following grounds: Eva is in
principle correct&mdash;the definitions should be regarded as simultaneous.  But
it seems difficult to implement a general, efficient mechanism that does what
Eva requires.  In the absence of such a mechanism, it is better to generate an
error in the difficult cases of simultaneous definitions (Alyssa&rsquo;s notion) than
to produce an incorrect answer (as Ben would have it).</p>
<h5 class="footnote-body-heading"><a id="FOOT212" href="#DOCF212">(212)</a></h5>
<p>This example illustrates a programming trick for
formulating recursive procedures without using definition.  The most general
trick of this sort is the <em class="math">Y</em> <a class="index-entry-id" id="index-operator"></a>
<em class="dfn">operator</em>, which can be used to give a
&ldquo;pure λ-calculus&rdquo; implementation of recursion.  (See <a class="ref" href="References.xhtml#Stoy-1977">Stoy 1977</a> for
details on the λ-calculus, and <a class="ref" href="References.xhtml#Gabriel-1988">Gabriel 1988</a> for an exposition of the
<em class="math">Y</em> operator in Scheme.)</p>
<h5 class="footnote-body-heading"><a id="FOOT213" href="#DOCF213">(213)</a></h5>
<p>This
technique is an integral part of the compilation process, which we shall
discuss in <a class="ref" href="Chapter-5.xhtml">Computing with Register Machines</a>.  Jonathan Rees wrote a Scheme interpreter like this
in about 1982 for the T project (<a class="ref" href="References.xhtml#Rees-and-Adams-1982">Rees and Adams 1982</a>).  Marc <a class="ref" href="References.xhtml#Feeley-_00281986_0029">Feeley (1986)</a> (see
also <a class="ref" href="References.xhtml#Feeley-and-Lapalme-1987">Feeley and Lapalme 1987</a>) independently invented this technique in his
master&rsquo;s thesis.</p>
<h5 class="footnote-body-heading"><a id="FOOT214" href="#DOCF214">(214)</a></h5>
<p>There is, however, an
important part of the variable search that <em class="emph">can</em> be done as part of the
syntactic analysis.  As we will show in <a class="ref" href="5_002e5.xhtml#g_t5_002e5_002e6">Lexical Addressing</a>, one can determine
the position in the environment structure where the value of the variable will
be found, thus obviating the need to scan the environment for the entry that
matches the variable.</p>
<h5 class="footnote-body-heading"><a id="FOOT215" href="#DOCF215">(215)</a></h5>
<p>See <a class="ref" href="#Exercise-4_002e23">Exercise 4.23</a>
for some insight into the processing of sequences.</p>
</div>
<hr>
<div class="nav-panel">
<p>
Next: <a href="4_002e2.xhtml#g_t4_002e2" accesskey="n" rel="next">Variations on a Scheme &mdash; Lazy Evaluation</a>, Previous: <a href="Chapter-4.xhtml" accesskey="p" rel="prev">Metalinguistic Abstraction</a>, Up: <a href="Chapter-4.xhtml" accesskey="u" rel="up">Metalinguistic Abstraction</a> &nbsp; [<a href="index.xhtml#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Term-Index.xhtml" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
