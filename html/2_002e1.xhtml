<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<!-- Created by GNU Texinfo 7.1, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>2.1 (Structure and Interpretation of Computer Programs, 2e)</title>

<meta name="description" content="2.1 (Structure and Interpretation of Computer Programs, 2e)" />
<meta name="keywords" content="2.1 (Structure and Interpretation of Computer Programs, 2e)" />
<meta name="resource-type" content="document" />
<meta name="distribution" content="global" />
<meta name="Generator" content="texi2any" />
<meta name="viewport" content="width=device-width,initial-scale=1" />

<link href="index.xhtml" rel="start" title="Top" />
<link href="Term-Index.xhtml" rel="index" title="Term Index" />
<link href="index.xhtml#SEC_Contents" rel="contents" title="Table of Contents" />
<link href="Chapter-2.xhtml" rel="up" title="Chapter 2" />
<link href="2_002e2.xhtml#g_t2_002e2" rel="next" title="2.2" />
<link href="Chapter-2.xhtml" rel="prev" title="Chapter 2" />
<style type="text/css">
<!--
a.copiable-link {visibility: hidden; text-decoration: none; line-height: 0em}
div.example {margin-left: 3.2em}
span:hover a.copiable-link {visibility: visible}
ul.mark-bullet {list-style-type: disc}
-->
</style>

<script src="js/jquery.min.js" type="text/javascript"></script>
<script src="js/footnotes.js" type="text/javascript"></script>
<script src="js/browsertest.js" type="text/javascript"></script>
</head>

<body lang="en">
<div class="section-level-extent" id="g_t2_002e1">
<div class="nav-panel">
<p>
Next: <a href="2_002e2.xhtml#g_t2_002e2" accesskey="n" rel="next">Hierarchical Data and the Closure Property</a>, Previous: <a href="Chapter-2.xhtml" accesskey="p" rel="prev">Building Abstractions with Data</a>, Up: <a href="Chapter-2.xhtml" accesskey="u" rel="up">Building Abstractions with Data</a> &#160; [<a href="index.xhtml#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Term-Index.xhtml" title="Index" rel="index">Index</a>]</p>
</div>
<h3 class="section" id="Introduction-to-Data-Abstraction"><span>2.1 Introduction to Data Abstraction<a class="copiable-link" href="#Introduction-to-Data-Abstraction"> &#182;</a></span></h3>

<p>In <a class="ref" href="1_002e1.xhtml#g_t1_002e1_002e8">Procedures as Black-Box Abstractions</a>, we noted that a procedure used as an element in
creating a more complex procedure could be regarded not only as a collection of
particular operations but also as a procedural abstraction.  That is, the
details of how the procedure was implemented could be suppressed, and the
particular procedure itself could be replaced by any other procedure with the
same overall behavior.  In other words, we could make an abstraction that would
separate the way the procedure would be used from the details of how the
procedure would be implemented in terms of more primitive procedures.  The
analogous notion for compound data is called <a class="index-entry-id" id="index-data-abstraction-1"></a>
<em class="dfn">data abstraction</em>.  Data
abstraction is a methodology that enables us to isolate how a compound data
object is used from the details of how it is constructed from more primitive
data objects.
</p>
<p>The basic idea of data abstraction is to structure the programs that are to use
compound data objects so that they operate on &#8220;abstract data.&#8221; That is, our
programs should use data in such a way as to make no assumptions about the data
that are not strictly necessary for performing the task at hand.  At the same
time, a &#8220;concrete&#8221; data representation is defined independent of the programs
that use the data.  The interface between these two parts of our system will be
a set of procedures, called <a class="index-entry-id" id="index-selectors"></a>
<em class="dfn">selectors</em> and <a class="index-entry-id" id="index-constructors"></a>
<em class="dfn">constructors</em>,
that implement the abstract data in terms of the concrete representation.  To
illustrate this technique, we will consider how to design a set of procedures
for manipulating rational numbers.
</p>

<hr />
<div class="subsection-level-extent" id="g_t2_002e1_002e1">
<h4 class="subsection" id="Example_003a-Arithmetic-Operations-for-Rational-Numbers"><span>2.1.1 Example: Arithmetic Operations for Rational Numbers<a class="copiable-link" href="#Example_003a-Arithmetic-Operations-for-Rational-Numbers"> &#182;</a></span></h4>

<p>Suppose we want to do arithmetic with rational numbers.  We want to be able to
add, subtract, multiply, and divide them and to test whether two rational
numbers are equal.
</p>
<p>Let us begin by assuming that we already have a way of constructing a rational
number from a numerator and a denominator.  We also assume that, given a
rational number, we have a way of extracting (or selecting) its numerator and
its denominator.  Let us further assume that the constructor and selectors are
available as procedures:
</p>
<ul class="itemize mark-bullet">
<li><code class="code">Rational::new(⟨<var class="var">n</var>⟩, ⟨<var class="var">d</var>⟩)</code> returns the rational number whose numerator
is the integer <code class="code">⟨<var class="var">n</var>⟩</code> and whose denominator is the integer
<code class="code">⟨<var class="var">d</var>⟩</code>.

</li><li><code class="code">⟨<var class="var">x</var>⟩.num()</code> returns the numerator of the rational number
<code class="code">⟨<var class="var">x</var>⟩</code>.

</li><li><code class="code">⟨<var class="var">x</var>⟩.denom()</code> returns the denominator of the rational number
<code class="code">⟨<var class="var">x</var>⟩</code>.

</li></ul>

<p>We are using here a powerful strategy of synthesis: <a class="index-entry-id" id="index-wishful-thinking"></a>
<em class="dfn">wishful thinking</em>.
We haven&#8217;t yet said how a rational number is represented, or how the methods
<code class="code">num</code>, <code class="code">denom</code>, and <code class="code">new</code> should be implemented.  Even
so, if we did have these three methods, we could then add, subtract,
multiply, divide, and test equality by using the following relations:
\[ % :30:
 
\begin{eqnarray}
{n_1 \over d_1} + {n_2 \over d_2}       &amp;=&amp; {n_1 d_2 + n_2 d_1 \over d_1 d_2}, \\
{n_1 \over d_1} - {n_2 \over d_2} 	&amp;=&amp; {n_1 d_2 - n_2 d_1 \over d_1 d_2}, \\
{n_1 \over d_1} \times {n_2 \over d_2} 	&amp;=&amp; {n_1 n_2 \over d_1 d_2}, \\
{n_1 \,/\, d_1} \over {n_2 \,/\, d_2} 	&amp;=&amp; {n_1 d_2 \over d_1 n_2}, \\
{n_1 \over d_1} 			&amp;=&amp; {n_2 \over d_2} \quad
						{\rm\ if\ and\ only\ if\quad} 
						n_1 d_2 = n_2 d_1. 
\end{eqnarray}
\]
We can express these rules as functions:
</p>
<div class="example">
<pre class="example-preformatted">fn add_rat(x: &amp;Rational, y: &amp;Rational) -&gt; Rational {
    Rational::new(
        x.num() * y.denom() + y.num() * x.denom(),
        x.denom() * y.denom()
    )
}

fn sub_rat(x: &amp;Rational, y: &amp;Rational) -&gt; Rational {
    Rational::new(
        x.num() * y.denom() - y.num() * x.denom(),
        x.denom() * y.denom()
    )
}

fn mul_rat(x: &amp;Rational, y: &amp;Rational) -&gt; Rational {
    Rational::new(
        x.num() * y.num(),
        x.denom() * y.denom()
    )
}

fn div_rat(x: &amp;Rational, y: &amp;Rational) -&gt; Rational {
    Rational::new(
        x.num() * y.denom(),
        x.denom() * y.num()
    )
}

fn equal_rat(x: &amp;Rational, y: &amp;Rational) -&gt; bool {
    x.num() * y.denom() == y.num() * x.denom()
}
</pre></div>

<p>Now we have the operations on rational numbers defined in terms of the selector
and constructor methods <code class="code">num</code>, <code class="code">denom</code>, and <code class="code">new</code>.
But we haven&#8217;t yet defined these.  What we need is some way to glue together a
numerator and a denominator to form a rational number.
</p>
<h4 class="subsubheading" id="Pairs"><span>Pairs<a class="copiable-link" href="#Pairs"> &#182;</a></span></h4>

<p>To enable us to implement the concrete level of our data abstraction, Rust
provides a compound structure called a <a class="index-entry-id" id="index-tuple"></a>
<em class="dfn">tuple</em>, which can be
constructed using parentheses with comma-separated values.  A tuple takes two
(or more) values and returns a compound data object that contains those values as
parts.  Given a pair (2-tuple), we can extract the parts using pattern matching
or field access with <code class="code">.0</code> and <code class="code">.1</code>.<a class="footnote" id="DOCF63" href="#FOOT63"><sup>63</sup></a> Thus, we can use tuples as follows:
</p>
<div class="example">
<pre class="example-preformatted">let x = (1, 2);

x.0
// 1

x.1
// 2
</pre></div>

<p>Notice that a pair is a data object that can be given a name and manipulated,
just like a primitive data object.  Moreover, tuples can be used to form
pairs whose elements are pairs, and so on:
</p>
<div class="example">
<pre class="example-preformatted">let x = (1, 2);
let y = (3, 4);
let z = (x, y);

z.0.0
// 1

z.1.0
// 3
</pre></div>

<p>In <a class="ref" href="2_002e2.xhtml#g_t2_002e2">Hierarchical Data and the Closure Property</a> we will see how this ability to combine pairs means that
tuples and structs can be used as general-purpose building blocks to create all sorts of
complex data structures.  The compound-data primitives <a class="index-entry-id" id="index-tuples"></a>
<em class="dfn">tuples</em> and
<a class="index-entry-id" id="index-structs"></a>
<em class="dfn">structs</em> are the primary tools we need.  Data objects constructed from these
are the foundation of Rust&#8217;s type system and can represent
<a class="index-entry-id" id="index-list_002dstructured"></a>
<em class="dfn">list-structured</em> data.
</p>
<h4 class="subsubheading" id="Representing-rational-numbers"><span>Representing rational numbers<a class="copiable-link" href="#Representing-rational-numbers"> &#182;</a></span></h4>

<p>A struct offers a natural way to complete the rational-number system.  Simply
represent a rational number as a struct with two integer fields: a numerator and a
denominator.  Then <code class="code">Rational::new</code>, <code class="code">num</code>, and <code class="code">denom</code> are readily
implemented as follows:<a class="footnote" id="DOCF64" href="#FOOT64"><sup>64</sup></a>
</p>
<div class="example">
<pre class="example-preformatted">struct Rational {
    num: i64,
    denom: i64,
}

impl Rational {
    fn new(n: i64, d: i64) -&gt; Self {
        Rational { num: n, denom: d }
    }

    fn num(&amp;self) -&gt; i64 {
        self.num
    }

    fn denom(&amp;self) -&gt; i64 {
        self.denom
    }
}
</pre></div>

<p>Also, in order to display the results of our computations, we can print
rational numbers by printing the numerator, a slash, and the
denominator:<a class="footnote" id="DOCF65" href="#FOOT65"><sup>65</sup></a>
</p>
<div class="example">
<pre class="example-preformatted">use std::fmt;

impl fmt::Display for Rational {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;{}/{}&quot;, self.num, self.denom)
    }
}
</pre></div>

<p>Now we can try our rational-number functions:
</p>
<div class="example">
<pre class="example-preformatted">let one_half = Rational::new(1, 2);
println!(&quot;{}&quot;, one_half);
// 1/2

let one_third = Rational::new(1, 3);
println!(&quot;{}&quot;, add_rat(&amp;one_half, &amp;one_third));
// 5/6

println!(&quot;{}&quot;, mul_rat(&amp;one_half, &amp;one_third));
// 1/6

println!(&quot;{}&quot;, add_rat(&amp;one_third, &amp;one_third));
// 6/9
</pre></div>

<p>As the final example shows, our rational-number implementation does not reduce
rational numbers to lowest terms.  We can remedy this by changing
<code class="code">new</code>. If we have a <code class="code">gcd</code> function like the one in
<a class="ref" href="1_002e2.xhtml#g_t1_002e2_002e5">Greatest Common Divisors</a> that produces the greatest common divisor of two integers, we can
use <code class="code">gcd</code> to reduce the numerator and the denominator to lowest terms
before constructing the value:
</p>
<div class="example">
<pre class="example-preformatted">fn gcd(a: i64, b: i64) -&gt; i64 {
    if b == 0 {
        a.abs()
    } else {
        gcd(b, a % b)
    }
}

impl Rational {
    fn new(n: i64, d: i64) -&gt; Self {
        let g = gcd(n, d);
        Rational {
            num: n / g,
            denom: d / g,
        }
    }
    // ... other methods ...
}
</pre></div>

<p>Now we have
</p>
<div class="example">
<pre class="example-preformatted">println!(&quot;{}&quot;, add_rat(&amp;one_third, &amp;one_third));
// 2/3
</pre></div>

<p>as desired.  This modification was accomplished by changing the constructor
<code class="code">new</code> without changing any of the functions (such as <code class="code">add_rat</code>
and <code class="code">mul_rat</code>) that implement the actual operations.
</p>
<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-2_002e1"></a>Exercise 2.1:</strong> Define a better version of
<code class="code">Rational::new</code> that handles both positive and negative arguments.
<code class="code">new</code> should normalize the sign so that if the rational number is
positive, both the numerator and denominator are positive, and if the rational
number is negative, only the numerator is negative.
</p></blockquote>

<hr />
</div>
<div class="subsection-level-extent" id="g_t2_002e1_002e2">
<h4 class="subsection" id="Abstraction-Barriers"><span>2.1.2 Abstraction Barriers<a class="copiable-link" href="#Abstraction-Barriers"> &#182;</a></span></h4>

<p>Before continuing with more examples of compound data and data abstraction, let
us consider some of the issues raised by the rational-number example.  We
defined the rational-number operations in terms of a constructor
<code class="code">Rational::new</code> and methods <code class="code">num</code> and <code class="code">denom</code>.  In general, the
underlying idea of data abstraction is to identify for each type of data object
a basic set of operations in terms of which all manipulations of data objects
of that type will be expressed, and then to use only those operations in
manipulating the data.
</p>
<p>We can envision the structure of the rational-number system as shown in
<a class="ref" href="#Figure-2_002e1">Figure 2.1</a>.  The horizontal lines represent <a class="index-entry-id" id="index-abstraction-barriers-1"></a>
<em class="dfn">abstraction barriers</em>
that isolate different &#8220;levels&#8221; of the system.  At each level, the
barrier separates the programs (above) that use the data abstraction from the
programs (below) that implement the data abstraction.  Programs that use
rational numbers manipulate them solely in terms of the functions supplied
&#8220;for public use&#8221; by the rational-number module: <code class="code">add_rat</code>,
<code class="code">sub_rat</code>, <code class="code">mul_rat</code>, <code class="code">div_rat</code>, and <code class="code">equal_rat</code>. These,
in turn, are implemented solely in terms of the constructor and methods
<code class="code">Rational::new</code>, <code class="code">num</code>, and <code class="code">denom</code>, which themselves are
implemented using struct fields.  The details of how the struct is implemented are
irrelevant to the rest of the rational-number module so long as the struct can be
manipulated through its public interface.  In effect,
functions and methods at each level are the interfaces that define the abstraction
barriers and connect the different levels.
</p>
<div class="float">
<a class="anchor" id="Figure-2_002e1"></a><img class="image" src="fig/chap2/Fig2.1d.std.svg" alt="fig/chap2/Fig2.1d" />
<div class="caption"><p><strong class="strong">Figure 2.1:</strong> Data-abstraction barriers in the rational-number package.</p></div></div>
<p>This simple idea has many advantages.  One advantage is that it makes programs
much easier to maintain and to modify.  Any complex data structure can be
represented in a variety of ways with the primitive data structures provided by
a programming language.  Of course, the choice of representation influences the
programs that operate on it; thus, if the representation were to be changed at
some later time, all such programs might have to be modified accordingly.  This
task could be time-consuming and expensive in the case of large programs unless
the dependence on the representation were to be confined by design to a very
few program modules.
</p>
<p>For example, an alternate way to address the problem of reducing rational
numbers to lowest terms is to perform the reduction whenever we access the
parts of a rational number, rather than when we construct it.  This leads to
different constructor and accessor methods:
</p>
<div class="example">
<pre class="example-preformatted">impl Rational {
    fn new(n: i64, d: i64) -&gt; Self {
        Rational { num: n, denom: d }
    }

    fn num(&amp;self) -&gt; i64 {
        let g = gcd(self.num, self.denom);
        self.num / g
    }

    fn denom(&amp;self) -&gt; i64 {
        let g = gcd(self.num, self.denom);
        self.denom / g
    }
}
</pre></div>

<p>The difference between this implementation and the previous one lies in when we
compute the <code class="code">gcd</code>.  If in our typical use of rational numbers we access
the numerators and denominators of the same rational numbers many times, it
would be preferable to compute the <code class="code">gcd</code> when the rational numbers are
constructed.  If not, we may be better off waiting until access time to compute
the <code class="code">gcd</code>.  In any case, when we change from one representation to the
other, the functions <code class="code">add_rat</code>, <code class="code">sub_rat</code>, and so on do not have to
be modified at all.
</p>
<p>Constraining the dependence on the representation to a few interface procedures
helps us design programs as well as modify them, because it allows us to
maintain the flexibility to consider alternate implementations.  To continue
with our simple example, suppose we are designing a rational-number package and
we can&#8217;t decide initially whether to perform the <code class="code">gcd</code> at construction
time or at selection time.  The data-abstraction methodology gives us a way to
defer that decision without losing the ability to make progress on the rest of
the system.
</p>
<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-2_002e2"></a>Exercise 2.2:</strong> Consider the problem of
representing line segments in a plane.  Each segment is represented as a pair
of points: a starting point and an ending point.  Define a <code class="code">Segment</code> struct
and methods <code class="code">start</code> and <code class="code">end</code>
that define the representation of segments in terms of points.  Furthermore, a
point can be represented as a pair of numbers: the <em class="math">x</em> coordinate and the
<em class="math">y</em> coordinate.  Accordingly, define a <code class="code">Point</code> struct with fields
<code class="code">x</code> and <code class="code">y</code> that define this representation.
Finally, using your structs and methods, define a function
<code class="code">midpoint_segment</code> that takes a line segment as argument and returns its
midpoint (the point whose coordinates are the average of the coordinates of the
endpoints).  To try your implementation, you&#8217;ll need a way to print points:
</p>
<div class="example">
<pre class="example-preformatted">use std::fmt;

impl fmt::Display for Point {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;({}, {})&quot;, self.x, self.y)
    }
}
</pre></div>
</blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-2_002e3"></a>Exercise 2.3:</strong> Implement a representation for
rectangles in a plane.  (Hint: You may want to make use of <a class="ref" href="#Exercise-2_002e2">Exercise 2.2</a>.)
In terms of your struct and methods, create functions that compute the
perimeter and the area of a given rectangle.  Now implement a different
representation for rectangles (perhaps using a trait).  Can you design your system with suitable
abstraction barriers, so that the same perimeter and area functions will work
with either representation?
</p></blockquote>

<hr />
</div>
<div class="subsection-level-extent" id="g_t2_002e1_002e3">
<h4 class="subsection" id="What-Is-Meant-by-Data_003f"><span>2.1.3 What Is Meant by Data?<a class="copiable-link" href="#What-Is-Meant-by-Data_003f"> &#182;</a></span></h4>

<p>We began the rational-number implementation in <a class="ref" href="#g_t2_002e1_002e1">Example: Arithmetic Operations for Rational Numbers</a> by
implementing the rational-number operations <code class="code">add_rat</code>, <code class="code">sub_rat</code>, and
so on in terms of three unspecified functions: <code class="code">Rational::new</code>, <code class="code">num</code>,
and <code class="code">denom</code>.  At that point, we could think of the operations as being
defined in terms of data objects&#8212;numerators, denominators, and rational
numbers&#8212;whose behavior was specified by the latter three functions.
</p>
<p>But exactly what is meant by <a class="index-entry-id" id="index-data-1"></a>
<em class="dfn">data</em>?  It is not enough to say
&#8220;whatever is implemented by the given methods and constructors.&#8221;  Clearly,
not every arbitrary set of three functions can serve as an appropriate basis
for the rational-number implementation.  We need to guarantee that, if we
construct a rational number <code class="code">x</code> from a pair of integers <code class="code">n</code> and
<code class="code">d</code>, then extracting the <code class="code">num</code> and the <code class="code">denom</code> of <code class="code">x</code> and
dividing them should yield the same result as dividing <code class="code">n</code> by <code class="code">d</code>.
In other words, <code class="code">Rational::new</code>, <code class="code">num</code>, and <code class="code">denom</code> must satisfy
the condition that, for any integer <code class="code">n</code> and any non-zero integer <code class="code">d</code>,
if <code class="code">x</code> is <code class="code">Rational::new(n, d)</code>, then
\[ % :31:
  {\text{x.num()} \over \text{x.denom()}} = {{\text{n} \over \text{d}}.}   \]
In fact, this is the only condition <code class="code">Rational::new</code>, <code class="code">num</code>, and
<code class="code">denom</code> must fulfill in order to form a suitable basis for a
rational-number representation.  In general, we can think of data as defined by
some collection of methods and constructors, together with specified
conditions that these functions must fulfill in order to be a valid
representation.<a class="footnote" id="DOCF66" href="#FOOT66"><sup>66</sup></a>
</p>
<p>This point of view can serve to define not only &#8220;high-level&#8221; data objects,
such as rational numbers, but lower-level objects as well.  Consider the notion
of a pair, which we used in order to define our rational numbers.  We never
actually said what a pair was, only that Rust provides tuples and structs
for operating on pairs.  But the only
thing we need to know about pairs is that if we glue two
objects together we can retrieve the objects later.  That is, the operations satisfy the condition that, for any
objects <code class="code">x</code> and <code class="code">y</code>, if <code class="code">z</code> is <code class="code">(x, y)</code> then <code class="code">z.0</code>
is <code class="code">x</code> and <code class="code">z.1</code> is <code class="code">y</code>.  Indeed, tuples are primitives in Rust.  However,
any implementation that satisfies the above condition can be used as the
basis for implementing pairs.  This point is illustrated strikingly by the fact
that we could implement pair operations without using
any data structures at all but only using closures.  Here are the
definitions:
</p>
<div class="example">
<pre class="example-preformatted">fn cons&lt;T: 'static, U: 'static&gt;(x: T, y: U) -&gt; Box&lt;dyn Fn(i32) -&gt; Box&lt;dyn std::any::Any&gt;&gt; {
    Box::new(move |m| {
        match m {
            0 =&gt; Box::new(x.clone()) as Box&lt;dyn std::any::Any&gt;,
            1 =&gt; Box::new(y.clone()) as Box&lt;dyn std::any::Any&gt;,
            _ =&gt; panic!(&quot;Argument not 0 or 1: CONS&quot;),
        }
    })
}

fn car&lt;T: 'static&gt;(z: &amp;dyn Fn(i32) -&gt; Box&lt;dyn std::any::Any&gt;) -&gt; T
where
    T: Clone + 'static,
{
    *z(0).downcast::&lt;T&gt;().unwrap()
}

fn cdr&lt;U: 'static&gt;(z: &amp;dyn Fn(i32) -&gt; Box&lt;dyn std::any::Any&gt;) -&gt; U
where
    U: Clone + 'static,
{
    *z(1).downcast::&lt;U&gt;().unwrap()
}
</pre></div>

<p>This use of closures corresponds to nothing like our intuitive notion of what
data should be.  Nevertheless, all we need to do to show that this is a valid
way to represent pairs is to verify that these functions satisfy the condition
given above.
</p>
<p>The subtle point to notice is that the value returned by <code class="code">cons(x, y)</code> is a
closure&#8212;namely a function that captures <code class="code">x</code> and <code class="code">y</code>, which
takes one argument and returns either <code class="code">x</code> or <code class="code">y</code> depending on whether
the argument is 0 or 1.  Correspondingly, <code class="code">car(z)</code> is defined to apply
<code class="code">z</code> to 0.  Hence, if <code class="code">z</code> is the closure formed by <code class="code">cons(x,
y)</code>, then <code class="code">z</code> applied to 0 will yield <code class="code">x</code>. Thus, we have shown that
<code class="code">car(cons(x, y))</code> yields <code class="code">x</code>, as desired.  Similarly, <code class="code">cdr(cons(x, y))</code> applies the closure returned by <code class="code">cons(x, y)</code> to 1, which
returns <code class="code">y</code>.  Therefore, this procedural implementation of pairs is a
valid implementation, and if we access pairs using only <code class="code">cons</code>,
<code class="code">car</code>, and <code class="code">cdr</code> we cannot distinguish this implementation from one
that uses tuples or structs.
</p>
<p>The point of exhibiting the procedural representation of pairs is not that Rust
works this way (Rust implements tuples and structs
directly, for efficiency and type safety reasons) but that it could work this way.  The
procedural representation, although obscure and requiring dynamic typing, is a perfectly adequate way to
represent pairs, since it fulfills the only conditions that pairs need to
fulfill.  This example also demonstrates that the ability to manipulate
closures as values automatically provides the ability to represent compound
data.  This may seem a curiosity now, but procedural representations of data
will play a central role in our programming repertoire.  This style of
programming is often called <a class="index-entry-id" id="index-message-passing"></a>
<em class="dfn">message passing</em>, and we will be using it
as a basic tool in <a class="ref" href="Chapter-3.xhtml">Modularity, Objects, and State</a> when we address the issues of modeling and
simulation.
</p>
<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-2_002e4"></a>Exercise 2.4:</strong> Here is an alternative procedural
representation of pairs using closures.  For this representation, verify that <code class="code">car(cons(x, y))</code> yields <code class="code">x</code> for any objects <code class="code">x</code> and <code class="code">y</code>.
</p>
<div class="example">
<pre class="example-preformatted">// Simplified version using generics and closures
type Pair&lt;T&gt; = Box&lt;dyn Fn(Box&lt;dyn Fn(T, T) -&gt; T&gt;) -&gt; T&gt;;

fn cons&lt;T: Clone + 'static&gt;(x: T, y: T) -&gt; Pair&lt;T&gt; {
    Box::new(move |m| m(x.clone(), y.clone()))
}

fn car&lt;T: Clone + 'static&gt;(z: &amp;Pair&lt;T&gt;) -&gt; T {
    z(Box::new(|p, _q| p))
}
</pre></div>

<p>What is the corresponding definition of <code class="code">cdr</code>? (Hint: To verify that this
works, make use of the substitution model of <a class="ref" href="1_002e1.xhtml#g_t1_002e1_002e5">The Substitution Model for Procedure Application</a>.)
</p></blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-2_002e5"></a>Exercise 2.5:</strong> Show that we can represent pairs of
nonnegative integers using only numbers and arithmetic operations if we
represent the pair <em class="math">a</em> and <em class="math">b</em> as the integer that is the product <em class="math">{2^a 3^b}</em>.
Give the corresponding definitions of the procedures <code class="code">cons</code>,
<code class="code">car</code>, and <code class="code">cdr</code>.
</p></blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-2_002e6"></a>Exercise 2.6:</strong> In case representing pairs as
closures wasn&#8217;t mind-boggling enough, consider that, in a language that can
manipulate closures, we can get by without numbers (at least insofar as
nonnegative integers are concerned) by implementing 0 and the operation of
adding 1 as
</p>
<div class="example">
<pre class="example-preformatted">// Church numerals in Rust (simplified)
type ChurchNum&lt;T&gt; = Box&lt;dyn Fn(Box&lt;dyn Fn(T) -&gt; T&gt;) -&gt; Box&lt;dyn Fn(T) -&gt; T&gt;&gt;;

fn zero&lt;T: 'static&gt;() -&gt; ChurchNum&lt;T&gt; {
    Box::new(|_f| Box::new(|x| x))
}

fn add_1&lt;T: 'static&gt;(n: ChurchNum&lt;T&gt;) -&gt; ChurchNum&lt;T&gt; {
    Box::new(move |f| {
        let nf = n(f.clone());
        Box::new(move |x| f(nf(x)))
    })
}
</pre></div>

<p>This representation is known as <a class="index-entry-id" id="index-Church-numerals"></a>
<em class="dfn">Church numerals</em>, after its inventor,
Alonzo Church, the logician who invented the λ-calculus.
</p>
<p>Define <code class="code">one</code> and <code class="code">two</code> directly (not in terms of <code class="code">zero</code> and
<code class="code">add_1</code>).  (Hint: Use substitution to evaluate <code class="code">add_1(zero())</code>).  Give
a direct definition of the addition function <code class="code">add</code> (not in terms of
repeated application of <code class="code">add_1</code>).
</p></blockquote>

<hr />
</div>
<div class="subsection-level-extent" id="g_t2_002e1_002e4">
<h4 class="subsection" id="Extended-Exercise_003a-Interval-Arithmetic"><span>2.1.4 Extended Exercise: Interval Arithmetic<a class="copiable-link" href="#Extended-Exercise_003a-Interval-Arithmetic"> &#182;</a></span></h4>

<p>Alyssa P. Hacker is designing a system to help people solve engineering
problems.  One feature she wants to provide in her system is the ability to
manipulate inexact quantities (such as measured parameters of physical devices)
with known precision, so that when computations are done with such approximate
quantities the results will be numbers of known precision.
</p>
<p>Electrical engineers will be using Alyssa&#8217;s system to compute electrical
quantities.  It is sometimes necessary for them to compute the value of a
parallel equivalent resistance <em class="math">R_p</em> of two resistors <em class="math">R_1</em> and <em class="math">R_2</em>
using the formula
\[ % :32:
  R_p \,=\, {{1 \over 1 / R_1 + 1 / R_2}.}   \]
Resistance values are usually known only up to some tolerance guaranteed by the
manufacturer of the resistor.  For example, if you buy a resistor labeled &#8220;6.8
ohms with 10% tolerance&#8221; you can only be sure that the resistor has a
resistance between 6.8 <em class="math">-</em> 0.68 = 6.12 and 6.8 + 0.68 = 7.48 ohms.  Thus, if you
have a 6.8-ohm 10% resistor in parallel with a 4.7-ohm 5% resistor, the
resistance of the combination can range from about 2.58 ohms (if the two
resistors are at the lower bounds) to about 2.97 ohms (if the two resistors are
at the upper bounds).
</p>
<p>Alyssa&#8217;s idea is to implement &#8220;interval arithmetic&#8221; as a set of arithmetic
operations for combining &#8220;intervals&#8221; (objects that represent the range of
possible values of an inexact quantity).  The result of adding, subtracting,
multiplying, or dividing two intervals is itself an interval, representing the
range of the result.
</p>
<p>Alyssa postulates the existence of an abstract object called an &#8220;interval&#8221;
that has two endpoints: a lower bound and an upper bound.  She also presumes
that, given the endpoints of an interval, she can construct the interval using
the data constructor <code class="code">Interval::new</code>.  Alyssa first writes a procedure for
adding two intervals.  She reasons that the minimum value the sum could be is
the sum of the two lower bounds and the maximum value it could be is the sum of
the two upper bounds:
</p>
<div class="example">
<pre class="example-preformatted">fn add_interval(x: &amp;Interval, y: &amp;Interval) -&gt; Interval {
    Interval::new(
        x.lower_bound() + y.lower_bound(),
        x.upper_bound() + y.upper_bound()
    )
}
</pre></div>

<p>Alyssa also works out the product of two intervals by finding the minimum and
the maximum of the products of the bounds and using them as the bounds of the
resulting interval.  (<code class="code">Min</code> and <code class="code">max</code> are primitives that find the
minimum or maximum of any number of arguments.)
</p>
<div class="example">
<pre class="example-preformatted">fn mul_interval(x: &amp;Interval, y: &amp;Interval) -&gt; Interval {
    let p1 = x.lower_bound() * y.lower_bound();
    let p2 = x.lower_bound() * y.upper_bound();
    let p3 = x.upper_bound() * y.lower_bound();
    let p4 = x.upper_bound() * y.upper_bound();
    Interval::new(
        p1.min(p2).min(p3).min(p4),
        p1.max(p2).max(p3).max(p4)
    )
}
</pre></div>

<p>To divide two intervals, Alyssa multiplies the first by the reciprocal of the
second.  Note that the bounds of the reciprocal interval are the reciprocal of
the upper bound and the reciprocal of the lower bound, in that order.
</p>
<div class="example">
<pre class="example-preformatted">fn div_interval(x: &amp;Interval, y: &amp;Interval) -&gt; Interval {
    mul_interval(
        x,
        &amp;Interval::new(
            1.0 / y.upper_bound(),
            1.0 / y.lower_bound()
        )
    )
}
</pre></div>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-2_002e7"></a>Exercise 2.7:</strong> Alyssa&#8217;s program is incomplete
because she has not specified the implementation of the interval abstraction.
Here is a definition of the interval constructor:
</p>
<div class="example">
<pre class="example-preformatted">struct Interval {
    lower: f64,
    upper: f64,
}

impl Interval {
    fn new(a: f64, b: f64) -&gt; Self {
        Interval { lower: a, upper: b }
    }
}
</pre></div>

<p>Define selectors <code class="code">upper_bound</code> and <code class="code">lower_bound</code> to complete the
implementation.
</p></blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-2_002e8"></a>Exercise 2.8:</strong> Using reasoning analogous to
Alyssa&#8217;s, describe how the difference of two intervals may be computed.  Define
a corresponding subtraction procedure, called <code class="code">sub_interval</code>.
</p></blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-2_002e9"></a>Exercise 2.9:</strong> The <a class="index-entry-id" id="index-width"></a>
<em class="dfn">width</em> of an interval
is half of the difference between its upper and lower bounds.  The width is a
measure of the uncertainty of the number specified by the interval.  For some
arithmetic operations the width of the result of combining two intervals is a
function only of the widths of the argument intervals, whereas for others the
width of the combination is not a function of the widths of the argument
intervals.  Show that the width of the sum (or difference) of two intervals is
a function only of the widths of the intervals being added (or subtracted).
Give examples to show that this is not true for multiplication or division.
</p></blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-2_002e10"></a>Exercise 2.10:</strong> Ben Bitdiddle, an expert systems
programmer, looks over Alyssa&#8217;s shoulder and comments that it is not clear what
it means to divide by an interval that spans zero.  Modify Alyssa&#8217;s code to
check for this condition and to signal an error if it occurs.
</p></blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-2_002e11"></a>Exercise 2.11:</strong> In passing, Ben also cryptically
comments: &#8220;By testing the signs of the endpoints of the intervals, it is
possible to break <code class="code">mul_interval</code> into nine cases, only one of which
requires more than two multiplications.&#8221;  Rewrite this procedure using Ben&#8217;s
suggestion.
</p>
<p>After debugging her program, Alyssa shows it to a potential user, who complains
that her program solves the wrong problem.  He wants a program that can deal
with numbers represented as a center value and an additive tolerance; for
example, he wants to work with intervals such as 3.5 <em class="math">\pm</em> 0.15 rather than
[3.35, 3.65].  Alyssa returns to her desk and fixes this problem by supplying
an alternate constructor and alternate selectors:
</p>
<div class="example">
<pre class="example-preformatted">impl Interval {
    fn from_center_width(c: f64, w: f64) -&gt; Self {
        Interval::new(c - w, c + w)
    }

    fn center(&amp;self) -&gt; f64 {
        (self.lower_bound() + self.upper_bound()) / 2.0
    }

    fn width(&amp;self) -&gt; f64 {
        (self.upper_bound() - self.lower_bound()) / 2.0
    }
}
</pre></div>

<p>Unfortunately, most of Alyssa&#8217;s users are engineers.  Real engineering
situations usually involve measurements with only a small uncertainty, measured
as the ratio of the width of the interval to the midpoint of the interval.
Engineers usually specify percentage tolerances on the parameters of devices,
as in the resistor specifications given earlier.
</p></blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-2_002e12"></a>Exercise 2.12:</strong> Define a constructor
<code class="code">make-center-percent</code> that takes a center and a percentage tolerance and
produces the desired interval.  You must also define a selector <code class="code">percent</code>
that produces the percentage tolerance for a given interval.  The <code class="code">center</code>
selector is the same as the one shown above.
</p></blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-2_002e13"></a>Exercise 2.13:</strong> Show that under the assumption of
small percentage tolerances there is a simple formula for the approximate
percentage tolerance of the product of two intervals in terms of the tolerances
of the factors.  You may simplify the problem by assuming that all numbers are
positive.
</p>
<p>After considerable work, Alyssa P. Hacker delivers her finished system.
Several years later, after she has forgotten all about it, she gets a frenzied
call from an irate user, Lem E. Tweakit.  It seems that Lem has noticed that
the formula for parallel resistors can be written in two algebraically
equivalent ways:
\[ % :33:
  {R_1 R_2 \over R_1 + R_2}  \]
and
\[ % :34:
  {{1 \over 1 / R_1 + 1 / R_2}.}  \]
He has written the following two programs, each of which computes the
parallel-resistors formula differently:
</p>
<div class="example">
<pre class="example-preformatted">fn par1(r1: &amp;Interval, r2: &amp;Interval) -&gt; Interval {
    div_interval(
        &amp;mul_interval(r1, r2),
        &amp;add_interval(r1, r2)
    )
}

fn par2(r1: &amp;Interval, r2: &amp;Interval) -&gt; Interval {
    let one = Interval::new(1.0, 1.0);
    div_interval(
        &amp;one,
        &amp;add_interval(
            &amp;div_interval(&amp;one, r1),
            &amp;div_interval(&amp;one, r2)
        )
    )
}
</pre></div>

<p>Lem complains that Alyssa&#8217;s program gives different answers for the two ways of
computing. This is a serious complaint.
</p></blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-2_002e14"></a>Exercise 2.14:</strong> Demonstrate that Lem is right.
Investigate the behavior of the system on a variety of arithmetic
expressions. Make some intervals <em class="math">A</em> and <em class="math">B</em>, and use them in computing the
expressions <em class="math">{A / A}</em> and <em class="math">{A / B}</em>.  You will get the most insight by
using intervals whose width is a small percentage of the center value. Examine
the results of the computation in center-percent form (see <a class="ref" href="#Exercise-2_002e12">Exercise 2.12</a>).
</p></blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-2_002e15"></a>Exercise 2.15:</strong> Eva Lu Ator, another user, has
also noticed the different intervals computed by different but algebraically
equivalent expressions. She says that a formula to compute with intervals using
Alyssa&#8217;s system will produce tighter error bounds if it can be written in such
a form that no variable that represents an uncertain number is repeated.  Thus,
she says, <code class="code">par2</code> is a &#8220;better&#8221; program for parallel resistances than
<code class="code">par1</code>.  Is she right?  Why?
</p></blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-2_002e16"></a>Exercise 2.16:</strong> Explain, in general, why
equivalent algebraic expressions may lead to different answers.  Can you devise
an interval-arithmetic package that does not have this shortcoming, or is this
task impossible?  (Warning: This problem is very difficult.)
</p></blockquote>


</div>
</div>
<div class="footnotes-segment">
<hr />
<h4 class="footnotes-heading">Footnotes</h4>

<h5 class="footnote-body-heading"><a id="FOOT63" href="#DOCF63">(63)</a></h5>
<p>In Scheme and Lisp, the names <code class="code">cons</code>, <code class="code">car</code>, and <code class="code">cdr</code> derive from the original
implementation of Lisp on the IBM 704.  That machine had an addressing scheme
that allowed one to reference the &#8220;address&#8221; and &#8220;decrement&#8221; parts of a
memory location.  <code class="code">Car</code> stands for &#8220;Contents of Address part of
Register&#8221; and <code class="code">cdr</code> (pronounced &#8220;could-er&#8221;) stands for &#8220;Contents of
Decrement part of Register.&#8221; Rust uses tuples and structs instead, with numeric
field access or named fields.</p>
<h5 class="footnote-body-heading"><a id="FOOT64" href="#DOCF64">(64)</a></h5>
<p>We could also use a simple tuple <code class="code">(i64, i64)</code>
to represent rational numbers, which would be more lightweight:
</p>
<div class="example">
<pre class="example-preformatted">fn make_rat(n: i64, d: i64) -&gt; (i64, i64) { (n, d) }
fn numer(x: (i64, i64)) -&gt; i64 { x.0 }
fn denom(x: (i64, i64)) -&gt; i64 { x.1 }
</pre></div>

<p>However, using a named struct provides better type safety and clearer intent.
The Rust type system will prevent us from accidentally using a tuple representing
something else (like a point) as a rational number.  Named structs also provide
better documentation and can implement traits for custom behavior.</p>
<h5 class="footnote-body-heading"><a id="FOOT65" href="#DOCF65">(65)</a></h5>
<p>In Rust, we implement the <code class="code">Display</code> trait to provide
custom formatting for our types. The <code class="code">println!</code> macro uses this trait to
print values.  The <code class="code">Display</code> implementation does not return a useful value
(it returns <code class="code">Result&lt;(), fmt::Error&gt;</code>), so in the uses of printing
below, we show only what is printed, not what the expression evaluates to.</p>
<h5 class="footnote-body-heading"><a id="FOOT66" href="#DOCF66">(66)</a></h5>
<p>Surprisingly, this idea is very difficult to formulate
rigorously. There are two approaches to giving such a formulation.  One,
pioneered by C. A. R. <a class="ref" href="References.xhtml#Hoare-_00281972_0029">Hoare (1972)</a>, is known as the method of <a class="index-entry-id" id="index-abstract-models"></a>
<em class="dfn">abstract models</em>.  
It formalizes the &#8220;procedures plus conditions&#8221; specification as
outlined in the rational-number example above.  Note that the condition on the
rational-number representation was stated in terms of facts about integers
(equality and division).  In general, abstract models define new kinds of data
objects in terms of previously defined types of data objects.  Assertions about
data objects can therefore be checked by reducing them to assertions about
previously defined data objects.  Another approach, introduced by Zilles at
<abbr class="abbr">MIT</abbr>, by Goguen, Thatcher, Wagner, and Wright at IBM 
(see <a class="ref" href="References.xhtml#Thatcher-et-al_002e-1978">Thatcher et al. 1978</a>), 
and by Guttag at Toronto (see <a class="ref" href="References.xhtml#Guttag-1977">Guttag 1977</a>), is called
<a class="index-entry-id" id="index-algebraic-specification"></a>
<em class="dfn">algebraic specification</em>.  It regards the &#8220;procedures&#8221; as elements
of an abstract algebraic system whose behavior is specified by axioms that
correspond to our &#8220;conditions,&#8221; and uses the techniques of abstract algebra
to check assertions about data objects.  Both methods are surveyed in the paper
by <a class="ref" href="References.xhtml#Liskov-and-Zilles-_00281975_0029">Liskov and Zilles (1975)</a>.</p>
</div>
<hr />
<div class="nav-panel">
<p>
Next: <a href="2_002e2.xhtml#g_t2_002e2" accesskey="n" rel="next">Hierarchical Data and the Closure Property</a>, Previous: <a href="Chapter-2.xhtml" accesskey="p" rel="prev">Building Abstractions with Data</a>, Up: <a href="Chapter-2.xhtml" accesskey="u" rel="up">Building Abstractions with Data</a> &#160; [<a href="index.xhtml#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Term-Index.xhtml" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
