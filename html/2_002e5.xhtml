<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<!-- Created by GNU Texinfo 7.1, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>2.5 (Structure and Interpretation of Computer Programs, 2e)</title>

<meta name="description" content="2.5 (Structure and Interpretation of Computer Programs, 2e)" />
<meta name="keywords" content="2.5 (Structure and Interpretation of Computer Programs, 2e)" />
<meta name="resource-type" content="document" />
<meta name="distribution" content="global" />
<meta name="Generator" content="texi2any" />
<meta name="viewport" content="width=device-width,initial-scale=1" />

<link href="index.xhtml" rel="start" title="Top" />
<link href="Term-Index.xhtml" rel="index" title="Term Index" />
<link href="index.xhtml#SEC_Contents" rel="contents" title="Table of Contents" />
<link href="Chapter-2.xhtml" rel="up" title="Chapter 2" />
<link href="Chapter-3.xhtml" rel="next" title="Chapter 3" />
<link href="2_002e4.xhtml#g_t2_002e4_002e3a" rel="prev" title="2.4.3a" />
<style type="text/css">
<!--
a.copiable-link {visibility: hidden; text-decoration: none; line-height: 0em}
div.example {margin-left: 3.2em}
span:hover a.copiable-link {visibility: visible}
ul.mark-bullet {list-style-type: disc}
-->
</style>
<link href="css/style.css" rel="stylesheet" type="text/css" />
<link href="css/prettify.css" rel="stylesheet" type="text/css" />
<script src="js/highlight/prettify.js" type="text/javascript"></script>
<script src="js/highlight/lang-lisp.js" type="text/javascript"></script>
<script src="js/highlight/lang-rust.js" type="text/javascript"></script>
</head>

<body lang="en">
<div class="section-level-extent" id="g_t2_002e5">
<div class="nav-panel">
<p>
Next: <a href="Chapter-3.xhtml" accesskey="n" rel="next">Modularity, Objects, and State</a>, Previous: <a href="2_002e4.xhtml#g_t2_002e4_002e3a" accesskey="p" rel="prev">Traits as Interfaces: Static and Dynamic Dispatch</a>, Up: <a href="Chapter-2.xhtml" accesskey="u" rel="up">Building Abstractions with Data</a> &#160; [<a href="index.xhtml#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Term-Index.xhtml" title="Index" rel="index">Index</a>]</p>
</div>
<h3 class="section" id="Systems-with-Generic-Operations"><span>2.5 Systems with Generic Operations<a class="copiable-link" href="#Systems-with-Generic-Operations"> &#182;</a></span></h3>

<p>In the previous section, we saw how to design systems in which data objects can
be represented in more than one way.  The key idea is to link the code that
specifies the data operations to the several representations by means of
generic interface procedures.  Now we will see how to use this same idea not
only to define operations that are generic over different representations but
also to define operations that are generic over different kinds of arguments.
We have already seen several different packages of arithmetic operations: the
primitive arithmetic (<code class="code">+</code>, <code class="code">-</code>, <code class="code">*</code>, <code class="code">/</code>) built into our
language, the rational-number arithmetic (<code class="code">add_rat</code>, <code class="code">sub_rat</code>,
<code class="code">mul-rat</code>, <code class="code">div_rat</code>) of <a class="ref" href="2_002e1.xhtml#g_t2_002e1_002e1">Example: Arithmetic Operations for Rational Numbers</a>, and the complex-number
arithmetic that we implemented in <a class="ref" href="2_002e4.xhtml#g_t2_002e4_002e3">Data-Directed Programming and Additivity</a>.  We will now use
data-directed techniques to construct a package of arithmetic operations that
incorporates all the arithmetic packages we have already constructed.
</p>
<p><a class="ref" href="#Figure-2_002e23">Figure 2.23</a> shows the structure of the system we shall build.  Notice the
abstraction barriers.  From the perspective of someone using &#8220;numbers,&#8221; there
is a single procedure <code class="code">add</code> that operates on whatever numbers are
supplied.  <code class="code">Add</code> is part of a generic interface that allows the separate
ordinary-arithmetic, rational-arithmetic, and complex-arithmetic packages to be
accessed uniformly by programs that use numbers.  Any individual arithmetic
package (such as the complex package) may itself be accessed through generic
procedures (such as <code class="code">add_complex</code>) that combine packages designed for
different representations (such as rectangular and polar).  Moreover, the
structure of the system is additive, so that one can design the individual
arithmetic packages separately and combine them to produce a generic arithmetic
system.
</p>
<div class="float">
<a class="anchor" id="Figure-2_002e23"></a><img class="image" src="fig/chap2/Fig2.23b.std.svg" alt="fig/chap2/Fig2.23b" />
<div class="caption"><p><strong class="strong">Figure 2.23:</strong> Generic arithmetic system.</p></div></div>

<hr />
<div class="subsection-level-extent" id="g_t2_002e5_002e1">
<h4 class="subsection" id="Generic-Arithmetic-Operations"><span>2.5.1 Generic Arithmetic Operations<a class="copiable-link" href="#Generic-Arithmetic-Operations"> &#182;</a></span></h4>

<p>The task of designing generic arithmetic operations is analogous to that of
designing the generic complex-number operations.  We would like, for instance,
to have a generic addition procedure <code class="code">add</code> that acts like ordinary
primitive addition <code class="code">+</code> on ordinary numbers, like <code class="code">add_rat</code> on
rational numbers, and like <code class="code">add_complex</code> on complex numbers.  We can
implement <code class="code">add</code>, and the other generic arithmetic operations, by following
the same strategy we used in <a class="ref" href="2_002e4.xhtml#g_t2_002e4_002e3">Data-Directed Programming and Additivity</a> to implement the generic
selectors for complex numbers.  We will attach a type tag to each kind of
number and cause the generic procedure to dispatch to an appropriate package
according to the data type of its arguments.
</p>
<p>The generic arithmetic procedures are defined as follows:
</p>
<div class="example">
<pre class="example-preformatted">// In Rust, generic operations use trait dispatch instead of apply-generic
// The Add, Sub, Mul, Div traits provide operator overloading

impl Add for Number {
    type Output = Number;
    fn add(self, other: Number) -&gt; Number {
        match (self, other) {
            (Number::SchemeNumber(a), Number::SchemeNumber(b)) =&gt;
                Number::SchemeNumber(a + b),
            (Number::Rational(a), Number::Rational(b)) =&gt;
                Number::Rational(a + b),
            (Number::Complex(a), Number::Complex(b)) =&gt;
                Number::Complex(a + b),
            // Mixed types use coercion (see section 2.5.2)
            (a, b) =&gt; {
                let (a_c, b_c) = coerce_to_common(a, b);
                a_c + b_c
            }
        }
    }
}
// Similar implementations for Sub, Mul, Div
</pre></div>

<p>We begin by installing a package for handling <a class="index-entry-id" id="index-ordinary"></a>
<em class="dfn">ordinary</em> numbers, that
is, the primitive numbers of our language.  We will tag these with the symbol
<code class="code">SchemeNumber</code>.  The arithmetic operations in this package are the
primitive arithmetic procedures (so there is no need to define extra procedures
to handle the untagged numbers).  Since these operations each take two
arguments, they are installed in the table keyed by the list
<code class="code">(scheme-number scheme-number)</code>:
</p>
<div class="example">
<pre class="example-preformatted">// In Rust, we use an enum variant instead of tagging
// The Number enum already provides type discrimination

#[derive(Debug, Clone, PartialEq)]
pub enum Number {
    SchemeNumber(i64),   // Tagged with variant name
    Rational(Rational),
    Complex(Complex),
}

// Arithmetic operations are implemented via trait impls
// (shown above - Add, Sub, Mul, Div traits)

// Constructor function
pub fn make_scheme_number(n: i64) -&gt; Number {
    Number::SchemeNumber(n)
}
</pre></div>

<p>Users of the Number package will create ordinary numbers by
calling the constructor:
</p>
<p>Now that the framework of the generic arithmetic system is in place, we can
readily include new kinds of numbers.  Here is a package that performs rational
arithmetic.  Notice that, as a benefit of additivity, we can use without
modification the rational-number code from <a class="ref" href="2_002e1.xhtml#g_t2_002e1_002e1">Example: Arithmetic Operations for Rational Numbers</a> as the internal
procedures in the package:
</p>
<div class="example">
<pre class="example-preformatted">// Rational number package using enum and trait
#[derive(Debug, Clone, Copy)]
struct Rational { numer: i64, denom: i64 }

impl Rational {
    fn new(n: i64, d: i64) -&gt; Self {
        let g = gcd(n.abs(), d.abs());
        let sign = if d &lt; 0 { -1 } else { 1 };
        Rational { numer: sign * n / g, denom: d.abs() / g }
    }
}

impl std::ops::Add for Rational {
    type Output = Self;
    fn add(self, other: Self) -&gt; Self {
        Rational::new(
            self.numer * other.denom + other.numer * self.denom,
            self.denom * other.denom,
        )
    }
}

impl std::ops::Sub for Rational {
    type Output = Self;
    fn sub(self, other: Self) -&gt; Self {
        Rational::new(
            self.numer * other.denom - other.numer * self.denom,
            self.denom * other.denom,
        )
    }
}

impl std::ops::Mul for Rational {
    type Output = Self;
    fn mul(self, other: Self) -&gt; Self {
        Rational::new(self.numer * other.numer, self.denom * other.denom)
    }
}

impl std::ops::Div for Rational {
    type Output = Self;
    fn div(self, other: Self) -&gt; Self {
        Rational::new(self.numer * other.denom, self.denom * other.numer)
    }
}
</pre></div>

<p>We can install a similar package to handle complex numbers, using the tag
<code class="code">complex</code>.  In creating the package, we extract from the table the
operations <code class="code">make_from_real_imag</code> and <code class="code">make_from_mag_ang</code> that were
defined by the rectangular and polar packages.  Additivity permits us to use,
as the internal operations, the same <code class="code">add_complex</code>, <code class="code">sub_complex</code>,
<code class="code">mul_complex</code>, and <code class="code">div_complex</code> procedures from <a class="ref" href="2_002e4.xhtml#g_t2_002e4_002e1">Representations for Complex Numbers</a>.
</p>
<div class="example">
<pre class="example-preformatted">// Complex number package using std::ops traits
impl std::ops::Add for Complex {
    type Output = Self;
    fn add(self, other: Self) -&gt; Self {
        Complex::Rectangular(
            self.real_part() + other.real_part(),
            self.imag_part() + other.imag_part(),
        )
    }
}

impl std::ops::Sub for Complex {
    type Output = Self;
    fn sub(self, other: Self) -&gt; Self {
        Complex::Rectangular(
            self.real_part() - other.real_part(),
            self.imag_part() - other.imag_part(),
        )
    }
}

impl std::ops::Mul for Complex {
    type Output = Self;
    fn mul(self, other: Self) -&gt; Self {
        Complex::Polar(
            self.magnitude() * other.magnitude(),
            self.angle() + other.angle(),
        )
    }
}

impl std::ops::Div for Complex {
    type Output = Self;
    fn div(self, other: Self) -&gt; Self {
        Complex::Polar(
            self.magnitude() / other.magnitude(),
            self.angle() - other.angle(),
        )
    }
}
</pre></div>

<p>Programs outside the complex-number package can construct complex numbers
either from real and imaginary parts or from magnitudes and angles.  Notice how
the underlying procedures, originally defined in the rectangular and polar
packages, are exported to the complex package, and exported from there to the
outside world.
</p>
<div class="example">
<pre class="example-preformatted">fn make_complex_from_real_imag(x: f64, y: f64) -&gt; Complex {
    Complex::Rectangular(x, y)
}

fn make_complex_from_mag_ang(r: f64, a: f64) -&gt; Complex {
    Complex::Polar(r, a)
}
</pre></div>

<p>What we have here is a two-level tag system.  A typical complex number, such as
<em class="math">{3 + 4i}</em> in rectangular form, would be represented as shown in <a class="ref" href="#Figure-2_002e24">Figure 2.24</a>.  
The outer tag (<code class="code">complex</code>) is used to direct the number to the
complex package.  Once within the complex package, the next tag
(<code class="code">rectangular</code>) is used to direct the number to the rectangular package.
In a large and complicated system there might be many levels, each interfaced
with the next by means of generic operations.  As a data object is passed
&#8220;downward,&#8221; the outer tag that is used to direct it to the appropriate
package is stripped off (by applying <code class="code">contents</code>) and the next level of tag
(if any) becomes visible to be used for further dispatching.
</p>
<div class="float">
<a class="anchor" id="Figure-2_002e24"></a><img class="image" src="fig/chap2/Fig2.24d.std.svg" alt="fig/chap2/Fig2.24d" />
<div class="caption"><p><strong class="strong">Figure 2.24:</strong> Representation of <em class="math">{3 + 4i}</em> in rectangular form.</p></div></div>
<p>In the above packages, we used <code class="code">add_rat</code>, <code class="code">add_complex</code>, and the
other arithmetic procedures exactly as originally written.  Once these
definitions are internal to different installation procedures, however, they no
longer need names that are distinct from each other: we could simply name them
<code class="code">add</code>, <code class="code">sub</code>, <code class="code">mul</code>, and <code class="code">div</code> in both packages.
</p>
<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-2_002e77"></a>Exercise 2.77:</strong> Louis Reasoner tries to evaluate
the expression <code class="code">(magnitude z)</code> where <code class="code">z</code> is the object shown in
<a class="ref" href="#Figure-2_002e24">Figure 2.24</a>.  To his surprise, instead of the answer 5 he gets an error
message from <code class="code">apply-generic</code>, saying there is no method for the operation
<code class="code">magnitude</code> on the types <code class="code">(complex)</code>.  He shows this interaction to
Alyssa P. Hacker, who says &#8220;The problem is that the complex-number selectors
were never defined for <code class="code">complex</code> numbers, just for <code class="code">polar</code> and
<code class="code">rectangular</code> numbers.  All you have to do to make this work is add the
following to the <code class="code">complex</code> package:&#8221;
</p>
<div class="example">
<pre class="example-preformatted">// Methods already available via pattern matching on Complex enum:
// complex.real_part(), complex.imag_part(),
// complex.magnitude(), complex.angle()
// No runtime dispatch table needed - the compiler handles it.
</pre></div>

<p>Describe in detail why this works.  As an example, trace through all the
procedures called in evaluating the expression <code class="code">(magnitude z)</code> where
<code class="code">z</code> is the object shown in <a class="ref" href="#Figure-2_002e24">Figure 2.24</a>.  In particular, how many
times is <code class="code">apply-generic</code> invoked?  What procedure is dispatched to in each
case?
</p></blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-2_002e78"></a>Exercise 2.78:</strong> The internal procedures in the
<code class="code">SchemeNumber</code> package are essentially nothing more than calls to the
primitive procedures <code class="code">+</code>, <code class="code">-</code>, etc.  It was not possible to use the
primitives of the language directly because our type-tag system requires that
each data object have a type attached to it.  In fact, however, all Lisp
implementations do have a type system, which they use internally.  Primitive
predicates such as <code class="code">symbol?</code> and <code class="code">number?</code>  determine whether data
objects have particular types.  Modify the definitions of <code class="code">type_tag</code>,
<code class="code">contents</code>, and <code class="code">attach_tag</code> from <a class="ref" href="2_002e4.xhtml#g_t2_002e4_002e2">Tagged data</a> so that our
generic system takes advantage of Scheme&#8217;s internal type system.  That is to
say, the system should work as before except that ordinary numbers should be
represented simply as Scheme numbers rather than as pairs whose <code class="code">car</code> is
the symbol <code class="code">SchemeNumber</code>.
</p></blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-2_002e79"></a>Exercise 2.79:</strong> Define a generic equality
predicate <code class="code">equ?</code> that tests the equality of two numbers, and install it in
the generic arithmetic package.  This operation should work for ordinary
numbers, rational numbers, and complex numbers.
</p></blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-2_002e80"></a>Exercise 2.80:</strong> Define a generic predicate
<code class="code">=zero?</code> that tests if its argument is zero, and install it in the generic
arithmetic package.  This operation should work for ordinary numbers, rational
numbers, and complex numbers.
</p></blockquote>

<hr />
</div>
<div class="subsection-level-extent" id="g_t2_002e5_002e2">
<h4 class="subsection" id="Combining-Data-of-Different-Types"><span>2.5.2 Combining Data of Different Types<a class="copiable-link" href="#Combining-Data-of-Different-Types"> &#182;</a></span></h4>

<p>We have seen how to define a unified arithmetic system that encompasses
ordinary numbers, complex numbers, rational numbers, and any other type of
number we might decide to invent, but we have ignored an important issue.  The
operations we have defined so far treat the different data types as being
completely independent.  Thus, there are separate packages for adding, say, two
ordinary numbers, or two complex numbers.  What we have not yet considered is
the fact that it is meaningful to define operations that cross the type
boundaries, such as the addition of a complex number to an ordinary number.  We
have gone to great pains to introduce barriers between parts of our programs so
that they can be developed and understood separately.  We would like to
introduce the cross-type operations in some carefully controlled way, so that
we can support them without seriously violating our module boundaries.
</p>
<p>One way to handle cross-type operations is to design a different procedure for
each possible combination of types for which the operation is valid.  For
example, we could extend the complex-number package so that it provides a
procedure for adding complex numbers to ordinary numbers and installs this in
the table using the tag <code class="code">(complex scheme-number)</code>:<a class="footnote" id="DOCF108" href="#FOOT108"><sup>108</sup></a>
</p>
<div class="example">
<pre class="example-preformatted">// In Rust, cross-type operations use From trait for coercion
impl std::ops::Add&lt;f64&gt; for Complex {
    type Output = Complex;
    fn add(self, x: f64) -&gt; Complex {
        Complex::Rectangular(
            self.real_part() + x,
            self.imag_part(),
        )
    }
}
</pre></div>

<p>This technique works, but it is cumbersome.  With such a system, the cost of
introducing a new type is not just the construction of the package of
procedures for that type but also the construction and installation of the
procedures that implement the cross-type operations.  This can easily be much
more code than is needed to define the operations on the type itself.  The
method also undermines our ability to combine separate packages additively, or
at least to limit the extent to which the implementors of the individual packages
need to take account of other packages.  For instance, in the example above, it
seems reasonable that handling mixed operations on complex numbers and ordinary
numbers should be the responsibility of the complex-number package.  Combining
rational numbers and complex numbers, however, might be done by the complex
package, by the rational package, or by some third package that uses operations
extracted from these two packages.  Formulating coherent policies on the
division of responsibility among packages can be an overwhelming task in
designing systems with many packages and many cross-type operations.
</p>
<h4 class="subsubheading" id="Coercion"><span>Coercion<a class="copiable-link" href="#Coercion"> &#182;</a></span></h4>

<p>In the general situation of completely unrelated operations acting on
completely unrelated types, implementing explicit cross-type operations,
cumbersome though it may be, is the best that one can hope for.  Fortunately,
we can usually do better by taking advantage of additional structure that may
be latent in our type system.  Often the different data types are not
completely independent, and there may be ways by which objects of one type may
be viewed as being of another type.  This process is called <a class="index-entry-id" id="index-coercion"></a>
<em class="dfn">coercion</em>.
For example, if we are asked to arithmetically combine an ordinary number with
a complex number, we can view the ordinary number as a complex number whose
imaginary part is zero.  This transforms the problem to that of combining two
complex numbers, which can be handled in the ordinary way by the
complex-arithmetic package.
</p>
<p>In general, we can implement this idea by designing coercion procedures that
transform an object of one type into an equivalent object of another type.
Here is a typical coercion procedure, which transforms a given ordinary number
to a complex number with that real part and zero imaginary part:
</p>
<div class="example">
<pre class="example-preformatted">impl From&lt;f64&gt; for Complex {
    fn from(n: f64) -&gt; Complex {
        Complex::Rectangular(n, 0.0)
    }
}
</pre></div>

<p>We install these coercion procedures in a special coercion table, indexed under
the names of the two types:
</p>
<div class="example">
<pre class="example-preformatted">// The From&lt;f64&gt; impl above registers this coercion.
// Usage: Complex::from(5.0) or 5.0_f64.into()
</pre></div>

<p>(We assume that there are <code class="code">put-coercion</code> and <code class="code">get-coercion</code>
procedures available for manipulating this table.)  Generally some of the slots
in the table will be empty, because it is not generally possible to coerce an
arbitrary data object of each type into all other types.  For example, there is
no way to coerce an arbitrary complex number to an ordinary number, so there
will be no general <code class="code">complex-&gt;scheme-number</code> procedure included in the
table.
</p>
<p>Once the coercion table has been set up, we can handle coercion in a uniform
manner by modifying the <code class="code">apply-generic</code> procedure of <a class="ref" href="2_002e4.xhtml#g_t2_002e4_002e3">Data-Directed Programming and Additivity</a>.
When asked to apply an operation, we first check whether the operation is
defined for the arguments&#8217; types, just as before.  If so, we dispatch to the
procedure found in the operation-and-type table.  Otherwise, we try coercion.
For simplicity, we consider only the case where there are two
arguments.<a class="footnote" id="DOCF109" href="#FOOT109"><sup>109</sup></a>  We check the
coercion table to see if objects of the first type can be coerced to the second
type.  If so, we coerce the first argument and try the operation again.  If
objects of the first type cannot in general be coerced to the second type, we
try the coercion the other way around to see if there is a way to coerce the
second argument to the type of the first argument.  Finally, if there is no
known way to coerce either type to the other type, we give up.  Here is the
procedure:
</p>
<div class="example">
<pre class="example-preformatted">// Rust's trait system handles coercion at compile time.
// With From/Into implementations, we can write generic
// functions that accept any coercible type:

fn add_numbers&lt;A, B&gt;(a: A, b: B) -&gt; Complex
where
    A: Into&lt;Complex&gt;,
    B: Into&lt;Complex&gt;,
{
    let a: Complex = a.into();
    let b: Complex = b.into();
    a + b
}

// Usage:
let result = add_numbers(3.0_f64, Complex::Rectangular(1.0, 2.0));
// =&gt; Complex::Rectangular(4.0, 2.0)
</pre></div>

<p>This coercion scheme has many advantages over the method of defining explicit
cross-type operations, as outlined above.  Although we still need to write
coercion procedures to relate the types (possibly <em class="math">n^2</em> procedures for a
system with <em class="math">n</em> types), we need to write only one procedure for each pair of
types rather than a different procedure for each collection of types and each
generic operation.<a class="footnote" id="DOCF110" href="#FOOT110"><sup>110</sup></a>  What we are counting on here is the fact
that the appropriate transformation between types depends only on the types
themselves, not on the operation to be applied.
</p>
<p>On the other hand, there may be applications for which our coercion scheme is
not general enough.  Even when neither of the objects to be combined can be
converted to the type of the other it may still be possible to perform the
operation by converting both objects to a third type.  In order to deal with
such complexity and still preserve modularity in our programs, it is usually
necessary to build systems that take advantage of still further structure in
the relations among types, as we discuss next.
</p>
<h4 class="subsubheading" id="Hierarchies-of-types"><span>Hierarchies of types<a class="copiable-link" href="#Hierarchies-of-types"> &#182;</a></span></h4>

<p>The coercion scheme presented above relied on the existence of natural
relations between pairs of types.  Often there is more &#8220;global&#8221; structure in
how the different types relate to each other.  For instance, suppose we are
building a generic arithmetic system to handle integers, rational numbers, real
numbers, and complex numbers.  In such a system, it is quite natural to regard
an integer as a special kind of rational number, which is in turn a special
kind of real number, which is in turn a special kind of complex number.  What
we actually have is a so-called <a class="index-entry-id" id="index-hierarchy-of-types"></a>
<em class="dfn">hierarchy of types</em>, in which, for
example, integers are a <a class="index-entry-id" id="index-subtype"></a>
<em class="dfn">subtype</em> of rational numbers (i.e., any
operation that can be applied to a rational number can automatically be applied
to an integer).  Conversely, we say that rational numbers form a
<a class="index-entry-id" id="index-supertype"></a>
<em class="dfn">supertype</em> of integers.  The particular hierarchy we have here is of a
very simple kind, in which each type has at most one supertype and at most one
subtype.  Such a structure, called a <a class="index-entry-id" id="index-tower"></a>
<em class="dfn">tower</em>, is illustrated in
<a class="ref" href="#Figure-2_002e25">Figure 2.25</a>.
</p>
<div class="float">
<a class="anchor" id="Figure-2_002e25"></a><img class="image" src="fig/chap2/Fig2.25.std.svg" alt="fig/chap2/Fig2.25" />
<div class="caption"><p><strong class="strong">Figure 2.25:</strong> A tower of types.</p></div></div>
<p>If we have a tower structure, then we can greatly simplify the problem of
adding a new type to the hierarchy, for we need only specify how the new type
is embedded in the next supertype above it and how it is the supertype of the
type below it.  For example, if we want to add an integer to a complex number,
we need not explicitly define a special coercion procedure
<code class="code">integer-&gt;complex</code>.  Instead, we define how an integer can be transformed
into a rational number, how a rational number is transformed into a real
number, and how a real number is transformed into a complex number.  We then
allow the system to transform the integer into a complex number through these
steps and then add the two complex numbers.
</p>
<p>We can redesign our <code class="code">apply-generic</code> procedure in the following way: For
each type, we need to supply a <code class="code">raise</code> procedure, which &#8220;raises&#8221; objects
of that type one level in the tower.  Then when the system is required to
operate on objects of different types it can successively raise the lower types
until all the objects are at the same level in the tower.  (<a class="ref" href="#Exercise-2_002e83">Exercise 2.83</a>
and <a class="ref" href="#Exercise-2_002e84">Exercise 2.84</a> concern the details of implementing such a strategy.)
</p>
<p>Another advantage of a tower is that we can easily implement the notion that
every type &#8220;inherits&#8221; all operations defined on a supertype.  For instance,
if we do not supply a special procedure for finding the real part of an
integer, we should nevertheless expect that <code class="code">real_part</code> will be defined
for integers by virtue of the fact that integers are a subtype of complex
numbers.  In a tower, we can arrange for this to happen in a uniform way by
modifying <code class="code">apply-generic</code>.  If the required operation is not directly
defined for the type of the object given, we raise the object to its supertype
and try again.  We thus crawl up the tower, transforming our argument as we go,
until we either find a level at which the desired operation can be performed or
hit the top (in which case we give up).
</p>
<p>Yet another advantage of a tower over a more general hierarchy is that it gives
us a simple way to &#8220;lower&#8221; a data object to the simplest representation.  For
example, if we add <em class="math">{2 + 3i}</em> to <em class="math">{4 - 3i}</em>, it would be nice to obtain the
answer as the integer 6 rather than as the complex number <em class="math">{6 + 0i}</em>.
<a class="ref" href="#Exercise-2_002e85">Exercise 2.85</a> discusses a way to implement such a lowering operation.
(The trick is that we need a general way to distinguish those objects that can
be lowered, such as <em class="math">{6 + 0i}</em>, from those that cannot, such as <em class="math">{6 + 2i}</em>.)
</p>
<h4 class="subsubheading" id="Inadequacies-of-hierarchies"><span>Inadequacies of hierarchies<a class="copiable-link" href="#Inadequacies-of-hierarchies"> &#182;</a></span></h4>

<p>If the data types in our system can be naturally arranged in a tower, this
greatly simplifies the problems of dealing with generic operations on different
types, as we have seen.  Unfortunately, this is usually not the case.
<a class="ref" href="#Figure-2_002e26">Figure 2.26</a> illustrates a more complex arrangement of mixed types, this
one showing relations among different types of geometric figures.  We see that,
in general, a type may have more than one subtype.  Triangles and
quadrilaterals, for instance, are both subtypes of polygons.  In addition, a
type may have more than one supertype.  For example, an isosceles right
triangle may be regarded either as an isosceles triangle or as a right
triangle.  This multiple-supertypes issue is particularly thorny, since it
means that there is no unique way to &#8220;raise&#8221; a type in the hierarchy.
Finding the &#8220;correct&#8221; supertype in which to apply an operation to an object
may involve considerable searching through the entire type network on the part
of a procedure such as <code class="code">apply-generic</code>.  Since there generally are
multiple subtypes for a type, there is a similar problem in coercing a value
&#8220;down&#8221; the type hierarchy.  Dealing with large numbers of interrelated types
while still preserving modularity in the design of large systems is very
difficult, and is an area of much current research.<a class="footnote" id="DOCF111" href="#FOOT111"><sup>111</sup></a>
</p>
<div class="float">
<a class="anchor" id="Figure-2_002e26"></a><img class="image" src="fig/chap2/Fig2.26f.std.svg" alt="fig/chap2/Fig2.26f" />
<div class="caption"><p><strong class="strong">Figure 2.26:</strong> Relations among types of geometric figures.</p></div></div>
<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-2_002e81"></a>Exercise 2.81:</strong> Louis Reasoner has noticed that
<code class="code">apply-generic</code> may try to coerce the arguments to each other&#8217;s type even
if they already have the same type.  Therefore, he reasons, we need to put
procedures in the coercion table to <a class="index-entry-id" id="index-coerce"></a>
<em class="dfn">coerce</em> arguments of each type to
their own type.  For example, in addition to the
<code class="code">scheme-number-&gt;complex</code> coercion shown above, he would do:
</p>
<div class="example">
<pre class="example-preformatted">// Identity coercion - unnecessary in Rust since types are known
// at compile time. The compiler won't try to coerce f64 to f64.
fn identity&lt;T&gt;(x: T) -&gt; T { x }
</pre></div>

<ol class="enumerate" type="a" start="1">
<li> With Louis&#8217;s coercion procedures installed, what happens if
<code class="code">apply-generic</code> is called with two arguments of type <code class="code">SchemeNumber</code>
or two arguments of type <code class="code">complex</code> for an operation that is not found in
the table for those types?  For example, assume that we&#8217;ve defined a generic
exponentiation operation:

<div class="example">
<pre class="example-preformatted">fn exp&lt;T: num_traits::Pow&lt;T, Output = T&gt;&gt;(x: T, y: T) -&gt; T {
    x.pow(y)
}
</pre></div>

<p>and have put a procedure for exponentiation in the Scheme-number
package but not in any other package:
</p>
<div class="example">
<pre class="example-preformatted">// Exponentiation for f64 is built into the language
fn exp_f64(x: f64, y: f64) -&gt; f64 {
    x.powf(y)  // using primitive powf
}
</pre></div>

<p>What happens if we call <code class="code">exp</code> with two complex numbers as arguments?
</p>
</li><li> Is Louis correct that something had to be done about coercion with arguments of
the same type, or does <code class="code">apply-generic</code> work correctly as is?

</li><li> Modify <code class="code">apply-generic</code> so that it doesn&#8217;t try coercion if the two
arguments have the same type.

</li></ol>
</blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-2_002e82"></a>Exercise 2.82:</strong> Show how to generalize
<code class="code">apply-generic</code> to handle coercion in the general case of multiple
arguments.  One strategy is to attempt to coerce all the arguments to the type
of the first argument, then to the type of the second argument, and so on.
Give an example of a situation where this strategy (and likewise the
two-argument version given above) is not sufficiently general.  (Hint: Consider
the case where there are some suitable mixed-type operations present in the
table that will not be tried.)
</p></blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-2_002e83"></a>Exercise 2.83:</strong> Suppose you are designing a
generic arithmetic system for dealing with the tower of types shown in
<a class="ref" href="#Figure-2_002e25">Figure 2.25</a>: integer, rational, real, complex.  For each type (except
complex), design a procedure that raises objects of that type one level in the
tower.  Show how to install a generic <code class="code">raise</code> operation that will work for
each type (except complex).
</p></blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-2_002e84"></a>Exercise 2.84:</strong> Using the <code class="code">raise</code> operation
of <a class="ref" href="#Exercise-2_002e83">Exercise 2.83</a>, modify the <code class="code">apply-generic</code> procedure so that it
coerces its arguments to have the same type by the method of successive
raising, as discussed in this section.  You will need to devise a way to test
which of two types is higher in the tower.  Do this in a manner that is
&#8220;compatible&#8221; with the rest of the system and will not lead to problems in
adding new levels to the tower.
</p></blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-2_002e85"></a>Exercise 2.85:</strong> This section mentioned a method
for &#8220;simplifying&#8221; a data object by lowering it in the tower of types as far
as possible.  Design a procedure <code class="code">drop</code> that accomplishes this for the
tower described in <a class="ref" href="#Exercise-2_002e83">Exercise 2.83</a>.  The key is to decide, in some general
way, whether an object can be lowered.  For example, the complex number 
<em class="math">{1.5 + 0i}</em> can be lowered as far as <code class="code">real</code>, the complex number <em class="math">{1 + 0i}</em> can
be lowered as far as <code class="code">integer</code>, and the complex number <em class="math">{2 + 3i}</em> cannot
be lowered at all.  Here is a plan for determining whether an object can be
lowered: Begin by defining a generic operation <code class="code">project</code> that &#8220;pushes&#8221;
an object down in the tower.  For example, projecting a complex number would
involve throwing away the imaginary part.  Then a number can be dropped if,
when we <code class="code">project</code> it and <code class="code">raise</code> the result back to the type we
started with, we end up with something equal to what we started with.  Show how
to implement this idea in detail, by writing a <code class="code">drop</code> procedure that drops
an object as far as possible.  You will need to design the various projection
operations<a class="footnote" id="DOCF112" href="#FOOT112"><sup>112</sup></a> and
install <code class="code">project</code> as a generic operation in the system.  You will also
need to make use of a generic equality predicate, such as described in
<a class="ref" href="#Exercise-2_002e79">Exercise 2.79</a>.  Finally, use <code class="code">drop</code> to rewrite <code class="code">apply-generic</code>
from <a class="ref" href="#Exercise-2_002e84">Exercise 2.84</a> so that it &#8220;simplifies&#8221; its answers.
</p></blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-2_002e86"></a>Exercise 2.86:</strong> Suppose we want to handle complex
numbers whose real parts, imaginary parts, magnitudes, and angles can be either
ordinary numbers, rational numbers, or other numbers we might wish to add to
the system.  Describe and implement the changes to the system needed to
accommodate this.  You will have to define operations such as <code class="code">sine</code> and
<code class="code">cosine</code> that are generic over ordinary numbers and rational numbers.
</p></blockquote>

<hr />
</div>
<div class="subsection-level-extent" id="g_t2_002e5_002e3">
<h4 class="subsection" id="Example_003a-Symbolic-Algebra"><span>2.5.3 Example: Symbolic Algebra<a class="copiable-link" href="#Example_003a-Symbolic-Algebra"> &#182;</a></span></h4>

<p>The manipulation of symbolic algebraic expressions is a complex process that
illustrates many of the hardest problems that occur in the design of
large-scale systems.  An algebraic expression, in general, can be viewed as a
hierarchical structure, a tree of operators applied to operands.  We can
construct algebraic expressions by starting with a set of primitive objects,
such as constants and variables, and combining these by means of algebraic
operators, such as addition and multiplication.  As in other languages, we form
abstractions that enable us to refer to compound objects in simple terms.
Typical abstractions in symbolic algebra are ideas such as linear combination,
polynomial, rational function, or trigonometric function.  We can regard these
as compound &#8220;types,&#8221; which are often useful for directing the processing of
expressions.  For example, we could describe the expression
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
  <mrow data-mjx-texclass="ORD">
    <msup>
      <mi>x</mi>
      <mn>2</mn>
    </msup>
    <mi>sin</mi>
    <mo data-mjx-texclass="NONE">&#x2061;</mo>
    <mo stretchy="false">(</mo>
    <msup>
      <mi>y</mi>
      <mn>2</mn>
    </msup>
    <mo>+</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
  </mrow>
  <mo>+</mo>
  <mrow data-mjx-texclass="ORD">
    <mi>x</mi>
    <mi>cos</mi>
    <mo data-mjx-texclass="NONE">&#x2061;</mo>
    <mn>2</mn>
    <mi>y</mi>
  </mrow>
  <mo>+</mo>
  <mrow data-mjx-texclass="ORD">
    <mi>cos</mi>
    <mo data-mjx-texclass="NONE">&#x2061;</mo>
    <mo stretchy="false">(</mo>
    <msup>
      <mi>y</mi>
      <mn>3</mn>
    </msup>
    <mo>&#x2212;</mo>
    <mn>2</mn>
    <msup>
      <mi>y</mi>
      <mn>2</mn>
    </msup>
    <mo stretchy="false">)</mo>
  </mrow>
</math>
as a polynomial in <em class="math">x</em> with coefficients that are trigonometric functions of
polynomials in <em class="math">y</em> whose coefficients are integers.
</p>
<p>We will not attempt to develop a complete algebraic-manipulation system here.
Such systems are exceedingly complex programs, embodying deep algebraic
knowledge and elegant algorithms.  What we will do is look at a simple but
important part of algebraic manipulation: the arithmetic of polynomials.  We
will illustrate the kinds of decisions the designer of such a system faces, and
how to apply the ideas of abstract data and generic operations to help organize
this effort.
</p>
<h4 class="subsubheading" id="Arithmetic-on-polynomials"><span>Arithmetic on polynomials<a class="copiable-link" href="#Arithmetic-on-polynomials"> &#182;</a></span></h4>

<p>Our first task in designing a system for performing arithmetic on polynomials
is to decide just what a polynomial is.  Polynomials are normally defined
relative to certain variables (the <a class="index-entry-id" id="index-indeterminates"></a>
<em class="dfn">indeterminates</em> of the polynomial).
For simplicity, we will restrict ourselves to polynomials having just one
indeterminate (<a class="index-entry-id" id="index-univariate-polynomials"></a>
<em class="dfn">univariate polynomials</em>).<a class="footnote" id="DOCF113" href="#FOOT113"><sup>113</sup></a> We will define a polynomial to be a sum of terms, each of
which is either a coefficient, a power of the indeterminate, or a product of a
coefficient and a power of the indeterminate.  A coefficient is defined as an
algebraic expression that is not dependent upon the indeterminate of the
polynomial.  For example,
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
  <mrow data-mjx-texclass="ORD">
    <mn>5</mn>
    <msup>
      <mi>x</mi>
      <mn>2</mn>
    </msup>
  </mrow>
  <mo>+</mo>
  <mrow data-mjx-texclass="ORD">
    <mn>3</mn>
    <mi>x</mi>
  </mrow>
  <mo>+</mo>
  <mn>7</mn>
</math>
is a simple polynomial in <em class="math">x</em>, and
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
  <mrow data-mjx-texclass="ORD">
    <mo stretchy="false">(</mo>
    <msup>
      <mi>y</mi>
      <mn>2</mn>
    </msup>
    <mo>+</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
    <msup>
      <mi>x</mi>
      <mn>3</mn>
    </msup>
  </mrow>
  <mo>+</mo>
  <mrow data-mjx-texclass="ORD">
    <mo stretchy="false">(</mo>
    <mn>2</mn>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
    <mi>x</mi>
    <mo>+</mo>
    <mn>1</mn>
  </mrow>
</math>
is a polynomial in <em class="math">x</em> whose coefficients are polynomials in <em class="math">y</em>.
</p>
<p>Already we are skirting some thorny issues.  Is the first of these polynomials
the same as the polynomial <em class="math">{5y^2 + 3y + 7}</em>, or not?  A reasonable answer
might be &#8220;yes, if we are considering a polynomial purely as a mathematical
function, but no, if we are considering a polynomial to be a syntactic form.&#8221;
The second polynomial is algebraically equivalent to a polynomial in <em class="math">y</em>
whose coefficients are polynomials in <em class="math">x</em>.  Should our system recognize this,
or not?  Furthermore, there are other ways to represent a polynomial&#8212;for
example, as a product of factors, or (for a univariate polynomial) as the set
of roots, or as a listing of the values of the polynomial at a specified set of
points.<a class="footnote" id="DOCF114" href="#FOOT114"><sup>114</sup></a>  We can finesse these questions by
deciding that in our algebraic-manipulation system a &#8220;polynomial&#8221; will be a
particular syntactic form, not its underlying mathematical meaning.
</p>
<p>Now we must consider how to go about doing arithmetic on polynomials.  In this
simple system, we will consider only addition and multiplication.  Moreover, we
will insist that two polynomials to be combined must have the same
indeterminate.
</p>
<p>We will approach the design of our system by following the familiar discipline
of data abstraction.  We will represent polynomials using a data structure
called a <a class="index-entry-id" id="index-poly"></a>
<em class="dfn">poly</em>, which consists of a variable and a collection of
terms.  We assume that we have selectors <code class="code">variable</code> and <code class="code">term-list</code>
that extract those parts from a poly and a constructor <code class="code">make-poly</code> that
assembles a poly from a given variable and a term list.  A variable will be
just a symbol, so we can use the <code class="code">same_variable</code>  procedure of 
<a class="ref" href="2_002e3.xhtml#g_t2_002e3_002e2">Example: Symbolic Differentiation</a> to compare variables.  The following procedures define addition and
multiplication of polys:
</p>
<div class="example">
<pre class="example-preformatted">fn add_poly(p1: &amp;Poly, p2: &amp;Poly) -&gt; Result&lt;Poly, &amp;'static str&gt; {
    if p1.variable == p2.variable {
        Ok(Poly {
            variable: p1.variable.clone(),
            terms: add_terms(&amp;p1.terms, &amp;p2.terms),
        })
    } else {
        Err(&quot;Polys not in same var: ADD-POLY&quot;)
    }
}

fn mul_poly(p1: &amp;Poly, p2: &amp;Poly) -&gt; Result&lt;Poly, &amp;'static str&gt; {
    if p1.variable == p2.variable {
        Ok(Poly {
            variable: p1.variable.clone(),
            terms: mul_terms(&amp;p1.terms, &amp;p2.terms),
        })
    } else {
        Err(&quot;Polys not in same var: MUL-POLY&quot;)
    }
}
</pre></div>

<p>To incorporate polynomials into our generic arithmetic system, we need to
supply them with type tags.  We&#8217;ll use the tag <code class="code">polynomial</code>, and install
appropriate operations on tagged polynomials in the operation table.  We&#8217;ll
embed all our code in an installation procedure for the polynomial package,
similar to the ones in <a class="ref" href="#g_t2_002e5_002e1">Generic Arithmetic Operations</a>:
</p>
<div class="example">
<pre class="example-preformatted">// Polynomial struct with variable name and term list
#[derive(Debug, Clone, PartialEq)]
struct Poly {
    variable: String,
    terms: Vec&lt;Term&gt;,
}

#[derive(Debug, Clone, PartialEq)]
struct Term {
    order: usize,
    coeff: f64,
}

impl Poly {
    fn new(variable: &amp;str, terms: Vec&lt;Term&gt;) -&gt; Self {
        Poly { variable: variable.to_string(), terms }
    }
}

// Trait implementations provide generic operations
impl std::ops::Add for Poly {
    type Output = Result&lt;Poly, &amp;'static str&gt;;
    fn add(self, other: Poly) -&gt; Self::Output {
        add_poly(&amp;self, &amp;other)
    }
}

impl std::ops::Mul for Poly {
    type Output = Result&lt;Poly, &amp;'static str&gt;;
    fn mul(self, other: Poly) -&gt; Self::Output {
        mul_poly(&amp;self, &amp;other)
    }
}
</pre></div>

<p>Polynomial addition is performed termwise.  Terms of the same order (i.e., with
the same power of the indeterminate) must be combined.  This is done by forming
a new term of the same order whose coefficient is the sum of the coefficients
of the addends.  Terms in one addend for which there are no terms of the same
order in the other addend are simply accumulated into the sum polynomial being
constructed.
</p>
<p>In order to manipulate term lists, we will assume that we have a constructor
empty term list that returns an empty term list and a constructor
<code class="code">adjoin_term</code> that adjoins a new term to a term list.  We will also assume
that we have a predicate <code class="code">is_empty</code> (or similar test) that tells if a given term list
is empty, a selector <code class="code">first_term</code> that extracts the highest-order term
from a term list, and a selector <code class="code">rest_terms</code> that returns all but the
highest-order term.  To manipulate terms, we will suppose that we have a
constructor <code class="code">make_term</code> that constructs a term with given order and
coefficient, and selectors <code class="code">order</code> and <code class="code">coeff</code> that return,
respectively, the order and the coefficient of the term.  These operations
allow us to consider both terms and term lists as data abstractions, whose
concrete representations we can worry about separately.
</p>
<p>Here is the procedure that constructs the term list for the sum of two
polynomials:<a class="footnote" id="DOCF115" href="#FOOT115"><sup>115</sup></a>
</p>
<div class="example">
<pre class="example-preformatted">fn add_terms(l1: &amp;[Term], l2: &amp;[Term]) -&gt; Vec&lt;Term&gt; {
    match (l1.first(), l2.first()) {
        (None, _) =&gt; l2.to_vec(),
        (_, None) =&gt; l1.to_vec(),
        (Some(t1), Some(t2)) =&gt; match t1.order.cmp(&amp;t2.order) {
            std::cmp::Ordering::Greater =&gt; {
                let mut result = vec![t1.clone()];
                result.extend(add_terms(&amp;l1[1..], l2));
                result
            }
            std::cmp::Ordering::Less =&gt; {
                let mut result = vec![t2.clone()];
                result.extend(add_terms(l1, &amp;l2[1..]));
                result
            }
            std::cmp::Ordering::Equal =&gt; {
                let sum_coeff = t1.coeff + t2.coeff;
                let mut result = if sum_coeff != 0.0 {
                    vec![Term { order: t1.order, coeff: sum_coeff }]
                } else {
                    vec![]
                };
                result.extend(add_terms(&amp;l1[1..], &amp;l2[1..]));
                result
            }
        },
    }
}
</pre></div>

<p>The most important point to note here is that we used the generic addition
procedure <code class="code">add</code> to add together the coefficients of the terms being
combined.  This has powerful consequences, as we will see below.
</p>
<p>In order to multiply two term lists, we multiply each term of the first list by
all the terms of the other list, repeatedly using <code class="code">mul-term-by-all-terms</code>,
which multiplies a given term by all terms in a given term list.  The resulting
term lists (one for each term of the first list) are accumulated into a sum.
Multiplying two terms forms a term whose order is the sum of the orders of the
factors and whose coefficient is the product of the coefficients of the
factors:
</p>
<div class="example">
<pre class="example-preformatted">fn mul_terms(l1: &amp;[Term], l2: &amp;[Term]) -&gt; Vec&lt;Term&gt; {
    if l1.is_empty() {
        vec![]
    } else {
        add_terms(
            &amp;mul_term_by_all_terms(&amp;l1[0], l2),
            &amp;mul_terms(&amp;l1[1..], l2),
        )
    }
}

fn mul_term_by_all_terms(t1: &amp;Term, l: &amp;[Term]) -&gt; Vec&lt;Term&gt; {
    l.iter()
        .map(|t2| Term {
            order: t1.order + t2.order,
            coeff: t1.coeff * t2.coeff,
        })
        .collect()
}
</pre></div>

<p>This is really all there is to polynomial addition and multiplication.  Notice
that, since we operate on terms using the generic procedures <code class="code">add</code> and
<code class="code">mul</code>, our polynomial package is automatically able to handle any type of
coefficient that is known about by the generic arithmetic package.  If we
include a coercion mechanism such as one of those discussed in 
<a class="ref" href="#g_t2_002e5_002e2">Combining Data of Different Types</a>, then we also are automatically able to handle operations on
polynomials of different coefficient types, such as
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
  <mrow data-mjx-texclass="ORD">
    <mo stretchy="false">[</mo>
    <mn>3</mn>
    <msup>
      <mi>x</mi>
      <mn>2</mn>
    </msup>
    <mo>+</mo>
    <mo stretchy="false">(</mo>
    <mn>2</mn>
    <mo>+</mo>
    <mn>3</mn>
    <mi>i</mi>
    <mo stretchy="false">)</mo>
    <mi>x</mi>
    <mo>+</mo>
    <mn>7</mn>
    <mo stretchy="false">]</mo>
    <mo>&#x22C5;</mo>
  </mrow>
  <mrow data-mjx-texclass="ORD">
    <mrow data-mjx-texclass="INNER">
      <mo data-mjx-texclass="OPEN">[</mo>
      <msup>
        <mi>x</mi>
        <mn>4</mn>
      </msup>
      <mo>+</mo>
      <mrow data-mjx-texclass="ORD">
        <mfrac>
          <mn>2</mn>
          <mn>3</mn>
        </mfrac>
      </mrow>
      <msup>
        <mi>x</mi>
        <mn>2</mn>
      </msup>
      <mo>+</mo>
      <mo stretchy="false">(</mo>
      <mn>5</mn>
      <mo>+</mo>
      <mn>3</mn>
      <mi>i</mi>
      <mo stretchy="false">)</mo>
      <mo data-mjx-texclass="CLOSE">]</mo>
    </mrow>
    <mo>.</mo>
  </mrow>
</math>
Because we installed the polynomial addition and multiplication procedures
<code class="code">add_poly</code> and <code class="code">mul_poly</code> in the generic arithmetic system as the
<code class="code">add</code> and <code class="code">mul</code> operations for type <code class="code">polynomial</code>, our system is
also automatically able to handle polynomial operations such as
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
  <mrow data-mjx-texclass="ORD">
    <mrow data-mjx-texclass="ORD">
      <mo minsize="1.623em" maxsize="1.623em">[</mo>
    </mrow>
    <mo stretchy="false">(</mo>
    <mi>y</mi>
    <mo>+</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
    <msup>
      <mi>x</mi>
      <mn>2</mn>
    </msup>
  </mrow>
  <mo>+</mo>
  <mrow data-mjx-texclass="ORD">
    <mo stretchy="false">(</mo>
    <msup>
      <mi>y</mi>
      <mn>2</mn>
    </msup>
    <mo>+</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
    <mi>x</mi>
  </mrow>
  <mo>+</mo>
  <mrow data-mjx-texclass="ORD">
    <mo stretchy="false">(</mo>
    <mi>y</mi>
    <mo>&#x2212;</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
    <mrow data-mjx-texclass="ORD">
      <mo minsize="1.623em" maxsize="1.623em">]</mo>
    </mrow>
    <mo>&#x22C5;</mo>
  </mrow>
  <mrow data-mjx-texclass="ORD">
    <mrow data-mjx-texclass="ORD">
      <mo minsize="1.623em" maxsize="1.623em">[</mo>
    </mrow>
    <mo stretchy="false">(</mo>
    <mi>y</mi>
    <mo>&#x2212;</mo>
    <mn>2</mn>
    <mo stretchy="false">)</mo>
    <mi>x</mi>
  </mrow>
  <mo>+</mo>
  <mrow data-mjx-texclass="ORD">
    <mo stretchy="false">(</mo>
    <msup>
      <mi>y</mi>
      <mn>3</mn>
    </msup>
    <mo>+</mo>
    <mn>7</mn>
    <mo stretchy="false">)</mo>
    <mrow data-mjx-texclass="ORD">
      <mo minsize="1.623em" maxsize="1.623em">]</mo>
    </mrow>
    <mo>.</mo>
  </mrow>
</math>
The reason is that when the system tries to combine coefficients, it will
dispatch through <code class="code">add</code> and <code class="code">mul</code>.  Since the coefficients are
themselves polynomials (in <em class="math">y</em>), these will be combined using <code class="code">add_poly</code>
and <code class="code">mul_poly</code>.  The result is a kind of &#8220;data-directed recursion&#8221; in
which, for example, a call to <code class="code">mul_poly</code> will result in recursive calls to
<code class="code">mul_poly</code> in order to multiply the coefficients.  If the coefficients of
the coefficients were themselves polynomials (as might be used to represent
polynomials in three variables), the data direction would ensure that the
system would follow through another level of recursive calls, and so on through
as many levels as the structure of the data dictates.<a class="footnote" id="DOCF116" href="#FOOT116"><sup>116</sup></a>
</p>
<h4 class="subsubheading" id="Representing-term-lists"><span>Representing term lists<a class="copiable-link" href="#Representing-term-lists"> &#182;</a></span></h4>

<p>Finally, we must confront the job of implementing a good representation for
term lists.  A term list is, in effect, a set of coefficients keyed by the
order of the term.  Hence, any of the methods for representing sets, as
discussed in <a class="ref" href="2_002e3.xhtml#g_t2_002e3_002e3">Example: Representing Sets</a>, can be applied to this task.  On the other
hand, our procedures <code class="code">add-terms</code> and <code class="code">mul-terms</code> always access term
lists sequentially from highest to lowest order.  Thus, we will use some kind
of ordered list representation.
</p>
<p>How should we structure the list that represents a term list?  One
consideration is the &#8220;density&#8221; of the polynomials we intend to manipulate.  A
polynomial is said to be <a class="index-entry-id" id="index-dense"></a>
<em class="dfn">dense</em> if it has nonzero coefficients in
terms of most orders.  If it has many zero terms it is said to be
<a class="index-entry-id" id="index-sparse"></a>
<em class="dfn">sparse</em>.  For example,
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
  <mi>A</mi>
  <mo>:</mo>
  <mstyle scriptlevel="0">
    <mspace width="1em"></mspace>
  </mstyle>
  <mrow data-mjx-texclass="ORD">
    <msup>
      <mi>x</mi>
      <mn>5</mn>
    </msup>
  </mrow>
  <mo>+</mo>
  <mrow data-mjx-texclass="ORD">
    <mn>2</mn>
    <msup>
      <mi>x</mi>
      <mn>4</mn>
    </msup>
  </mrow>
  <mo>+</mo>
  <mrow data-mjx-texclass="ORD">
    <mn>3</mn>
    <msup>
      <mi>x</mi>
      <mn>2</mn>
    </msup>
  </mrow>
  <mo>&#x2212;</mo>
  <mrow data-mjx-texclass="ORD">
    <mn>2</mn>
    <mi>x</mi>
  </mrow>
  <mo>&#x2212;</mo>
  <mn>5</mn>
</math>
is a dense polynomial, whereas
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
  <mi>B</mi>
  <mo>:</mo>
  <mstyle scriptlevel="0">
    <mspace width="1em"></mspace>
  </mstyle>
  <msup>
    <mi>x</mi>
    <mrow data-mjx-texclass="ORD">
      <mn>100</mn>
    </mrow>
  </msup>
  <mo>+</mo>
  <mrow data-mjx-texclass="ORD">
    <mn>2</mn>
    <msup>
      <mi>x</mi>
      <mn>2</mn>
    </msup>
  </mrow>
  <mo>+</mo>
  <mn>1</mn>
</math>
is sparse.
</p>
<p>The term lists of dense polynomials are most efficiently represented as lists
of the coefficients.  For example, <em class="math">A</em> above would be nicely represented as
<code class="code">(1 2 0 3 -2 -5)</code>.  The order of a term in this representation is the
length of the sublist beginning with that term&#8217;s coefficient, decremented by
1.<a class="footnote" id="DOCF117" href="#FOOT117"><sup>117</sup></a>  This would be a terrible representation for
a sparse polynomial such as <em class="math">B</em>: There would be a giant list of zeros
punctuated by a few lonely nonzero terms.  A more reasonable representation of
the term list of a sparse polynomial is as a list of the nonzero terms, where
each term is a list containing the order of the term and the coefficient for
that order.  In such a scheme, polynomial <em class="math">B</em> is efficiently represented as
<code class="code">((100 1) (2 2) (0 1))</code>.  As most polynomial manipulations are performed
on sparse polynomials, we will use this method.  We will assume that term lists
are represented as lists of terms, arranged from highest-order to lowest-order
term.  Once we have made this decision, implementing the selectors and
constructors for terms and term lists is straightforward:<a class="footnote" id="DOCF118" href="#FOOT118"><sup>118</sup></a>
</p>
<div class="example">
<pre class="example-preformatted">impl Term {
    fn new(order: usize, coeff: f64) -&gt; Self {
        Term { order, coeff }
    }

    fn is_zero(&amp;self) -&gt; bool {
        self.coeff == 0.0
    }
}

fn adjoin_term(term: Term, mut term_list: Vec&lt;Term&gt;) -&gt; Vec&lt;Term&gt; {
    if !term.is_zero() {
        term_list.insert(0, term);
    }
    term_list
}

// Slice methods provide first_term, rest_terms, and is_empty:
// term_list.first()      -&gt; Option&lt;&amp;Term&gt;
// &amp;term_list[1..]        -&gt; &amp;[Term]  (rest)
// term_list.is_empty()   -&gt; bool
</pre></div>

<p>where <code class="code">=zero?</code> is as defined in <a class="ref" href="#Exercise-2_002e80">Exercise 2.80</a>.  (See also
<a class="ref" href="#Exercise-2_002e87">Exercise 2.87</a> below.)
</p>
<p>Users of the polynomial package will create (tagged) polynomials by means of
the procedure:
</p>
<div class="example">
<pre class="example-preformatted">fn make_polynomial(var: &amp;str, terms: Vec&lt;Term&gt;) -&gt; Poly {
    Poly::new(var, terms)
}
</pre></div>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-2_002e87"></a>Exercise 2.87:</strong> Install <code class="code">=zero?</code> for
polynomials in the generic arithmetic package.  This will allow
<code class="code">adjoin_term</code> to work for polynomials with coefficients that are
themselves polynomials.
</p></blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-2_002e88"></a>Exercise 2.88:</strong> Extend the polynomial system to
include subtraction of polynomials.  (Hint: You may find it helpful to define a
generic negation operation.)
</p></blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-2_002e89"></a>Exercise 2.89:</strong> Define procedures that implement
the term-list representation described above as appropriate for dense
polynomials.
</p></blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-2_002e90"></a>Exercise 2.90:</strong> Suppose we want to have a
polynomial system that is efficient for both sparse and dense polynomials.  One
way to do this is to allow both kinds of term-list representations in our
system.  The situation is analogous to the complex-number example of 
<a class="ref" href="2_002e4.xhtml#g_t2_002e4">Multiple Representations for Abstract Data</a>, where we allowed both rectangular and polar representations.  To do
this we must distinguish different types of term lists and make the operations
on term lists generic.  Redesign the polynomial system to implement this
generalization.  This is a major effort, not a local change.
</p></blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-2_002e91"></a>Exercise 2.91:</strong> A univariate polynomial can be
divided by another one to produce a polynomial quotient and a polynomial
remainder.  For example,
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
  <mrow data-mjx-texclass="ORD">
    <mfrac>
      <mrow>
        <msup>
          <mi>x</mi>
          <mn>5</mn>
        </msup>
        <mo>&#x2212;</mo>
        <mn>1</mn>
      </mrow>
      <mrow>
        <msup>
          <mi>x</mi>
          <mn>2</mn>
        </msup>
        <mo>&#x2212;</mo>
        <mn>1</mn>
      </mrow>
    </mfrac>
  </mrow>
  <mstyle scriptlevel="0">
    <mspace width="0.167em"></mspace>
  </mstyle>
  <mo>=</mo>
  <mstyle scriptlevel="0">
    <mspace width="0.167em"></mspace>
  </mstyle>
  <mrow data-mjx-texclass="ORD">
    <msup>
      <mi>x</mi>
      <mn>3</mn>
    </msup>
    <mo>+</mo>
    <mi>x</mi>
    <mo>,</mo>
  </mrow>
  <mtext>&#xA0;remainder&#xA0;</mtext>
  <mrow data-mjx-texclass="ORD">
    <mi>x</mi>
    <mo>&#x2212;</mo>
    <mn>1.</mn>
  </mrow>
</math>
Division can be performed via long division.  That is, divide the highest-order
term of the dividend by the highest-order term of the divisor.  The result is
the first term of the quotient.  Next, multiply the result by the divisor,
subtract that from the dividend, and produce the rest of the answer by
recursively dividing the difference by the divisor.  Stop when the order of the
divisor exceeds the order of the dividend and declare the dividend to be the
remainder.  Also, if the dividend ever becomes zero, return zero as both
quotient and remainder.
</p>
<p>We can design a <code class="code">div-poly</code> procedure on the model of <code class="code">add_poly</code> and
<code class="code">mul_poly</code>. The procedure checks to see if the two polys have the same
variable.  If so, <code class="code">div-poly</code> strips off the variable and passes the
problem to <code class="code">div-terms</code>, which performs the division operation on term
lists. <code class="code">Div-poly</code> finally reattaches the variable to the result supplied
by <code class="code">div-terms</code>.  It is convenient to design <code class="code">div-terms</code> to compute
both the quotient and the remainder of a division.  <code class="code">Div-terms</code> can take
two term lists as arguments and return a list of the quotient term list and the
remainder term list.
</p>
<p>Complete the following definition of <code class="code">div-terms</code> by filling in the missing
expressions.  Use this to implement <code class="code">div-poly</code>, which takes two polys as
arguments and returns a list of the quotient and remainder polys.
</p>
<div class="example">
<pre class="example-preformatted">fn div_terms(l1: &amp;[Term], l2: &amp;[Term]) -&gt; (Vec&lt;Term&gt;, Vec&lt;Term&gt;) {
    if l1.is_empty() {
        return (vec![], vec![]);
    }
    let t1 = &amp;l1[0];
    let t2 = &amp;l2[0];
    if t2.order &gt; t1.order {
        (vec![], l1.to_vec())
    } else {
        let new_c = t1.coeff / t2.coeff;
        let new_o = t1.order - t2.order;
        let new_term = Term::new(new_o, new_c);
        // <em class="emph">compute rest of result recursively</em>
        let subtracted = subtract_terms(
            l1,
            &amp;mul_term_by_all_terms(&amp;new_term, l2),
        );
        let (rest_quotient, remainder) = div_terms(&amp;subtracted, l2);
        // <em class="emph">form complete result</em>
        let mut quotient = vec![new_term];
        quotient.extend(rest_quotient);
        (quotient, remainder)
    }
}
</pre></div>
</blockquote>

<h4 class="subsubheading" id="Hierarchies-of-types-in-symbolic-algebra"><span>Hierarchies of types in symbolic algebra<a class="copiable-link" href="#Hierarchies-of-types-in-symbolic-algebra"> &#182;</a></span></h4>

<p>Our polynomial system illustrates how objects of one type (polynomials) may in
fact be complex objects that have objects of many different types as parts.
This poses no real difficulty in defining generic operations.  We need only
install appropriate generic operations for performing the necessary
manipulations of the parts of the compound types.  In fact, we saw that
polynomials form a kind of &#8220;recursive data abstraction,&#8221; in that parts of a
polynomial may themselves be polynomials.  Our generic operations and our
data-directed programming style can handle this complication without much
trouble.
</p>
<p>On the other hand, polynomial algebra is a system for which the data types
cannot be naturally arranged in a tower.  For instance, it is possible to have
polynomials in <em class="math">x</em> whose coefficients are polynomials in <em class="math">y</em>.  It is also
possible to have polynomials in <em class="math">y</em> whose coefficients are polynomials in
<em class="math">x</em>.  Neither of these types is &#8220;above&#8221; the other in any natural way, yet
it is often necessary to add together elements from each set.  There are
several ways to do this.  One possibility is to convert one polynomial to the
type of the other by expanding and rearranging terms so that both polynomials
have the same principal variable.  One can impose a towerlike structure on this
by ordering the variables and thus always converting any polynomial to a
&#8220;canonical form&#8221; with the highest-priority variable dominant and the
lower-priority variables buried in the coefficients.  This strategy works
fairly well, except that the conversion may expand a polynomial unnecessarily,
making it hard to read and perhaps less efficient to work with.  The tower
strategy is certainly not natural for this domain or for any domain where the
user can invent new types dynamically using old types in various combining
forms, such as trigonometric functions, power series, and integrals.
</p>
<p>It should not be surprising that controlling coercion is a serious problem in
the design of large-scale algebraic-manipulation systems.  Much of the
complexity of such systems is concerned with relationships among diverse types.
Indeed, it is fair to say that we do not yet completely understand coercion.
In fact, we do not yet completely understand the concept of a data type.
Nevertheless, what we know provides us with powerful structuring and modularity
principles to support the design of large systems.
</p>
<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-2_002e92"></a>Exercise 2.92:</strong> By imposing an ordering on
variables, extend the polynomial package so that addition and multiplication of
polynomials works for polynomials in different variables.  (This is not easy!)
</p></blockquote>

<h4 class="subsubheading" id="Extended-exercise_003a-Rational-functions"><span>Extended exercise: Rational functions<a class="copiable-link" href="#Extended-exercise_003a-Rational-functions"> &#182;</a></span></h4>

<p>We can extend our generic arithmetic system to include <a class="index-entry-id" id="index-rational-functions"></a>
<em class="dfn">rational functions</em>.  
These are &#8220;fractions&#8221; whose numerator and denominator are
polynomials, such as
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
  <mrow data-mjx-texclass="ORD">
    <mrow data-mjx-texclass="ORD">
      <mfrac>
        <mrow>
          <mi>x</mi>
          <mo>+</mo>
          <mn>1</mn>
        </mrow>
        <mrow>
          <msup>
            <mi>x</mi>
            <mn>3</mn>
          </msup>
          <mo>&#x2212;</mo>
          <mn>1</mn>
        </mrow>
      </mfrac>
    </mrow>
    <mo>.</mo>
  </mrow>
</math>
The system should be able to add, subtract, multiply, and divide rational
functions, and to perform such computations as
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
  <mrow data-mjx-texclass="ORD">
    <mfrac>
      <mrow>
        <mi>x</mi>
        <mo>+</mo>
        <mn>1</mn>
      </mrow>
      <mrow>
        <msup>
          <mi>x</mi>
          <mn>3</mn>
        </msup>
        <mo>&#x2212;</mo>
        <mn>1</mn>
      </mrow>
    </mfrac>
  </mrow>
  <mo>+</mo>
  <mrow data-mjx-texclass="ORD">
    <mfrac>
      <mi>x</mi>
      <mrow>
        <msup>
          <mi>x</mi>
          <mn>2</mn>
        </msup>
        <mo>&#x2212;</mo>
        <mn>1</mn>
      </mrow>
    </mfrac>
  </mrow>
  <mstyle scriptlevel="0">
    <mspace width="0.167em"></mspace>
  </mstyle>
  <mo>=</mo>
  <mstyle scriptlevel="0">
    <mspace width="0.167em"></mspace>
  </mstyle>
  <mrow data-mjx-texclass="ORD">
    <mrow data-mjx-texclass="ORD">
      <mfrac>
        <mrow>
          <msup>
            <mi>x</mi>
            <mn>3</mn>
          </msup>
          <mo>+</mo>
          <mn>2</mn>
          <msup>
            <mi>x</mi>
            <mn>2</mn>
          </msup>
          <mo>+</mo>
          <mn>3</mn>
          <mi>x</mi>
          <mo>+</mo>
          <mn>1</mn>
        </mrow>
        <mrow>
          <msup>
            <mi>x</mi>
            <mn>4</mn>
          </msup>
          <mo>+</mo>
          <msup>
            <mi>x</mi>
            <mn>3</mn>
          </msup>
          <mo>&#x2212;</mo>
          <mi>x</mi>
          <mo>&#x2212;</mo>
          <mn>1</mn>
        </mrow>
      </mfrac>
    </mrow>
    <mo>.</mo>
  </mrow>
</math>
(Here the sum has been simplified by removing common factors.  Ordinary &#8220;cross
multiplication&#8221; would have produced a fourth-degree polynomial over a
fifth-degree polynomial.)
</p>
<p>If we modify our rational-arithmetic package so that it uses generic
operations, then it will do what we want, except for the problem of reducing
fractions to lowest terms.
</p>
<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-2_002e93"></a>Exercise 2.93:</strong> Modify the rational-arithmetic
package to use generic operations, but change <code class="code">Rational::new</code> so that it does
not attempt to reduce fractions to lowest terms.  Test your system by calling
<code class="code">make-rational</code> on two polynomials to produce a rational function:
</p>
<div class="example">
<pre class="example-preformatted">let p1 = Poly::new(&quot;x&quot;, vec![Term::new(2, 1.0), Term::new(0, 1.0)]);
let p2 = Poly::new(&quot;x&quot;, vec![Term::new(3, 1.0), Term::new(0, 1.0)]);
let rf = RationalFn::new(p2, p1);
</pre></div>

<p>Now add <code class="code">rf</code> to itself, using <code class="code">add</code>. You will observe that this
addition procedure does not reduce fractions to lowest terms.
</p></blockquote>

<p>We can reduce polynomial fractions to lowest terms using the same idea we used
with integers: modifying <code class="code">Rational::new</code> to divide both the numerator and the
denominator by their greatest common divisor.  The notion of &#8220;greatest common
divisor&#8221; makes sense for polynomials.  In fact, we can compute the
<abbr class="abbr">GCD</abbr> of two polynomials using essentially the same Euclid&#8217;s Algorithm
that works for integers.<a class="footnote" id="DOCF119" href="#FOOT119"><sup>119</sup></a>  The integer version is
</p>
<div class="example">
<pre class="example-preformatted">fn gcd(a: i64, b: i64) -&gt; i64 {
    if b == 0 {
        a
    } else {
        gcd(b, a % b)
    }
}
</pre></div>

<p>Using this, we could make the obvious modification to define a <abbr class="abbr">GCD</abbr>
operation that works on term lists:
</p>
<div class="example">
<pre class="example-preformatted">fn gcd_terms(a: &amp;[Term], b: &amp;[Term]) -&gt; Vec&lt;Term&gt; {
    if b.is_empty() {
        a.to_vec()
    } else {
        let (_, remainder) = div_terms(a, b);
        gcd_terms(b, &amp;remainder)
    }
}
</pre></div>

<p>where <code class="code">remainder-terms</code> picks out the remainder component of the list
returned by the term-list division operation <code class="code">div-terms</code> that was
implemented in <a class="ref" href="#Exercise-2_002e91">Exercise 2.91</a>.
</p>
<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-2_002e94"></a>Exercise 2.94:</strong> Using <code class="code">div-terms</code>, implement
the procedure <code class="code">remainder-terms</code> and use this to define <code class="code">gcd-terms</code> as
above.  Now write a procedure <code class="code">gcd-poly</code> that computes the polynomial
<abbr class="abbr">GCD</abbr> of two polys.  (The procedure should signal an error if the two
polys are not in the same variable.)  Install in the system a generic operation
<code class="code">greatest-common-divisor</code> that reduces to <code class="code">gcd-poly</code> for polynomials
and to ordinary <code class="code">gcd</code> for ordinary numbers.  As a test, try
</p>
<div class="example">
<pre class="example-preformatted">let p1 = Poly::new(&quot;x&quot;, vec![
    Term::new(4, 1.0), Term::new(3, -1.0),
    Term::new(2, -2.0), Term::new(1, 2.0),
]);

let p2 = Poly::new(&quot;x&quot;, vec![
    Term::new(3, 1.0), Term::new(1, -1.0),
]);

let result = gcd_poly(&amp;p1, &amp;p2);
</pre></div>

<p>and check your result by hand.
</p></blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-2_002e95"></a>Exercise 2.95:</strong> Define <em class="math">P_1</em>, <em class="math">P_2</em>, and
<em class="math">P_3</em> to be the polynomials
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
  <mtable columnalign="right left" columnspacing="1em" rowspacing="4pt">
    <mtr>
      <mtd>
        <msub>
          <mi>P</mi>
          <mn>1</mn>
        </msub>
        <mo>:</mo>
      </mtd>
      <mtd>
        <mi>a</mi>
        <mi>m</mi>
        <mi>p</mi>
        <mo>;</mo>
        <msup>
          <mi>x</mi>
          <mn>2</mn>
        </msup>
        <mo>&#x2212;</mo>
        <mn>2</mn>
        <mi>x</mi>
        <mo>+</mo>
        <mn>1</mn>
        <mo>,</mo>
      </mtd>
    </mtr>
    <mtr>
      <mtd>
        <msub>
          <mi>P</mi>
          <mn>2</mn>
        </msub>
        <mo>:</mo>
      </mtd>
      <mtd>
        <mi>a</mi>
        <mi>m</mi>
        <mi>p</mi>
        <mo>;</mo>
        <mn>11</mn>
        <msup>
          <mi>x</mi>
          <mn>2</mn>
        </msup>
        <mo>+</mo>
        <mn>7</mn>
        <mo>,</mo>
      </mtd>
    </mtr>
    <mtr>
      <mtd>
        <msub>
          <mi>P</mi>
          <mn>3</mn>
        </msub>
        <mo>:</mo>
      </mtd>
      <mtd>
        <mi>a</mi>
        <mi>m</mi>
        <mi>p</mi>
        <mo>;</mo>
        <mn>13</mn>
        <mi>x</mi>
        <mo>+</mo>
        <mn>5.</mn>
      </mtd>
    </mtr>
  </mtable>
</math>
Now define <em class="math">Q_1</em> to be the product of <em class="math">P_1</em> and <em class="math">P_2</em>, and <em class="math">Q_2</em> to be
the product of <em class="math">P_1</em> and <em class="math">P_3</em>, and use <code class="code">greatest-common-divisor</code>
(<a class="ref" href="#Exercise-2_002e94">Exercise 2.94</a>) to compute the <abbr class="abbr">GCD</abbr> of <em class="math">Q_1</em> and <em class="math">Q_2</em>.
Note that the answer is not the same as <em class="math">P_1</em>.  This example introduces
noninteger operations into the computation, causing difficulties with the
<abbr class="abbr">GCD</abbr> algorithm.<a class="footnote" id="DOCF120" href="#FOOT120"><sup>120</sup></a>  To understand what is happening, try tracing
<code class="code">gcd-terms</code> while computing the <abbr class="abbr">GCD</abbr> or try performing the
division by hand.
</p></blockquote>

<p>We can solve the problem exhibited in <a class="ref" href="#Exercise-2_002e95">Exercise 2.95</a> if we use the
following modification of the <abbr class="abbr">GCD</abbr> algorithm (which really works only
in the case of polynomials with integer coefficients).  Before performing any
polynomial division in the <abbr class="abbr">GCD</abbr> computation, we multiply the dividend
by an integer constant factor, chosen to guarantee that no fractions will arise
during the division process.  Our answer will thus differ from the actual
<abbr class="abbr">GCD</abbr> by an integer constant factor, but this does not matter in the
case of reducing rational functions to lowest terms; the <abbr class="abbr">GCD</abbr> will be
used to divide both the numerator and denominator, so the integer constant
factor will cancel out.
</p>
<p>More precisely, if <em class="math">P</em> and <em class="math">Q</em> are polynomials, let <em class="math">O_1</em> be the order of
<em class="math">P</em> (i.e., the order of the largest term of <em class="math">P</em>) and let <em class="math">O_2</em> be the
order of <em class="math">Q</em>.  Let <em class="math">c</em> be the leading coefficient of <em class="math">Q</em>.  Then it can be
shown that, if we multiply <em class="math">P</em> by the <a class="index-entry-id" id="index-integerizing-factor"></a>
<em class="dfn">integerizing<!-- /@w --> factor<!-- /@w --></em>
<em class="math">c^{1 + O_1 - O_2}</em>, the resulting polynomial can be divided by <em class="math">Q</em> by
using the <code class="code">div-terms</code> algorithm without introducing any fractions.  The
operation of multiplying the dividend by this constant and then dividing is
sometimes called the <a class="index-entry-id" id="index-pseudodivision"></a>
<em class="dfn">pseudodivision</em> of <em class="math">P</em> by <em class="math">Q</em>.  The remainder
of the division is called the <a class="index-entry-id" id="index-pseudoremainder"></a>
<em class="dfn">pseudoremainder</em>.
</p>
<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-2_002e96"></a>Exercise 2.96:</strong>
</p><ol class="enumerate" type="a" start="1">
<li> Implement the procedure <code class="code">pseudoremainder-terms</code>, which is just like
<code class="code">remainder-terms</code> except that it multiplies the dividend by the
integerizing factor described above before calling <code class="code">div-terms</code>.  Modify
<code class="code">gcd-terms</code> to use <code class="code">pseudoremainder-terms</code>, and verify that
<code class="code">greatest-common-divisor</code> now produces an answer with integer coefficients
on the example in <a class="ref" href="#Exercise-2_002e95">Exercise 2.95</a>.

</li><li> The <abbr class="abbr">GCD</abbr> now has integer coefficients, but they are larger than those
of <em class="math">P_1</em>.  Modify <code class="code">gcd-terms</code> so that it removes common factors from the
coefficients of the answer by dividing all the coefficients by their (integer)
greatest common divisor.

</li></ol>
</blockquote>

<p>Thus, here is how to reduce a rational function to lowest terms:
</p>
<ul class="itemize mark-bullet">
<li>Compute the <abbr class="abbr">GCD</abbr> of the numerator and denominator, using the version
of <code class="code">gcd-terms</code> from <a class="ref" href="#Exercise-2_002e96">Exercise 2.96</a>.

</li><li>When you obtain the <abbr class="abbr">GCD</abbr>, multiply both numerator and denominator by
the same integerizing factor before dividing through by the <abbr class="abbr">GCD</abbr>, so
that division by the <abbr class="abbr">GCD</abbr> will not introduce any noninteger
coefficients.  As the factor you can use the leading coefficient of the
<abbr class="abbr">GCD</abbr> raised to the power <em class="math">{1 + O_1 - O_2}</em>, where <em class="math">O_2</em> is the
order of the <abbr class="abbr">GCD</abbr> and <em class="math">O_1</em> is the maximum of the orders of the
numerator and denominator.  This will ensure that dividing the numerator and
denominator by the <abbr class="abbr">GCD</abbr> will not introduce any fractions.

</li><li>The result of this operation will be a numerator and denominator with integer
coefficients.  The coefficients will normally be very large because of all of
the integerizing factors, so the last step is to remove the redundant factors
by computing the (integer) greatest common divisor of all the coefficients of
the numerator and the denominator and dividing through by this factor.

</li></ul>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-2_002e97"></a>Exercise 2.97:</strong>
</p><ol class="enumerate" type="a" start="1">
<li> Implement this algorithm as a procedure <code class="code">reduce-terms</code> that takes two term
lists <code class="code">n</code> and <code class="code">d</code> as arguments and returns a list <code class="code">nn</code>,
<code class="code">dd</code>, which are <code class="code">n</code> and <code class="code">d</code> reduced to lowest terms via the
algorithm given above.  Also write a procedure <code class="code">reduce-poly</code>, analogous to
<code class="code">add_poly</code>, that checks to see if the two polys have the same variable.
If so, <code class="code">reduce-poly</code> strips off the variable and passes the problem to
<code class="code">reduce-terms</code>, then reattaches the variable to the two term lists
supplied by <code class="code">reduce-terms</code>.

</li><li> Define a procedure analogous to <code class="code">reduce-terms</code> that does what the original
<code class="code">Rational::new</code> did for integers:

<div class="example">
<pre class="example-preformatted">fn reduce_integers(n: i64, d: i64) -&gt; (i64, i64) {
    let g = gcd(n, d);
    (n / g, d / g)
}
</pre></div>

<p>and define <code class="code">reduce</code> as a generic operation that calls <code class="code">apply-generic</code>
to dispatch to either <code class="code">reduce-poly</code> (for <code class="code">polynomial</code> arguments) or
<code class="code">reduce-integers</code> (for <code class="code">SchemeNumber</code> arguments).  You can now
easily make the rational-arithmetic package reduce fractions to lowest terms by
having <code class="code">Rational::new</code> call <code class="code">reduce</code> before combining the given numerator
and denominator to form a rational number.  The system now handles rational
expressions in either integers or polynomials.  To test your program, try the
example at the beginning of this extended exercise:
</p>
<div class="example">
<pre class="example-preformatted">let p1 = Poly::new(&quot;x&quot;, vec![Term::new(1, 1.0), Term::new(0, 1.0)]);
let p2 = Poly::new(&quot;x&quot;, vec![Term::new(3, 1.0), Term::new(0, -1.0)]);
let p3 = Poly::new(&quot;x&quot;, vec![Term::new(1, 1.0)]);
let p4 = Poly::new(&quot;x&quot;, vec![Term::new(2, 1.0), Term::new(0, -1.0)]);
let rf1 = RationalFn::new(p1, p2);
let rf2 = RationalFn::new(p3, p4);
let result = rf1 + rf2;
</pre></div>

<p>See if you get the correct answer, correctly reduced to lowest terms.
</p></li></ol>
</blockquote>

<p>The <abbr class="abbr">GCD</abbr> computation is at the heart of any system that does
operations on rational functions.  The algorithm used above, although
mathematically straightforward, is extremely slow.  The slowness is due partly
to the large number of division operations and partly to the enormous size of
the intermediate coefficients generated by the pseudodivisions.  One of the
active areas in the development of algebraic-manipulation systems is the design
of better algorithms for computing polynomial <abbr class="abbr">GCD</abbr>s.<a class="footnote" id="DOCF121" href="#FOOT121"><sup>121</sup></a>
</p>

</div>
</div>
<div class="footnotes-segment">
<hr />
<h4 class="footnotes-heading">Footnotes</h4>

<h5 class="footnote-body-heading"><a id="FOOT108" href="#DOCF108">(108)</a></h5>
<p>We also have
to supply an almost identical procedure to handle the types
<code class="code">(scheme-number complex)</code>.</p>
<h5 class="footnote-body-heading"><a id="FOOT109" href="#DOCF109">(109)</a></h5>
<p>See <a class="ref" href="#Exercise-2_002e82">Exercise 2.82</a> for generalizations.</p>
<h5 class="footnote-body-heading"><a id="FOOT110" href="#DOCF110">(110)</a></h5>
<p>If we are clever, we can usually get by with fewer
than <em class="math">n^2</em> coercion procedures.  For instance, if we know how to convert from
type 1 to type 2 and from type 2 to type 3, then we can use this knowledge to
convert from type 1 to type 3.  This can greatly decrease the number of
coercion procedures we need to supply explicitly when we add a new type to the
system.  If we are willing to build the required amount of sophistication into
our system, we can have it search the &#8220;graph&#8221; of relations among types and
automatically generate those coercion procedures that can be inferred from the
ones that are supplied explicitly.</p>
<h5 class="footnote-body-heading"><a id="FOOT111" href="#DOCF111">(111)</a></h5>
<p>This statement,
which also appears in the first edition of this book, is just as true now as it
was when we wrote it twelve years ago.  Developing a useful, general framework
for expressing the relations among different types of entities (what
philosophers call &#8220;ontology&#8221;) seems intractably difficult.  The main
difference between the confusion that existed ten years ago and the confusion
that exists now is that now a variety of inadequate ontological theories have
been embodied in a plethora of correspondingly inadequate programming
languages.  For example, much of the complexity of object-oriented programming
languages&#8212;and the subtle and confusing differences among contemporary
object-oriented languages&#8212;centers on the treatment of generic operations on
interrelated types.  Our own discussion of computational objects in
<a class="ref" href="Chapter-3.xhtml">Modularity, Objects, and State</a> avoids these issues entirely.  Readers familiar with
object-oriented programming will notice that we have much to say in
chapter 3 about local state, but we do not even mention &#8220;classes&#8221; or
&#8220;inheritance.&#8221;  In fact, we suspect that these problems cannot be adequately
addressed in terms of computer-language design alone, without also drawing on
work in knowledge representation and automated reasoning.</p>
<h5 class="footnote-body-heading"><a id="FOOT112" href="#DOCF112">(112)</a></h5>
<p>A real number can be projected to an integer using the
<code class="code">round</code> primitive, which returns the closest integer to its argument.</p>
<h5 class="footnote-body-heading"><a id="FOOT113" href="#DOCF113">(113)</a></h5>
<p>On the other hand,
we will allow polynomials whose coefficients are themselves polynomials in
other variables.  This will give us essentially the same representational power
as a full multivariate system, although it does lead to coercion problems, as
discussed below.</p>
<h5 class="footnote-body-heading"><a id="FOOT114" href="#DOCF114">(114)</a></h5>
<p>For univariate polynomials, giving the value of a polynomial
at a given set of points can be a particularly good representation.  This makes
polynomial arithmetic extremely simple.  To obtain, for example, the sum of two
polynomials represented in this way, we need only add the values of the
polynomials at corresponding points.  To transform back to a more familiar
representation, we can use the Lagrange interpolation formula, which shows how
to recover the coefficients of a polynomial of degree <em class="math">n</em> given the values of
the polynomial at <em class="math">{n + 1}</em> points.</p>
<h5 class="footnote-body-heading"><a id="FOOT115" href="#DOCF115">(115)</a></h5>
<p>This operation is very much like the ordered
<code class="code">union_set</code> operation we developed in <a class="ref" href="2_002e3.xhtml#Exercise-2_002e62">Exercise 2.62</a>.  In
fact, if we think of the terms of the polynomial as a set ordered according to
the power of the indeterminate, then the program that produces the term list
for a sum is almost identical to <code class="code">union_set</code>.</p>
<h5 class="footnote-body-heading"><a id="FOOT116" href="#DOCF116">(116)</a></h5>
<p>To make this
work completely smoothly, we should also add to our generic arithmetic system
the ability to coerce a &#8220;number&#8221; to a polynomial by regarding it as a
polynomial of degree zero whose coefficient is the number.  This is necessary
if we are going to perform operations such as
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
  <mrow data-mjx-texclass="ORD">
    <mo stretchy="false">[</mo>
    <msup>
      <mi>x</mi>
      <mn>2</mn>
    </msup>
    <mo>+</mo>
    <mo stretchy="false">(</mo>
    <mi>y</mi>
    <mo>+</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
    <mi>x</mi>
    <mo>+</mo>
    <mn>5</mn>
    <mo stretchy="false">]</mo>
  </mrow>
  <mo>+</mo>
  <mrow data-mjx-texclass="ORD">
    <mo stretchy="false">[</mo>
    <msup>
      <mi>x</mi>
      <mn>2</mn>
    </msup>
    <mo>+</mo>
    <mn>2</mn>
    <mi>x</mi>
    <mo>+</mo>
    <mn>1</mn>
    <mo stretchy="false">]</mo>
    <mo>,</mo>
  </mrow>
</math>
which requires adding the coefficient <em class="math">{y + 1}</em> to the coefficient 2.</p>
<h5 class="footnote-body-heading"><a id="FOOT117" href="#DOCF117">(117)</a></h5>
<p>In these polynomial examples, we assume that we have implemented
the generic arithmetic system using the type mechanism suggested in
<a class="ref" href="#Exercise-2_002e78">Exercise 2.78</a>.  Thus, coefficients that are ordinary numbers will be
represented as the numbers themselves rather than as pairs whose <code class="code">car</code> is
the symbol <code class="code">SchemeNumber</code>.</p>
<h5 class="footnote-body-heading"><a id="FOOT118" href="#DOCF118">(118)</a></h5>
<p>Although we
are assuming that term lists are ordered, we have implemented
<code class="code">adjoin_term</code> to simply <code class="code">cons</code> the new term onto the existing term
list.  We can get away with this so long as we guarantee that the procedures
(such as <code class="code">add-terms</code>) that use <code class="code">adjoin_term</code> always call it with a
higher-order term than appears in the list.  If we did not want to make such a
guarantee, we could have implemented <code class="code">adjoin_term</code> to be similar to the
<code class="code">adjoin_set</code> constructor for the ordered-list representation of sets
(<a class="ref" href="2_002e3.xhtml#Exercise-2_002e61">Exercise 2.61</a>).</p>
<h5 class="footnote-body-heading"><a id="FOOT119" href="#DOCF119">(119)</a></h5>
<p>The fact that Euclid&#8217;s Algorithm works for
polynomials is formalized in algebra by saying that polynomials form a kind of
algebraic domain called a <a class="index-entry-id" id="index-Euclidean-ring"></a>
<em class="dfn">Euclidean ring</em>.  A Euclidean ring is a
domain that admits addition, subtraction, and commutative multiplication,
together with a way of assigning to each element <em class="math">x</em> of the ring a positive
integer &#8220;measure&#8221; <em class="math">{m(x)}</em> with the properties that 
<em class="math">{m(xy) \ge m(x)}</em> for any nonzero <em class="math">x</em> and <em class="math">y</em> and that, given any <em class="math">x</em> and
<em class="math">y</em>, there exists a <em class="math">q</em> such that <em class="math">{y = qx + r}</em> and either
<em class="math">{r = 0}</em> or <em class="math">{m(r) &lt; m(x)}</em>.  From an abstract point of view, this
is what is needed to prove that Euclid&#8217;s Algorithm works.  For the domain of
integers, the measure <em class="math">m</em> of an integer is the absolute value of the integer
itself.  For the domain of polynomials, the measure of a polynomial is its
degree.</p>
<h5 class="footnote-body-heading"><a id="FOOT120" href="#DOCF120">(120)</a></h5>
<p>In an implementation like <abbr class="abbr">MIT</abbr>
Scheme, this produces a polynomial that is indeed a divisor of <em class="math">Q_1</em> and
<em class="math">Q_2</em>, but with rational coefficients.  In many other Scheme systems, in
which division of integers can produce limited-precision decimal numbers, we
may fail to get a valid divisor.</p>
<h5 class="footnote-body-heading"><a id="FOOT121" href="#DOCF121">(121)</a></h5>
<p>One
extremely efficient and elegant method for computing polynomial <abbr class="abbr">GCD</abbr>s
was discovered by Richard <a class="ref" href="References.xhtml#Zippel-_00281979_0029">Zippel (1979)</a>.  The method is a probabilistic
algorithm, as is the fast test for primality that we discussed in <a class="ref" href="Chapter-1.xhtml">Building Abstractions with Procedures</a>.  Zippel&#8217;s book (<a class="ref" href="References.xhtml#Zippel-1993">Zippel 1993</a>) describes this method, together with other ways to
compute polynomial <abbr class="abbr">GCD</abbr>s.</p>
</div>
<hr />
<div class="nav-panel">
<p>
Next: <a href="Chapter-3.xhtml" accesskey="n" rel="next">Modularity, Objects, and State</a>, Previous: <a href="2_002e4.xhtml#g_t2_002e4_002e3a" accesskey="p" rel="prev">Traits as Interfaces: Static and Dynamic Dispatch</a>, Up: <a href="Chapter-2.xhtml" accesskey="u" rel="up">Building Abstractions with Data</a> &#160; [<a href="index.xhtml#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Term-Index.xhtml" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
