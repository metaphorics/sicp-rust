<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<!-- Created by GNU Texinfo 7.1, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>3.2 (Structure and Interpretation of Computer Programs, 2e)</title>

<meta name="description" content="3.2 (Structure and Interpretation of Computer Programs, 2e)" />
<meta name="keywords" content="3.2 (Structure and Interpretation of Computer Programs, 2e)" />
<meta name="resource-type" content="document" />
<meta name="distribution" content="global" />
<meta name="Generator" content="texi2any" />
<meta name="viewport" content="width=device-width,initial-scale=1" />

<link href="index.xhtml" rel="start" title="Top" />
<link href="Term-Index.xhtml" rel="index" title="Term Index" />
<link href="index.xhtml#SEC_Contents" rel="contents" title="Table of Contents" />
<link href="Chapter-3.xhtml" rel="up" title="Chapter 3" />
<link href="3_002e3.xhtml#g_t3_002e3" rel="next" title="3.3" />
<link href="3_002e1.xhtml#g_t3_002e1_002e4" rel="prev" title="3.1.4" />
<style type="text/css">
<!--
a.copiable-link {visibility: hidden; text-decoration: none; line-height: 0em}
div.example {margin-left: 3.2em}
span:hover a.copiable-link {visibility: visible}
ul.mark-bullet {list-style-type: disc}
-->
</style>
<link href="css/style.css" rel="stylesheet" type="text/css" />
<link href="css/prettify.css" rel="stylesheet" type="text/css" />
<script src="js/highlight/prettify.js" type="text/javascript"></script>
<script src="js/highlight/lang-lisp.js" type="text/javascript"></script>
<script src="js/highlight/lang-rust.js" type="text/javascript"></script>
</head>

<body lang="en">
<div class="section-level-extent" id="g_t3_002e2">
<div class="nav-panel">
<p>
Next: <a href="3_002e3.xhtml#g_t3_002e3" accesskey="n" rel="next">Modeling with Mutable Data</a>, Previous: <a href="3_002e1.xhtml#g_t3_002e1_002e4" accesskey="p" rel="prev">The Borrow Checker as Guardian</a>, Up: <a href="Chapter-3.xhtml" accesskey="u" rel="up">Modularity, Objects, and State</a> &#160; [<a href="index.xhtml#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Term-Index.xhtml" title="Index" rel="index">Index</a>]</p>
</div>
<h3 class="section" id="The-Environment-Model-of-Evaluation"><span>3.2 The Environment Model of Evaluation<a class="copiable-link" href="#The-Environment-Model-of-Evaluation"> &#182;</a></span></h3>

<p>When we introduced compound procedures in <a class="ref" href="Chapter-1.xhtml">Building Abstractions with Procedures</a>, we used the
substitution model of evaluation (<a class="ref" href="1_002e1.xhtml#g_t1_002e1_002e5">The Substitution Model for Procedure Application</a>) to define what is meant
by applying a procedure to arguments:
</p>
<ul class="itemize mark-bullet">
<li>To apply a compound procedure to arguments, evaluate the body of the procedure
with each formal parameter replaced by the corresponding argument.

</li></ul>

<p>Once we admit assignment into our programming language, such a definition is no
longer adequate.  In particular, <a class="ref" href="3_002e1.xhtml#g_t3_002e1_002e3">The Costs of Introducing Assignment</a> argued that, in the
presence of assignment, a variable can no longer be considered to be merely a
name for a value.  Rather, a variable must somehow designate a &#8220;place&#8221; in
which values can be stored.  In our new model of evaluation, these places will
be maintained in structures called <a class="index-entry-id" id="index-environments"></a>
<em class="dfn">environments</em>.
</p>
<p>An environment is a sequence of <a class="index-entry-id" id="index-frames"></a>
<em class="dfn">frames</em>.  Each frame is a table
(possibly empty) of <a class="index-entry-id" id="index-bindings"></a>
<em class="dfn">bindings</em>, which associate variable names with
their corresponding values.  (A single frame may contain at most one binding
for any variable.)  Each frame also has a pointer to its <a class="index-entry-id" id="index-enclosing-environment"></a>
<em class="dfn">enclosing environment</em>, 
unless, for the purposes of discussion, the frame is considered
to be <a class="index-entry-id" id="index-global-1"></a>
<em class="dfn">global</em>.  The <a class="index-entry-id" id="index-value-of-a-variable"></a>
<em class="dfn">value of a variable</em> with respect to an
environment is the value given by the binding of the variable in the first
frame in the environment that contains a binding for that variable.  If no
frame in the sequence specifies a binding for the variable, then the variable
is said to be <a class="index-entry-id" id="index-unbound"></a>
<em class="dfn">unbound</em> in the environment.
</p>
<p><a class="ref" href="#Figure-3_002e1">Figure 3.1</a> shows a simple environment structure consisting of three
frames, labeled I, II, and III.  In the diagram, A, B, C, and D are pointers to
environments.  C and D point to the same environment.  The variables <code class="code">z</code>
and <code class="code">x</code> are bound in frame II, while <code class="code">y</code> and <code class="code">x</code> are bound in
frame I.  The value of <code class="code">x</code> in environment D is 3.  The value of <code class="code">x</code>
with respect to environment B is also 3.  This is determined as follows: We
examine the first frame in the sequence (frame III) and do not find a binding
for <code class="code">x</code>, so we proceed to the enclosing environment D and find the binding
in frame I.  On the other hand, the value of <code class="code">x</code> in environment A is 7,
because the first frame in the sequence (frame II) contains a binding of
<code class="code">x</code> to 7.  With respect to environment A, the binding of <code class="code">x</code> to 7 in
frame II is said to <a class="index-entry-id" id="index-shadow"></a>
<em class="dfn">shadow</em> the binding of <code class="code">x</code> to 3 in frame I.
</p>
<div class="float">
<a class="anchor" id="Figure-3_002e1"></a><img class="image" src="fig/chap3/Fig3.1b.std.svg" alt="fig/chap3/Fig3.1b" />
<div class="caption"><p><strong class="strong">Figure 3.1:</strong> A simple environment structure.</p></div></div>
<p>The environment is crucial to the evaluation process, because it determines the
context in which an expression should be evaluated.  Indeed, one could say that
expressions in a programming language do not, in themselves, have any meaning.
Rather, an expression acquires a meaning only with respect to some environment
in which it is evaluated.  Even the interpretation of an expression as
straightforward as <code class="code">(+ 1 1)</code> depends on an understanding that one is
operating in a context in which <code class="code">+</code> is the symbol for addition.  Thus, in
our model of evaluation we will always speak of evaluating an expression with
respect to some environment.  To describe interactions with the interpreter, we
will suppose that there is a global environment, consisting of a single frame
(with no enclosing environment) that includes values for the symbols associated
with the primitive procedures.  For example, the idea that <code class="code">+</code> is the
symbol for addition is captured by saying that the symbol <code class="code">+</code> is bound in
the global environment to the primitive addition procedure.
</p>

<hr />
<div class="subsection-level-extent" id="g_t3_002e2_002e1">
<h4 class="subsection" id="The-Rules-for-Evaluation"><span>3.2.1 The Rules for Evaluation<a class="copiable-link" href="#The-Rules-for-Evaluation"> &#182;</a></span></h4>

<p>The overall specification of how the interpreter evaluates a combination
remains the same as when we first introduced it in <a class="ref" href="1_002e1.xhtml#g_t1_002e1_002e3">Evaluating Combinations</a>:
</p>
<ul class="itemize mark-bullet">
<li>To evaluate a combination:

</li></ul>

<ol class="enumerate">
<li> Evaluate the subexpressions of the combination.<a class="footnote" id="DOCF133" href="#FOOT133"><sup>133</sup></a>

</li><li> Apply the value of the operator subexpression to the values of the operand
subexpressions.

</li></ol>

<p>The environment model of evaluation replaces the substitution model in
specifying what it means to apply a compound procedure to arguments.
</p>
<p>In the environment model of evaluation, a procedure is always a pair consisting
of some code and a pointer to an environment.  Procedures are created in one
way only: by evaluating a closure expression.  This produces a procedure
whose code is obtained from the text of the closure expression and whose
environment is the environment in which the closure expression was
evaluated to produce the procedure.  For example, consider the procedure
definition
</p>
<div class="example">
<pre class="example-preformatted">fn square(x: i64) -&gt; i64 {
    x * x
}
</pre></div>

<p>evaluated in the global environment.  In Rust, function definitions create
function items.  An equivalent form using closures would be:
</p>
<div class="example">
<pre class="example-preformatted">let square = |x: i64| -&gt; i64 { x * x };
</pre></div>

<p>which evaluates <code class="code">|x| x * x</code> and binds <code class="code">square</code> to the
resulting value, all in the global environment.
</p>
<p><a class="ref" href="#Figure-3_002e2">Figure 3.2</a> shows the result of evaluating this definition expression.
The procedure object is a pair whose code specifies that the procedure has one
formal parameter, namely <code class="code">x</code>, and a procedure body <code class="code">(* x x)</code>.  The
environment part of the procedure is a pointer to the global environment, since
that is the environment in which the closure expression was evaluated to
produce the procedure. A new binding, which associates the procedure object
with the symbol <code class="code">square</code>, has been added to the global frame.  In general,
definition creates definitions by adding bindings to frames.
</p>
<div class="float">
<a class="anchor" id="Figure-3_002e2"></a><img class="image" src="fig/chap3/Fig3.2b.std.svg" alt="fig/chap3/Fig3.2b" />
<div class="caption"><p><strong class="strong">Figure 3.2:</strong> Environment structure produced by evaluating <code class="code">fn square(x: i64) -&gt; i64 { x * x }</code> in the global environment.</p></div></div>
<p>Now that we have seen how procedures are created, we can describe how
procedures are applied.  The environment model specifies: To apply a procedure
to arguments, create a new environment containing a frame that binds the
parameters to the values of the arguments.  The enclosing environment of this
frame is the environment specified by the procedure.  Now, within this new
environment, evaluate the procedure body.
</p>
<p>To show how this rule is followed, <a class="ref" href="#Figure-3_002e3">Figure 3.3</a> illustrates the environment
structure created by evaluating the expression <code class="code">square(5)</code> in the global
environment, where <code class="code">square</code> is the procedure generated in <a class="ref" href="#Figure-3_002e2">Figure 3.2</a>.  
Applying the procedure results in the creation of a new environment,
labeled E1 in the figure, that begins with a frame in which <code class="code">x</code>, the
formal parameter for the procedure, is bound to the argument 5.  The pointer
leading upward from this frame shows that the frame&#8217;s enclosing environment is
the global environment.  The global environment is chosen here, because this is
the environment that is indicated as part of the <code class="code">square</code> procedure
object.  Within E1, we evaluate the body of the procedure, <code class="code">(* x x)</code>.
Since the value of <code class="code">x</code> in E1 is 5, the result is <code class="code">(* 5 5)</code>, or 25.
</p>
<div class="float">
<a class="anchor" id="Figure-3_002e3"></a><img class="image" src="fig/chap3/Fig3.3b.std.svg" alt="fig/chap3/Fig3.3b" />
<div class="caption"><p><strong class="strong">Figure 3.3:</strong> Environment created by evaluating <code class="code">square(5)</code> in the global environment.</p></div></div>
<p>The environment model of procedure application can be summarized by two rules:
</p>
<ul class="itemize mark-bullet">
<li>A procedure object is applied to a set of arguments by constructing a frame,
binding the formal parameters of the procedure to the arguments of the call,
and then evaluating the body of the procedure in the context of the new
environment constructed.  The new frame has as its enclosing environment the
environment part of the procedure object being applied.

</li><li>A procedure is created by evaluating a closure expression relative to a
given environment.  The resulting procedure object is a pair consisting of the
text of the closure expression and a pointer to the environment in which
the procedure was created.

</li></ul>

<p>We also specify that defining a symbol using definition creates a binding in
the current environment frame and assigns to the symbol the indicated
value.<a class="footnote" id="DOCF134" href="#FOOT134"><sup>134</sup></a> Finally, we
specify the behavior of <code class="code">set!</code>, the operation that forced us to introduce
the environment model in the first place.  Evaluating the expression
<code class="code">(set! ⟨<var class="var">variable</var>⟩ ⟨<var class="var">value</var>⟩)</code> in some environment locates the
binding of the variable in the environment and changes that binding to indicate
the new value.  That is, one finds the first frame in the environment that
contains a binding for the variable and modifies that frame.  If the variable
is unbound in the environment, then <code class="code">set!</code> signals an error.
</p>
<p>These evaluation rules, though considerably more complex than the substitution
model, are still reasonably straightforward.  Moreover, the evaluation model,
though abstract, provides a correct description of how the interpreter
evaluates expressions.  In <a class="ref" href="Chapter-4.xhtml">Metalinguistic Abstraction</a> we shall see how this model can
serve as a blueprint for implementing a working interpreter.  The following
sections elaborate the details of the model by analyzing some illustrative
programs.
</p>
<hr />
</div>
<div class="subsection-level-extent" id="g_t3_002e2_002e2">
<h4 class="subsection" id="Applying-Simple-Procedures"><span>3.2.2 Applying Simple Procedures<a class="copiable-link" href="#Applying-Simple-Procedures"> &#182;</a></span></h4>

<p>When we introduced the substitution model in <a class="ref" href="1_002e1.xhtml#g_t1_002e1_002e5">The Substitution Model for Procedure Application</a> we showed how
the combination <code class="code">f(5)</code> evaluates to 136, given the following procedure
definitions:
</p>
<div class="example">
<pre class="example-preformatted">fn square(x: i64) -&gt; i64 {
    x * x
}

fn sum_of_squares(x: i64, y: i64) -&gt; i64 {
    square(x) + square(y)
}

fn f(a: i64) -&gt; i64 {
    sum_of_squares(a + 1, a * 2)
}
</pre></div>

<p>We can analyze the same example using the environment model.  <a class="ref" href="#Figure-3_002e4">Figure 3.4</a>
shows the three procedure objects created by evaluating the definitions of
<code class="code">f</code>, <code class="code">square</code>, and <code class="code">sum_of_squares</code> in the global environment.
Each procedure object consists of some code, together with a pointer to the
global environment.
</p>
<div class="float">
<a class="anchor" id="Figure-3_002e4"></a><img class="image" src="fig/chap3/Fig3.4b.std.svg" alt="fig/chap3/Fig3.4b" />
<div class="caption"><p><strong class="strong">Figure 3.4:</strong> Procedure objects in the global frame.</p></div></div>
<p>In <a class="ref" href="#Figure-3_002e5">Figure 3.5</a> we see the environment structure created by evaluating the
expression <code class="code">f(5)</code>.  The call to <code class="code">f</code> creates a new environment E1
beginning with a frame in which <code class="code">a</code>, the formal parameter of <code class="code">f</code>, is
bound to the argument 5.  In E1, we evaluate the body of <code class="code">f</code>:
</p>
<div class="example">
<pre class="example-preformatted">sum_of_squares(a + 1, a * 2)
</pre></div>

<div class="float">
<a class="anchor" id="Figure-3_002e5"></a><img class="image" src="fig/chap3/Fig3.5b.std.svg" alt="fig/chap3/Fig3.5b" />
<div class="caption"><p><strong class="strong">Figure 3.5:</strong> Environments created by evaluating <code class="code">f(5)</code> using<!-- /@w --> the procedures in <a class="ref" href="#Figure-3_002e4">Figure 3.4</a>.</p></div></div>
<p>To evaluate this combination, we first evaluate the subexpressions.  The first
subexpression, <code class="code">sum_of_squares</code>, has a value that is a procedure object.
(Notice how this value is found: We first look in the first frame of E1, which
contains no binding for <code class="code">sum_of_squares</code>.  Then we proceed to the
enclosing environment, i.e. the global environment, and find the binding shown
in <a class="ref" href="#Figure-3_002e4">Figure 3.4</a>.)  The other two subexpressions are evaluated by applying
the primitive operations <code class="code">+</code> and <code class="code">*</code> to evaluate the two combinations
<code class="code">(+ a 1)</code> and <code class="code">(* a 2)</code> to obtain 6 and 10, respectively.
</p>
<p>Now we apply the procedure object <code class="code">sum_of_squares</code> to the arguments 6 and
10.  This results in a new environment E2 in which the formal parameters
<code class="code">x</code> and <code class="code">y</code> are bound to the arguments.  Within E2 we evaluate the
combination <code class="code">(+ (square x) (square y))</code>.  This leads us to evaluate
<code class="code">(square x)</code>, where <code class="code">square</code> is found in the global frame and
<code class="code">x</code> is 6.  Once again, we set up a new environment, E3, in which <code class="code">x</code>
is bound to 6, and within this we evaluate the body of <code class="code">square</code>, which is
<code class="code">(* x x)</code>.  Also as part of applying <code class="code">sum_of_squares</code>, we must
evaluate the subexpression <code class="code">(square y)</code>, where <code class="code">y</code> is 10.  This
second call to <code class="code">square</code> creates another environment, E4, in which
<code class="code">x</code>, the formal parameter of <code class="code">square</code>, is bound to 10.  And within E4
we must evaluate <code class="code">(* x x)</code>.
</p>
<p>The important point to observe is that each call to <code class="code">square</code> creates a new
environment containing a binding for <code class="code">x</code>.  We can see here how the
different frames serve to keep separate the different local variables all named
<code class="code">x</code>.  Notice that each frame created by <code class="code">square</code> points to the global
environment, since this is the environment indicated by the <code class="code">square</code>
procedure object.
</p>
<p>After the subexpressions are evaluated, the results are returned.  The values
generated by the two calls to <code class="code">square</code> are added by <code class="code">sum_of_squares</code>,
and this result is returned by <code class="code">f</code>.  Since our focus here is on the
environment structures, we will not dwell on how these returned values are
passed from call to call; however, this is also an important aspect of the
evaluation process, and we will return to it in detail in <a class="ref" href="Chapter-5.xhtml">Computing with Register Machines</a>.
</p>
<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-3_002e9"></a>Exercise 3.9:</strong> In <a class="ref" href="1_002e2.xhtml#g_t1_002e2_002e1">Linear Recursion and Iteration</a> we used the
substitution model to analyze two procedures for computing factorials, a
recursive version
</p>
<div class="example">
<pre class="example-preformatted">fn factorial(n: u64) -&gt; u64 {
    if n == 1 {
        1
    } else {
        n * factorial(n - 1)
    }
}
</pre></div>

<p>and an iterative version
</p>
<div class="example">
<pre class="example-preformatted">fn factorial(n: u64) -&gt; u64 {
    fact_iter(1, 1, n)
}

fn fact_iter(product: u64, counter: u64, max_count: u64) -&gt; u64 {
    if counter &gt; max_count {
        product
    } else {
        fact_iter(counter * product, counter + 1, max_count)
    }
}
</pre></div>

<p>Show the environment structures created by evaluating <code class="code">(factorial 6)</code>
using each version of the <code class="code">factorial</code> procedure.<a class="footnote" id="DOCF135" href="#FOOT135"><sup>135</sup></a>
</p></blockquote>

<hr />
</div>
<div class="subsection-level-extent" id="g_t3_002e2_002e3">
<h4 class="subsection" id="Frames-as-the-Repository-of-Local-State"><span>3.2.3 Frames as the Repository of Local State<a class="copiable-link" href="#Frames-as-the-Repository-of-Local-State"> &#182;</a></span></h4>

<p>We can turn to the environment model to see how procedures and assignment can
be used to represent objects with local state.  As an example, consider the
&#8220;withdrawal processor&#8221; from <a class="ref" href="3_002e1.xhtml#g_t3_002e1_002e1">Local State Variables</a> created by calling the
procedure
</p>
<div class="example">
<pre class="example-preformatted">use std::cell::Cell;

fn make_withdraw(initial: i64) -&gt; impl FnMut(i64) -&gt; Result&lt;i64, &amp;'static str&gt; {
    let balance = Cell::new(initial);
    move |amount| {
        let current = balance.get();
        if current &gt;= amount {
            balance.set(current - amount);
            Ok(balance.get())
        } else {
            Err(&quot;Insufficient funds&quot;)
        }
    }
}
</pre></div>

<p>Let us describe the evaluation of
</p>
<div class="example">
<pre class="example-preformatted">let mut w1 = make_withdraw(100);
</pre></div>

<p>followed by
</p>
<div class="example">
<pre class="example-preformatted">w1(50);
// =&gt; Ok(50)
</pre></div>

<p><a class="ref" href="#Figure-3_002e6">Figure 3.6</a> shows the result of defining the <code class="code">make_withdraw</code>
procedure in the global environment.  This produces a procedure object that
contains a pointer to the global environment.  So far, this is no different
from the examples we have already seen, except that the body of the procedure
is itself a closure expression.
</p>
<div class="float">
<a class="anchor" id="Figure-3_002e6"></a><img class="image" src="fig/chap3/Fig3.6c.std.svg" alt="fig/chap3/Fig3.6c" />
<div class="caption"><p><strong class="strong">Figure 3.6:</strong> Result of defining <code class="code">make_withdraw</code> in the global environment.</p></div></div>
<p>The interesting part of the computation happens when we apply the procedure
<code class="code">make_withdraw</code> to an argument:
</p>
<div class="example">
<pre class="example-preformatted">let mut w1 = make_withdraw(100);
</pre></div>

<p>We begin, as usual, by setting up an environment E1 in which the formal
parameter <code class="code">balance</code> is bound to the argument 100.  Within this
environment, we evaluate the body of <code class="code">make_withdraw</code>, namely the
closure expression.  This constructs a new procedure object, whose code
is as specified by the <code class="code">lambda</code> and whose environment is E1, the
environment in which the <code class="code">lambda</code> was evaluated to produce the procedure.
The resulting procedure object is the value returned by the call to
<code class="code">make_withdraw</code>.  This is bound to <code class="code">W1</code> in the global environment,
since the definition itself is being evaluated in the global environment.
<a class="ref" href="#Figure-3_002e7">Figure 3.7</a> shows the resulting environment structure.
</p>
<div class="float">
<a class="anchor" id="Figure-3_002e7"></a><img class="image" src="fig/chap3/Fig3.7b.std.svg" alt="fig/chap3/Fig3.7b" />
<div class="caption"><p><strong class="strong">Figure 3.7:</strong> Result of evaluating <code class="code">let mut w1 = make_withdraw(100);</code>.</p></div></div>
<p>Now we can analyze what happens when <code class="code">W1</code> is applied to an argument:
</p>
<div class="example">
<pre class="example-preformatted">w1(50);
// =&gt; Ok(50)
</pre></div>

<p>We begin by constructing a frame in which <code class="code">amount</code>, the formal parameter
of <code class="code">W1</code>, is bound to the argument 50.  The crucial point to observe is
that this frame has as its enclosing environment not the global environment,
but rather the environment E1, because this is the environment that is
specified by the <code class="code">W1</code> procedure object.  Within this new environment, we
evaluate the body of the procedure:
</p>
<div class="example">
<pre class="example-preformatted">if balance.get() &gt;= amount {
    balance.set(balance.get() - amount);
    Ok(balance.get())
} else {
    Err(&quot;Insufficient funds&quot;)
}
</pre></div>

<p>The resulting environment structure is shown in <a class="ref" href="#Figure-3_002e8">Figure 3.8</a>.  The
expression being evaluated references both <code class="code">amount</code> and <code class="code">balance</code>.
<code class="code">Amount</code> will be found in the first frame in the environment, while
<code class="code">balance</code> will be found by following the enclosing-environment pointer to
E1.
</p>
<div class="float">
<a class="anchor" id="Figure-3_002e8"></a><img class="image" src="fig/chap3/Fig3.8c.std.svg" alt="fig/chap3/Fig3.8c" />
<div class="caption"><p><strong class="strong">Figure 3.8:</strong> Environments created by applying the procedure object <code class="code">W1</code>.</p></div></div>
<p>When the <code class="code">set!</code> is executed, the binding of <code class="code">balance</code> in E1 is
changed.  At the completion of the call to <code class="code">W1</code>, <code class="code">balance</code> is 50, and
the frame that contains <code class="code">balance</code> is still pointed to by the procedure
object <code class="code">W1</code>.  The frame that binds <code class="code">amount</code> (in which we executed the
code that changed <code class="code">balance</code>) is no longer relevant, since the procedure
call that constructed it has terminated, and there are no pointers to that
frame from other parts of the environment.  The next time <code class="code">W1</code> is called,
this will build a new frame that binds <code class="code">amount</code> and whose enclosing
environment is E1.  We see that E1 serves as the &#8220;place&#8221; that holds the local
state variable for the procedure object <code class="code">W1</code>.  <a class="ref" href="#Figure-3_002e9">Figure 3.9</a> shows the
situation after the call to <code class="code">W1</code>.
</p>
<div class="float">
<a class="anchor" id="Figure-3_002e9"></a><img class="image" src="fig/chap3/Fig3.9b.std.svg" alt="fig/chap3/Fig3.9b" />
<div class="caption"><p><strong class="strong">Figure 3.9:</strong> Environments after the call to <code class="code">W1</code>.</p></div></div>
<p>Observe what happens when we create a second &#8220;withdraw&#8221; object by making
another call to <code class="code">make_withdraw</code>:
</p>
<div class="example">
<pre class="example-preformatted">let mut w2 = make_withdraw(100);
</pre></div>

<p>This produces the environment structure of <a class="ref" href="#Figure-3_002e10">Figure 3.10</a>, which shows that
<code class="code">W2</code> is a procedure object, that is, a pair with some code and an
environment.  The environment E2 for <code class="code">W2</code> was created by the call to
<code class="code">make_withdraw</code>.  It contains a frame with its own local binding for
<code class="code">balance</code>.  On the other hand, <code class="code">W1</code> and <code class="code">W2</code> have the same code:
the code specified by the closure expression in the body of
<code class="code">make_withdraw</code>.<a class="footnote" id="DOCF136" href="#FOOT136"><sup>136</sup></a> We see here why <code class="code">W1</code> and
<code class="code">W2</code> behave as independent objects.  Calls to <code class="code">W1</code> reference the
state variable <code class="code">balance</code> stored in E1, whereas calls to <code class="code">W2</code>
reference the <code class="code">balance</code> stored in E2. Thus, changes to the local state of
one object do not affect the other object.
</p>
<div class="float">
<a class="anchor" id="Figure-3_002e10"></a><img class="image" src="fig/chap3/Fig3.10b.std.svg" alt="fig/chap3/Fig3.10b" />
<div class="caption"><p><strong class="strong">Figure 3.10:</strong> Using <code class="code">let mut w2 = make_withdraw(100);</code> to create a second object.</p></div></div>
<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-3_002e10"></a>Exercise 3.10:</strong> In the <code class="code">make_withdraw</code>
procedure, the local variable <code class="code">balance</code> is created as a parameter of
<code class="code">make_withdraw</code>.  We could also create the local state variable
explicitly, using <code class="code">let</code>, as follows:
</p>
<div class="example">
<pre class="example-preformatted">fn make_withdraw(initial_amount: i64) -&gt; impl FnMut(i64) -&gt; Result&lt;i64, &amp;'static str&gt; {
    let balance = std::cell::Cell::new(initial_amount);
    move |amount| {
        let current = balance.get();
        if current &gt;= amount {
            balance.set(current - amount);
            Ok(balance.get())
        } else {
            Err(&quot;Insufficient funds&quot;)
        }
    }
}
</pre></div>

<p>In Rust, the <code class="code">let</code> binding creates a local variable that is captured
by the closure, similar to how Scheme&#8217;s <code class="code">let</code> creates a binding
in a new scope:
</p>
<div class="example">
<pre class="example-preformatted">// Rust's let binding captures the variable
let balance = Cell::new(initial_amount);
move |amount| { /* uses balance */ }
</pre></div>

<p>Use the environment model to analyze this alternate version of
<code class="code">make_withdraw</code>, drawing figures like the ones above to illustrate the
interactions
</p>
<div class="example">
<pre class="example-preformatted">let mut w1 = make_withdraw(100);
w1(50);
let mut w2 = make_withdraw(100);
</pre></div>

<p>Show that the two versions of <code class="code">make_withdraw</code> create objects with the same
behavior.  How do the environment structures differ for the two versions?
</p></blockquote>

<hr />
</div>
<div class="subsection-level-extent" id="g_t3_002e2_002e4">
<h4 class="subsection" id="Internal-Definitions"><span>3.2.4 Internal Definitions<a class="copiable-link" href="#Internal-Definitions"> &#182;</a></span></h4>

<p>Section <a class="ref" href="1_002e1.xhtml#g_t1_002e1_002e8">Procedures as Black-Box Abstractions</a> introduced the idea that procedures can have internal
definitions, thus leading to a block structure as in the following procedure to
compute square roots:
</p>
<div class="example">
<pre class="example-preformatted">fn sqrt(x: f64) -&gt; f64 {
    fn good_enough(guess: f64, x: f64) -&gt; bool {
        (guess * guess - x).abs() &lt; 0.001
    }

    fn improve(guess: f64, x: f64) -&gt; f64 {
        (guess + x / guess) / 2.0
    }

    fn sqrt_iter(guess: f64, x: f64) -&gt; f64 {
        if good_enough(guess, x) {
            guess
        } else {
            sqrt_iter(improve(guess, x), x)
        }
    }

    sqrt_iter(1.0, x)
}
</pre></div>

<p>Now we can use the environment model to see why these internal definitions
behave as desired.  <a class="ref" href="#Figure-3_002e11">Figure 3.11</a> shows the point in the evaluation of the
expression <code class="code">(sqrt 2)</code> where the internal procedure <code class="code">good_enough</code> has
been called for the first time with <code class="code">guess</code> equal to 1.
</p>
<div class="float">
<a class="anchor" id="Figure-3_002e11"></a><img class="image" src="fig/chap3/Fig3.11b.std.svg" alt="fig/chap3/Fig3.11b" />
<div class="caption"><p><strong class="strong">Figure 3.11:</strong> <code class="code">Sqrt</code> procedure with internal definitions.</p></div></div>
<p>Observe the structure of the environment.  <code class="code">Sqrt</code> is a symbol in the
global environment that is bound to a procedure object whose associated
environment is the global environment.  When <code class="code">sqrt</code> was called, a new
environment E1 was formed, subordinate to the global environment, in which the
parameter <code class="code">x</code> is bound to 2.  The body of <code class="code">sqrt</code> was then evaluated
in E1.  Since the first expression in the body of <code class="code">sqrt</code> is
</p>
<div class="example">
<pre class="example-preformatted">fn good_enough(guess: f64, x: f64) -&gt; bool {
    (guess * guess - x).abs() &lt; 0.001
}
</pre></div>

<p>evaluating this expression defined the procedure <code class="code">good_enough</code>  in the
environment E1.  To be more precise, the symbol <code class="code">good_enough</code> was added
to the first frame of E1, bound to a procedure object whose associated
environment is E1.  Similarly, <code class="code">improve</code> and <code class="code">sqrt-iter</code> were defined
as procedures in E1.  For conciseness, <a class="ref" href="#Figure-3_002e11">Figure 3.11</a> shows only the
procedure object for <code class="code">good_enough</code>.
</p>
<p>After the local procedures were defined, the expression <code class="code">(sqrt-iter 1.0)</code>
was evaluated, still in environment E1.  So the procedure object bound to
<code class="code">sqrt-iter</code> in E1 was called with 1 as an argument.  This created an
environment E2 in which <code class="code">guess</code>, the parameter of <code class="code">sqrt-iter</code>, is
bound to 1.  <code class="code">Sqrt-iter</code> in turn called <code class="code">good_enough</code> with the value
of <code class="code">guess</code> (from E2) as the argument for <code class="code">good_enough</code>.  This set up
another environment, E3, in which <code class="code">guess</code> (the parameter of
<code class="code">good_enough</code>) is bound to 1.  Although <code class="code">sqrt-iter</code> and
<code class="code">good_enough</code> both have a parameter named <code class="code">guess</code>, these are two
distinct local variables located in different frames.  Also, E2 and E3 both
have E1 as their enclosing environment, because the <code class="code">sqrt-iter</code> and
<code class="code">good_enough</code> procedures both have E1 as their environment part.  One
consequence of this is that the symbol <code class="code">x</code> that appears in the body of
<code class="code">good_enough</code> will reference the binding of <code class="code">x</code> that appears in E1,
namely the value of <code class="code">x</code> with which the original <code class="code">sqrt</code> procedure was
called.
</p>
<p>The environment model thus explains the two key properties that make local
procedure definitions a useful technique for modularizing programs:
</p>
<ul class="itemize mark-bullet">
<li>The names of the local procedures do not interfere with names external to the
enclosing procedure, because the local procedure names will be bound in the
frame that the procedure creates when it is run, rather than being bound in the
global environment.

</li><li>The local procedures can access the arguments of the enclosing procedure,
simply by using parameter names as free variables.  This is because the body of
the local procedure is evaluated in an environment that is subordinate to the
evaluation environment for the enclosing procedure.

</li></ul>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-3_002e11"></a>Exercise 3.11:</strong> In <a class="ref" href="#g_t3_002e2_002e3">Frames as the Repository of Local State</a> we saw how
the environment model described the behavior of procedures with local state.
Now we have seen how internal definitions work.  A typical message-passing
procedure contains both of these aspects.  Consider the bank account procedure
of <a class="ref" href="3_002e1.xhtml#g_t3_002e1_002e1">Local State Variables</a>:
</p>
<div class="example">
<pre class="example-preformatted">use std::cell::Cell;

struct Account {
    balance: Cell&lt;i64&gt;,
}

impl Account {
    fn new(balance: i64) -&gt; Self {
        Account { balance: Cell::new(balance) }
    }

    fn withdraw(&amp;self, amount: i64) -&gt; Result&lt;i64, &amp;'static str&gt; {
        let current = self.balance.get();
        if current &gt;= amount {
            self.balance.set(current - amount);
            Ok(self.balance.get())
        } else {
            Err(&quot;Insufficient funds&quot;)
        }
    }

    fn deposit(&amp;self, amount: i64) -&gt; i64 {
        self.balance.set(self.balance.get() + amount);
        self.balance.get()
    }
}
</pre></div>

<p>Show the environment structure generated by the sequence of interactions
</p>
<div class="example">
<pre class="example-preformatted">let acc = Account::new(50);

acc.deposit(40);
// =&gt; 90

acc.withdraw(60);
// =&gt; Ok(30)
</pre></div>

<p>Where is the local state for <code class="code">acc</code> kept?  Suppose we define another
account
</p>
<div class="example">
<pre class="example-preformatted">let acc2 = Account::new(100);
</pre></div>

<p>How are the local states for the two accounts kept distinct?  Which parts of
the environment structure are shared between <code class="code">acc</code> and <code class="code">acc2</code>?
</p></blockquote>

</div>
</div>
<div class="footnotes-segment">
<hr />
<h4 class="footnotes-heading">Footnotes</h4>

<h5 class="footnote-body-heading"><a id="FOOT133" href="#DOCF133">(133)</a></h5>
<p>Assignment introduces a
subtlety into step 1 of the evaluation rule.  As shown in <a class="ref" href="3_002e1.xhtml#Exercise-3_002e8">Exercise 3.8</a>,
the presence of assignment allows us to write expressions that will produce
different values depending on the order in which the subexpressions in a
combination are evaluated.  Thus, to be precise, we should specify an
evaluation order in step 1 (e.g., left to right or right to left).  However,
this order should always be considered to be an implementation detail, and one
should never write programs that depend on some particular order.  For
instance, a sophisticated compiler might optimize a program by varying the
order in which subexpressions are evaluated.</p>
<h5 class="footnote-body-heading"><a id="FOOT134" href="#DOCF134">(134)</a></h5>
<p>If there is already a binding for the variable in the current
frame, then the binding is changed.  This is convenient because it allows
redefinition of symbols; however, it also means that definition can be used
to change values, and this brings up the issues of assignment without
explicitly using <code class="code">set!</code>.  Because of this, some people prefer
redefinitions of existing symbols to signal errors or warnings.</p>
<h5 class="footnote-body-heading"><a id="FOOT135" href="#DOCF135">(135)</a></h5>
<p>The environment
model will not clarify our claim in <a class="ref" href="1_002e2.xhtml#g_t1_002e2_002e1">Linear Recursion and Iteration</a> that the interpreter
can execute a procedure such as <code class="code">fact_iter</code> in a constant amount of space
using tail recursion.  We will discuss tail recursion when we deal with the
control structure of the interpreter in <a class="ref" href="5_002e4.xhtml#g_t5_002e4">The Explicit-Control Evaluator</a>.</p>
<h5 class="footnote-body-heading"><a id="FOOT136" href="#DOCF136">(136)</a></h5>
<p>Whether <code class="code">W1</code> and <code class="code">W2</code> share the same
physical code stored in the computer, or whether they each keep a copy of the
code, is a detail of the implementation.  For the interpreter we implement in
<a class="ref" href="Chapter-4.xhtml">Metalinguistic Abstraction</a>, the code is in fact shared.</p>
</div>
<hr />
<div class="nav-panel">
<p>
Next: <a href="3_002e3.xhtml#g_t3_002e3" accesskey="n" rel="next">Modeling with Mutable Data</a>, Previous: <a href="3_002e1.xhtml#g_t3_002e1_002e4" accesskey="p" rel="prev">The Borrow Checker as Guardian</a>, Up: <a href="Chapter-3.xhtml" accesskey="u" rel="up">Modularity, Objects, and State</a> &#160; [<a href="index.xhtml#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Term-Index.xhtml" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
