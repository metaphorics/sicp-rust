<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<!-- Created by GNU Texinfo 7.1, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>5.4 (Structure and Interpretation of Computer Programs, 2e)</title>

<meta name="description" content="5.4 (Structure and Interpretation of Computer Programs, 2e)" />
<meta name="keywords" content="5.4 (Structure and Interpretation of Computer Programs, 2e)" />
<meta name="resource-type" content="document" />
<meta name="distribution" content="global" />
<meta name="Generator" content="texi2any" />
<meta name="viewport" content="width=device-width,initial-scale=1" />

<link href="index.xhtml" rel="start" title="Top" />
<link href="Term-Index.xhtml" rel="index" title="Term Index" />
<link href="index.xhtml#SEC_Contents" rel="contents" title="Table of Contents" />
<link href="Chapter-5.xhtml" rel="up" title="Chapter 5" />
<link href="5_002e5.xhtml#g_t5_002e5" rel="next" title="5.5" />
<link href="5_002e3.xhtml#g_t5_002e3_002e3" rel="prev" title="5.3.3" />
<style type="text/css">
<!--
a.copiable-link {visibility: hidden; text-decoration: none; line-height: 0em}
div.example {margin-left: 3.2em}
span.r {font-family: initial; font-weight: normal; font-style: normal}
span:hover a.copiable-link {visibility: visible}
ul.mark-bullet {list-style-type: disc}
-->
</style>
<link href="css/style.css" rel="stylesheet" type="text/css" />
<link href="css/prettify.css" rel="stylesheet" type="text/css" />
<script src="js/highlight/prettify.js" type="text/javascript"></script>
<script src="js/highlight/lang-lisp.js" type="text/javascript"></script>
<script src="js/highlight/lang-rust.js" type="text/javascript"></script>
</head>

<body lang="en">
<div class="section-level-extent" id="g_t5_002e4">
<div class="nav-panel">
<p>
Next: <a href="5_002e5.xhtml#g_t5_002e5" accesskey="n" rel="next">Compilation</a>, Previous: <a href="5_002e3.xhtml#g_t5_002e3_002e3" accesskey="p" rel="prev">Ownership as Compile-Time Garbage Collection</a>, Up: <a href="Chapter-5.xhtml" accesskey="u" rel="up">Computing with Register Machines</a> &#160; [<a href="index.xhtml#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Term-Index.xhtml" title="Index" rel="index">Index</a>]</p>
</div>
<h3 class="section" id="The-Explicit_002dControl-Evaluator"><span>5.4 The Explicit-Control Evaluator<a class="copiable-link" href="#The-Explicit_002dControl-Evaluator"> &#182;</a></span></h3>

<p>In <a class="ref" href="5_002e1.xhtml#g_t5_002e1">Designing Register Machines</a> we saw how to transform simple Scheme programs into
descriptions of register machines.  We will now perform this transformation on
a more complex program, the metacircular evaluator of
<a class="ref" href="4_002e1.xhtml#g_t4_002e1_002e1">The Core of the Evaluator</a>&#8211;<a class="ref" href="4_002e1.xhtml#g_t4_002e1_002e4">Running the Evaluator as a Program</a>, which shows how the behavior of a Scheme interpreter
can be described in terms of the procedures <code class="code">eval</code> and <code class="code">apply</code>. The
<a class="index-entry-id" id="index-explicit_002dcontrol-evaluator"></a>
<em class="dfn">explicit-control evaluator</em> that we develop in this section shows how
the underlying procedure-calling and argument-passing mechanisms used in the
evaluation process can be described in terms of operations on registers and
stacks.  In addition, the explicit-control evaluator can serve as an
implementation of a dynamic language interpreter, written in a style that is
very similar to the native machine language of conventional computers.  The
evaluator can be executed by the register-machine simulator of
<a class="ref" href="5_002e2.xhtml#g_t5_002e2">A Register-Machine Simulator</a>.
</p>
<h4 class="subsubheading" id="Registers-and-operations"><span>Registers and operations<a class="copiable-link" href="#Registers-and-operations"> &#182;</a></span></h4>

<p>In designing the explicit-control evaluator, we must specify the operations to
be used in our register machine.  We described the metacircular evaluator in
terms of abstract syntax, using enum variants such as <code class="code">Expr::Quote</code> and
<code class="code">Expr::Lambda</code>.  In implementing the register machine, we could expand
these procedures into sequences of elementary memory operations,
and implement these operations on our register machine.  However, this would
make our evaluator very long, obscuring the basic structure with details.  To
clarify the presentation, we will include as primitive operations of the
register machine the syntax procedures given in <a class="ref" href="4_002e1.xhtml#g_t4_002e1_002e2">Representing Expressions</a> and the
procedures for representing environments and other run-time data given in
sections <a class="ref" href="4_002e1.xhtml#g_t4_002e1_002e3">Evaluator Data Structures</a> and <a class="ref" href="4_002e1.xhtml#g_t4_002e1_002e4">Running the Evaluator as a Program</a>.
</p>
<p>Our evaluator register machine includes a stack and seven registers:
<code class="code">exp</code>, <code class="code">env</code>, <code class="code">val</code>, <code class="code">continue</code>, <code class="code">proc</code>, <code class="code">argl</code>,
and <code class="code">unev</code>.  <code class="code">Exp</code> is used to hold the expression to be evaluated,
and <code class="code">env</code> contains the environment in which the evaluation is to be
performed.  At the end of an evaluation, <code class="code">val</code> contains the value obtained
by evaluating the expression in the designated environment.  The
<code class="code">continue</code> register is used to implement recursion, as explained in
<a class="ref" href="5_002e1.xhtml#g_t5_002e1_002e4">Using a Stack to Implement Recursion</a>.  The
registers <code class="code">proc</code>, <code class="code">argl</code>, and <code class="code">unev</code> are used in evaluating
combinations.
</p>
<p>In Rust, we implement the controller as a <code class="code">run</code> loop that dispatches based
on a <code class="code">current_label</code> enum variant. Each instruction or sequence of
instructions is implemented as a method on the <code class="code">EvaluatorMachine</code> struct.
</p>

<hr />
<div class="subsection-level-extent" id="g_t5_002e4_002e1">
<h4 class="subsection" id="The-Core-of-the-Explicit_002dControl-Evaluator"><span>5.4.1 The Core of the Explicit-Control Evaluator<a class="copiable-link" href="#The-Core-of-the-Explicit_002dControl-Evaluator"> &#182;</a></span></h4>

<p>The central element in the evaluator is the sequence of instructions beginning
at <code class="code">eval_dispatch</code>.  This corresponds to the <code class="code">eval</code> procedure of the
metacircular evaluator described in <a class="ref" href="4_002e1.xhtml#g_t4_002e1_002e1">The Core of the Evaluator</a>.  When the controller
starts at <code class="code">eval_dispatch</code>, it evaluates the expression specified by
<code class="code">exp</code> in the environment specified by <code class="code">env</code>.  When evaluation is
complete, the controller will go to the entry point stored in <code class="code">continue</code>,
and the <code class="code">val</code> register will hold the value of the expression.  In Rust, we
implement this dispatch using a <code class="code">match</code> on a <code class="code">Label</code> enum:
</p>
<div class="example">
<pre class="example-preformatted">fn eval_dispatch(&amp;mut self) -&gt; Result&lt;(), String&gt; {
    let exp = self.exp.clone().ok_or(&quot;No expression in exp register&quot;)?;

    match exp {
        Expr::Number(_) | Expr::Bool(_) | Expr::String(_) | Expr::Nil =&gt; {
            self.current_label = Label::EvSelfEval;
        }
        Expr::Symbol(_) =&gt; {
            self.current_label = Label::EvVariable;
        }
        Expr::Quote(_) =&gt; {
            self.current_label = Label::EvQuoted;
        }
        Expr::Lambda { .. } =&gt; {
            self.current_label = Label::EvLambda;
        }
        Expr::If { .. } =&gt; {
            self.current_label = Label::EvIf;
        }
        Expr::Definition { .. } =&gt; {
            self.current_label = Label::EvDefinition;
        }
        Expr::Begin(_) =&gt; {
            self.current_label = Label::EvBegin;
        }
        Expr::Application { .. } =&gt; {
            self.current_label = Label::EvApplication;
        }
        _ =&gt; {
            self.error = Some(format!(&quot;Unknown expression type: {:?}&quot;, exp));
            self.current_label = Label::Error;
        }
    }
    Ok(())
}
</pre></div>

<h4 class="subsubheading" id="Evaluating-simple-expressions"><span>Evaluating simple expressions<a class="copiable-link" href="#Evaluating-simple-expressions"> &#182;</a></span></h4>

<p>Numbers and strings (which are self-evaluating), variables, quotations, and
<code class="code">lambda</code> expressions have no subexpressions to be evaluated.  For these,
the evaluator simply places the correct value in the <code class="code">val</code> register and
continues execution at the entry point specified by <code class="code">continue</code>.
Evaluation of simple expressions is performed by the following controller code:
</p>
<div class="example">
<pre class="example-preformatted">fn ev_self_eval(&amp;mut self) -&gt; Result&lt;(), String&gt; {
    let exp = self.exp.clone().ok_or(&quot;No expression&quot;)?;
    self.val = Some(match exp {
        Expr::Number(n) =&gt; Value::Number(n),
        Expr::Bool(b) =&gt; Value::Bool(b),
        Expr::String(s) =&gt; Value::String(s),
        Expr::Nil =&gt; Value::Nil,
        _ =&gt; return Err(&quot;Not self-evaluating&quot;.into()),
    });
    self.current_label = self.continue_reg;
    Ok(())
}

fn ev_variable(&amp;mut self) -&gt; Result&lt;(), String&gt; {
    let var = match self.exp.clone() {
        Some(Expr::Symbol(s)) =&gt; s,
        _ =&gt; return Err(&quot;Expected symbol&quot;.into()),
    };
    self.val = Some(self.env.lookup(&amp;var).cloned()
        .ok_or_else(|| format!(&quot;Unbound variable: {}&quot;, var))?);
    self.current_label = self.continue_reg;
    Ok(())
}

fn ev_quoted(&amp;mut self) -&gt; Result&lt;(), String&gt; {
    let quoted = match self.exp.clone() {
        Some(Expr::Quote(inner)) =&gt; *inner,
        _ =&gt; return Err(&quot;Expected quote&quot;.into()),
    };
    self.val = Some(self.expr_to_value(quoted));
    self.current_label = self.continue_reg;
    Ok(())
}

fn ev_lambda(&amp;mut self) -&gt; Result&lt;(), String&gt; {
    let (params, body) = match self.exp.clone() {
        Some(Expr::Lambda { params, body }) =&gt; (params, body),
        _ =&gt; return Err(&quot;Expected lambda&quot;.into()),
    };
    self.val = Some(Value::Procedure {
        params, body, env: self.env.clone(), self_name: None,
    });
    self.current_label = self.continue_reg;
    Ok(())
}
</pre></div>

<p>Observe how <code class="code">ev_lambda</code> uses the <code class="code">params</code> and <code class="code">body</code> from the
expression to construct a procedure object, capturing the current environment.
</p>
<h4 class="subsubheading" id="Evaluating-procedure-applications"><span>Evaluating procedure applications<a class="copiable-link" href="#Evaluating-procedure-applications"> &#182;</a></span></h4>

<p>A procedure application is specified by a combination containing an operator
and operands.  The operator is a subexpression whose value is a procedure, and
the operands are subexpressions whose values are the arguments to which the
procedure should be applied.  The metacircular <code class="code">eval</code> handles applications
by calling itself recursively to evaluate each element of the combination, and
then passing the results to <code class="code">apply</code>, which performs the actual procedure
application.  The explicit-control evaluator does the same thing; these
recursive calls are implemented by setting the <code class="code">current_label</code> to
<code class="code">Label::EvalDispatch</code>, together with use of the stack to save registers
that will be restored after the recursive call returns.
</p>
<p>We begin the evaluation of an application by evaluating the operator to produce
a procedure, which will later be applied to the evaluated operands.  To
evaluate the operator, we move it to the <code class="code">exp</code> register and go to
<code class="code">eval_dispatch</code>.  The environment in the <code class="code">env</code> register is already
the correct one in which to evaluate the operator.  However, we save <code class="code">env</code>
because we will need it later to evaluate the operands.  We also extract the
operands into <code class="code">unev</code> and save this on the stack.  We set up
<code class="code">continue</code> so that <code class="code">eval_dispatch</code> will resume at
<code class="code">ev_appl_did_operator</code> after the operator has been evaluated.  First,
however, we save the old value of <code class="code">continue</code>, which tells the controller
where to continue after the application.
</p>
<div class="example">
<pre class="example-preformatted">fn ev_application(&amp;mut self) -&gt; Result&lt;(), String&gt; {
    let (operator, operands) = match self.exp.clone() {
        Some(Expr::Application { operator, operands }) =&gt; (operator, operands),
        _ =&gt; return Err(&quot;Expected application&quot;.into()),
    };
    self.save(StackFrame::Continue(self.continue_reg));
    self.save(StackFrame::Env(self.env.clone()));
    self.unev = operands;
    self.save(StackFrame::Unev(self.unev.clone()));
    self.exp = Some(*operator);
    self.continue_reg = Label::EvApplDidOperator;
    self.current_label = Label::EvalDispatch;
    Ok(())
}
</pre></div>

<p>Upon returning from evaluating the operator subexpression, we proceed to
evaluate the operands of the combination and to accumulate the resulting
arguments in a list, held in <code class="code">argl</code>.  First we restore the unevaluated
operands and the environment.  We initialize <code class="code">argl</code> to an empty list.
Then we assign to the <code class="code">proc</code> register the procedure that was produced by
evaluating the operator.  If there are no operands, we go directly to
<code class="code">apply_dispatch</code>.  Otherwise we save <code class="code">proc</code> on the stack and start
the argument-evaluation loop:
</p>
<div class="example">
<pre class="example-preformatted">fn ev_appl_did_operator(&amp;mut self) -&gt; Result&lt;(), String&gt; {
    self.restore_unev()?;
    self.restore_env()?;
    self.argl = Vec::new();
    self.proc = self.val.clone();
    if self.unev.is_empty() {
        self.current_label = Label::ApplyDispatch;
    } else {
        self.save(StackFrame::Proc(self.proc.clone().unwrap()));
        self.current_label = Label::EvApplOperandLoop;
    }
    Ok(())
}
</pre></div>

<p>Each cycle of the argument-evaluation loop evaluates an operand from the list
in <code class="code">unev</code> and accumulates the result into <code class="code">argl</code>.  To evaluate an
operand, we place it in the <code class="code">exp</code> register and go to <code class="code">eval_dispatch</code>,
after setting <code class="code">continue</code> so that execution will resume with the
argument-accumulation phase.  But first we save the arguments accumulated so
far (held in <code class="code">argl</code>), the environment (held in <code class="code">env</code>), and the
remaining operands to be evaluated (held in <code class="code">unev</code>).  A special case is
made for the evaluation of the last operand, which is handled at
<code class="code">ev_appl_last_arg</code>.
</p>
<div class="example">
<pre class="example-preformatted">fn ev_appl_operand_loop(&amp;mut self) -&gt; Result&lt;(), String&gt; {
    self.save(StackFrame::Argl(self.argl.clone()));
    self.exp = Some(self.unev[0].clone());
    if self.unev.len() == 1 {
        self.current_label = Label::EvApplLastArg;
    } else {
        self.save(StackFrame::Env(self.env.clone()));
        self.save(StackFrame::Unev(self.unev.clone()));
        self.continue_reg = Label::EvApplAccumulateArg;
        self.current_label = Label::EvalDispatch;
    }
    Ok(())
}
</pre></div>

<p>When an operand has been evaluated, the value is accumulated into the list held
in <code class="code">argl</code>.  The operand is then removed from the list of unevaluated
operands in <code class="code">unev</code>, and the argument-evaluation continues.
</p>
<div class="example">
<pre class="example-preformatted">fn ev_appl_accumulate_arg(&amp;mut self) -&gt; Result&lt;(), String&gt; {
    self.restore_unev()?;
    self.restore_env()?;
    self.restore_argl()?;
    self.argl.push(self.val.clone().ok_or(&quot;No value&quot;)?);
    self.unev = self.unev[1..].to_vec();
    self.current_label = Label::EvApplOperandLoop;
    Ok(())
}
</pre></div>

<p>Evaluation of the last argument is handled differently.  There is no need to
save the environment or the list of unevaluated operands before going to
<code class="code">eval_dispatch</code>, since they will not be required after the last operand is
evaluated.  Thus, we return from the evaluation to a special entry point
<code class="code">ev_appl_accum_last_arg</code>, which restores the argument list, accumulates
the new argument, restores the saved procedure, and goes off to perform the
application.<a class="footnote" id="DOCF283" href="#FOOT283"><sup>283</sup></a>
</p>
<div class="example lisp">
<pre class="lisp-preformatted">ev_appl_last_arg
  (assign continue
          (label ev_appl_accum_last_arg))
  (goto (label eval_dispatch))
ev_appl_accum_last_arg
  (restore argl)
  (assign argl
          (op adjoin_arg)
          (reg val)
          (reg argl))
  (restore proc)
  (goto (label apply_dispatch))
</pre></div>

<p>The details of the argument-evaluation loop determine the order in which the
interpreter evaluates the operands of a combination (e.g., left to right or
right to left&#8212;see <a class="ref" href="3_002e1.xhtml#Exercise-3_002e8">Exercise 3.8</a>).  This order is not determined by the
metacircular evaluator, which inherits its control structure from the
underlying Scheme in which it is implemented.<a class="footnote" id="DOCF284" href="#FOOT284"><sup>284</sup></a> Because
the <code class="code">first-operand</code> selector (used in <code class="code">ev_appl_operand_loop</code> to
extract successive operands from <code class="code">unev</code>) is implemented as <code class="code">car</code> and
the <code class="code">rest-operands</code> selector is implemented as <code class="code">cdr</code>, the
explicit-control evaluator will evaluate the operands of a combination in
left-to-right order.
</p>
<h4 class="subsubheading" id="Procedure-application"><span>Procedure application<a class="copiable-link" href="#Procedure-application"> &#182;</a></span></h4>

<p>The entry point <code class="code">apply_dispatch</code> corresponds to the <code class="code">apply</code> procedure
of the metacircular evaluator.  By the time we get to <code class="code">apply_dispatch</code>,
the <code class="code">proc</code> register contains the procedure to apply and <code class="code">argl</code>
contains the list of evaluated arguments to which it must be applied.  The
saved value of <code class="code">continue</code> (originally passed to <code class="code">eval_dispatch</code> and
saved at <code class="code">ev_application</code>), which tells where to return with the result of
the procedure application, is on the stack.  When the application is complete,
the controller transfers to the entry point specified by the saved
<code class="code">continue</code>, with the result of the application in <code class="code">val</code>.  As with the
metacircular <code class="code">apply</code>, there are two cases to consider.  Either the
procedure to be applied is a primitive or it is a compound procedure.
</p>
<div class="example">
<pre class="example-preformatted">// apply-dispatch
Label(&quot;apply-dispatch&quot;.into()),
match self.proc.as_ref().unwrap() {
    Value::Primitive(_) =&gt; { self.current_label = Label::PrimitiveApply; }
    Value::Procedure { .. } =&gt; { self.current_label = Label::CompoundApply; }
    _ =&gt; { self.current_label = Label::UnknownProcedureType; }
}
</pre></div>

<p>We assume that each primitive is implemented so as to obtain its arguments from
<code class="code">argl</code> and place its result in <code class="code">val</code>.  To specify how the machine
handles primitives, we would have to provide a sequence of controller
instructions to implement each primitive and arrange for <code class="code">primitive_apply</code>
to dispatch to the instructions for the primitive identified by the contents of
<code class="code">proc</code>.  Since we are interested in the structure of the evaluation
process rather than the details of the primitives, we will instead just use an
<code class="code">apply_primitive_procedure</code> operation that applies the procedure in
<code class="code">proc</code> to the arguments in <code class="code">argl</code>.  For the purpose of simulating the
evaluator with the simulator of <a class="ref" href="5_002e2.xhtml#g_t5_002e2">A Register-Machine Simulator</a> we use the procedure
<code class="code">apply_primitive_procedure</code>, which calls on the underlying Scheme system
to perform the application, just as we did for the metacircular evaluator in
<a class="ref" href="4_002e1.xhtml#g_t4_002e1_002e4">Running the Evaluator as a Program</a>.  After computing the value of the primitive application,
we restore <code class="code">continue</code> and go to the designated entry point.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">primitive_apply
  (assign val (op apply_primitive_procedure)
              (reg proc)
              (reg argl))
  (restore continue)
  (goto (reg continue))
</pre></div>

<p>To apply a compound procedure, we proceed just as with the metacircular
evaluator.  We construct a frame that binds the procedure&#8217;s parameters to the
arguments, use this frame to extend the environment carried by the procedure,
and evaluate in this extended environment the sequence of expressions that
forms the body of the procedure.  <code class="code">Ev-sequence</code>, described below in
<a class="ref" href="#g_t5_002e4_002e2">Sequence Evaluation and Tail Recursion</a>, handles the evaluation of the sequence.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">compound_apply
  (assign unev
          (op procedure_parameters)
          (reg proc))
  (assign env
          (op procedure_environment)
          (reg proc))
  (assign env
          (op extend_environment)
          (reg unev)
          (reg argl)
          (reg env))
  (assign unev
          (op procedure_body)
          (reg proc))
  (goto (label ev_sequence))
</pre></div>

<p><code class="code">Compound-apply</code> is the only place in the interpreter where the <code class="code">env</code>
register is ever assigned a new value.  Just as in the metacircular evaluator,
the new environment is constructed from the environment carried by the
procedure, together with the argument list and the corresponding list of
variables to be bound.
</p>
<hr />
</div>
<div class="subsection-level-extent" id="g_t5_002e4_002e2">
<h4 class="subsection" id="Sequence-Evaluation-and-Tail-Recursion"><span>5.4.2 Sequence Evaluation and Tail Recursion<a class="copiable-link" href="#Sequence-Evaluation-and-Tail-Recursion"> &#182;</a></span></h4>

<p>The portion of the explicit-control evaluator at <code class="code">ev_sequence</code> is
analogous to the metacircular evaluator&#8217;s <code class="code">eval_sequence</code> procedure.  It
handles sequences of expressions in procedure bodies or in explicit
<code class="code">begin</code> expressions.
</p>
<p>Explicit <code class="code">begin</code> expressions are evaluated by placing the sequence of
expressions to be evaluated in <code class="code">unev</code>, saving <code class="code">continue</code> on the
stack, and jumping to <code class="code">ev_sequence</code>.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">ev_begin
  (assign unev
          (op begin_actions)
          (reg exp))
  (save continue)
  (goto (label ev_sequence))
</pre></div>

<p>The implicit sequences in procedure bodies are handled by jumping to
<code class="code">ev_sequence</code> from <code class="code">compound_apply</code>, at which point <code class="code">continue</code>
is already on the stack, having been saved at <code class="code">ev_application</code>.
</p>
<p>The entries at <code class="code">ev_sequence</code> and <code class="code">ev_sequence_continue</code> form a loop
that successively evaluates each expression in a sequence.  The list of
unevaluated expressions is kept in <code class="code">unev</code>.  Before evaluating each
expression, we check to see if there are additional expressions to be evaluated
in the sequence.  If so, we save the rest of the unevaluated expressions (held
in <code class="code">unev</code>) and the environment in which these must be evaluated (held in
<code class="code">env</code>) and call <code class="code">eval_dispatch</code> to evaluate the expression.  The two
saved registers are restored upon the return from this evaluation, at
<code class="code">ev_sequence_continue</code>.
</p>
<p>The final expression in the sequence is handled differently, at the entry point
<code class="code">ev_sequence_last_exp</code>.  Since there are no more expressions to be
evaluated after this one, we need not save <code class="code">unev</code> or <code class="code">env</code> before
going to <code class="code">eval_dispatch</code>.  The value of the whole sequence is the value of
the last expression, so after the evaluation of the last expression there is
nothing left to do except continue at the entry point currently held on the
stack (which was saved by <code class="code">ev_application</code> or <code class="code">ev_begin</code>.)  Rather
than setting up <code class="code">continue</code> to arrange for <code class="code">eval_dispatch</code> to return
here and then restoring <code class="code">continue</code> from the stack and continuing at that
entry point, we restore <code class="code">continue</code> from the stack before going to
<code class="code">eval_dispatch</code>, so that <code class="code">eval_dispatch</code> will continue at that entry
point after evaluating the expression.
</p>
<div class="example">
<pre class="example-preformatted">// ev-sequence
Label(&quot;ev-sequence&quot;.into()),
Assign(&quot;exp&quot;.into(), Op(&quot;first-exp&quot;.into(), vec![Reg(&quot;unev&quot;.into())])),
Test(Op(&quot;is-last-exp&quot;.into(), vec![Reg(&quot;unev&quot;.into())])),
Branch(&quot;ev-sequence-last-exp&quot;.into()),
Save(&quot;unev&quot;.into()),
Save(&quot;env&quot;.into()),
Assign(&quot;continue&quot;.into(), Label(&quot;ev-sequence-continue&quot;.into())),
Goto(Label(&quot;eval-dispatch&quot;.into())),
Label(&quot;ev-sequence-continue&quot;.into()),
Restore(&quot;env&quot;.into()),
Restore(&quot;unev&quot;.into()),
Assign(&quot;unev&quot;.into(), Op(&quot;rest-exps&quot;.into(), vec![Reg(&quot;unev&quot;.into())])),
Goto(Label(&quot;ev-sequence&quot;.into())),
Label(&quot;ev-sequence-last-exp&quot;.into()),
Restore(&quot;continue&quot;.into()),
Goto(Label(&quot;eval-dispatch&quot;.into())),
</pre></div>

<h4 class="subsubheading" id="Tail-recursion"><span>Tail recursion<a class="copiable-link" href="#Tail-recursion"> &#182;</a></span></h4>

<p>In <a class="ref" href="Chapter-1.xhtml">Building Abstractions with Procedures</a> we said that the process described by a procedure such as
</p>
<div class="example">
<pre class="example-preformatted">fn sqrt_iter(guess: f64, x: f64) -&gt; f64 {
    if good_enough(guess, x) {
        guess
    } else {
        sqrt_iter(improve(guess, x), x)
    }
}
</pre></div>

<p>is an iterative process.  Even though the procedure is syntactically recursive
(defined in terms of itself), it is not logically necessary for an evaluator to
save information in passing from one call to <code class="code">sqrt-iter</code> to the
next.<a class="footnote" id="DOCF285" href="#FOOT285"><sup>285</sup></a> An evaluator that can execute a procedure such as
<code class="code">sqrt-iter</code> without requiring increasing storage as the procedure
continues to call itself is called a <a class="index-entry-id" id="index-tail_002drecursive-1"></a>
<em class="dfn">tail-recursive</em> evaluator.  The
metacircular implementation of the evaluator in <a class="ref" href="Chapter-4.xhtml">Metalinguistic Abstraction</a> does not
specify whether the evaluator is tail-recursive, because that evaluator
inherits its mechanism for saving state from the underlying Scheme.  With the
explicit-control evaluator, however, we can trace through the evaluation
process to see when procedure calls cause a net accumulation of information on
the stack.
</p>
<p>Our evaluator is tail-recursive, because in order to evaluate the final
expression of a sequence we transfer directly to <code class="code">eval_dispatch</code> without
saving any information on the stack.  Hence, evaluating the final expression in
a sequence&#8212;even if it is a procedure call (as in <code class="code">sqrt-iter</code>, where the
<code class="code">if</code> expression, which is the last expression in the procedure body,
reduces to a call to <code class="code">sqrt-iter</code>)&#8212;will not cause any information to be
accumulated on the stack.<a class="footnote" id="DOCF286" href="#FOOT286"><sup>286</sup></a>
</p>
<p>If we did not think to take advantage of the fact that it was unnecessary to
save information in this case, we might have implemented <code class="code">eval_sequence</code>
by treating all the expressions in a sequence in the same way&#8212;saving the
registers, evaluating the expression, returning to restore the registers, and
repeating this until all the expressions have been evaluated:<a class="footnote" id="DOCF287" href="#FOOT287"><sup>287</sup></a>
</p>
<div class="example">
<pre class="example-preformatted">// ev-sequence (non-tail-recursive)
Label(&quot;ev-sequence&quot;.into()),
Test(Op(&quot;no-more-exps?&quot;.into(), vec![Reg(&quot;unev&quot;.into())])),
Branch(&quot;ev-sequence-end&quot;.into()),
Assign(&quot;exp&quot;.into(), Op(&quot;first-exp&quot;.into(), vec![Reg(&quot;unev&quot;.into())])),
Save(&quot;unev&quot;.into()),
Save(&quot;env&quot;.into()),
Assign(&quot;continue&quot;.into(), Label(&quot;ev-sequence-continue&quot;.into())),
Goto(Label(&quot;eval-dispatch&quot;.into())),
Label(&quot;ev-sequence-continue&quot;.into()),
Restore(&quot;env&quot;.into()),
Restore(&quot;unev&quot;.into()),
Assign(&quot;unev&quot;.into(), Op(&quot;rest-exps&quot;.into(), vec![Reg(&quot;unev&quot;.into())])),
Goto(Label(&quot;ev-sequence&quot;.into())),
Label(&quot;ev-sequence-end&quot;.into()),
Restore(&quot;continue&quot;.into()),
Goto(Reg(&quot;continue&quot;.into())),
</pre></div>

<p>This may seem like a minor change to our previous code for evaluation of a
sequence: The only difference is that we go through the save-restore cycle for
the last expression in a sequence as well as for the others.  The interpreter
will still give the same value for any expression.  But this change is fatal to
the tail-recursive implementation, because we must now return after evaluating
the final expression in a sequence in order to undo the (useless) register
saves.  These extra saves will accumulate during a nest of procedure calls.
Consequently, processes such as <code class="code">sqrt-iter</code> will require space
proportional to the number of iterations rather than requiring constant space.
This difference can be significant.  For example, with tail recursion, an
infinite loop can be expressed using only the procedure-call mechanism:
</p>
<div class="example">
<pre class="example-preformatted">fn count(n: i64) -&gt; ! {
    println!(&quot;{}&quot;, n);
    count(n + 1)
}
</pre></div>

<p>Without tail recursion, such a procedure would eventually run out of stack
space, and expressing a true iteration would require some control mechanism
other than procedure call.
</p>
<hr />
</div>
<div class="subsection-level-extent" id="g_t5_002e4_002e2a">
<h4 class="subsection" id="SIMD-and-Auto_002dVectorization"><span>5.4.3 SIMD and Auto-Vectorization<a class="copiable-link" href="#SIMD-and-Auto_002dVectorization"> &#182;</a></span></h4>

<a class="index-entry-id" id="index-SIMD"></a>
<a class="index-entry-id" id="index-vectorization"></a>
<a class="index-entry-id" id="index-data-parallelism"></a>
<a class="index-entry-id" id="index-parallel-processing"></a>

<p>In our exploration of sequence operations and tail recursion (<a class="ref" href="#g_t5_002e4_002e2">Sequence Evaluation and Tail Recursion</a>), we
focused on how control flow and stack management affect program execution. But
modern processors offer another dimension of performance: <a class="index-entry-id" id="index-data-2"></a>
parallelism
<em class="dfn">data
parallelism</em> through <abbr class="abbr">SIMD</abbr> (Single Instruction, Multiple Data)
operations. Where tail recursion transforms recursive sequences into efficient
loops, <abbr class="abbr">SIMD</abbr> transforms scalar loops into parallel operations that process
multiple data elements simultaneously.
</p>
<p><abbr class="abbr">SIMD</abbr> represents a fundamental architectural feature of contemporary
processors, from x86&#8217;s <abbr class="abbr">AVX-512</abbr> to ARM&#8217;s <abbr class="abbr">NEON</abbr> and RISC-V&#8217;s vector
extensions. Understanding <abbr class="abbr">SIMD</abbr> illuminates the gap between our abstract
model of sequential computation and the reality of modern hardware, where
parallelism exists at every level—from instruction-level to core-level
parallelism.
</p>
<h4 class="subsubheading" id="What-Is-SIMD_003f"><span>What Is SIMD?<a class="copiable-link" href="#What-Is-SIMD_003f"> &#182;</a></span></h4>

<a class="index-entry-id" id="index-vector-operations"></a>
<a class="index-entry-id" id="index-parallel-arithmetic"></a>
<p>Single Instruction, Multiple Data means applying the same operation to multiple
data elements in parallel using a single instruction. Instead of processing one
number at a time, <abbr class="abbr">SIMD</abbr> instructions operate on <em class="emph">vectors</em> of numbers.
</p>
<p>Consider adding two arrays of floating-point numbers:
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">// Scalar code (one element at a time)
fn add_scalar(a: &amp;[f32], b: &amp;[f32], result: &amp;mut [f32]) {
    for i in 0..a.len() {
        result[i] = a[i] + b[i];
    }
}
</pre></div></div>

<p>On modern hardware, this could be processed four or eight elements at once:
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">// Conceptual SIMD code (multiple elements simultaneously)
// [a0, a1, a2, a3] + [b0, b1, b2, b3] = [c0, c1, c2, c3]
// All four additions happen in parallel
</pre></div></div>

<p>The speedup is proportional to the vector width: 4× with 128-bit <abbr class="abbr">SSE</abbr>
vectors, 8× with 256-bit <abbr class="abbr">AVX2</abbr>, or 16× with 512-bit <abbr class="abbr">AVX-512</abbr>. This
parallelism is <em class="emph">free</em>—a single instruction does the work of many.
</p>
<h4 class="subsubheading" id="Rust_0027s-portable_005fsimd"><span>Rust&#8217;s portable_simd<a class="copiable-link" href="#Rust_0027s-portable_005fsimd"> &#182;</a></span></h4>

<a class="index-entry-id" id="index-portable_005fsimd"></a>
<a class="index-entry-id" id="index-std_003a_003asimd"></a>
<a class="index-entry-id" id="index-platform-independence"></a>
<p>Rust&#8217;s <code class="code">std::simd</code> module (formerly <code class="code">portable_simd</code>, stabilized in
Edition 2024) provides platform-independent <abbr class="abbr">SIMD</abbr> programming. The
compiler maps generic <abbr class="abbr">SIMD</abbr> operations to the best available instruction
set on each target architecture.
</p>
<p>First, enable <abbr class="abbr">SIMD</abbr> in your <samp class="file">Cargo.toml</samp>:
</p>
<div class="example">
<pre class="example-preformatted">[dependencies]
# std::simd is stable in Edition 2024

[profile.release]
opt-level = 3
codegen-units = 1
lto = true
</pre></div>

<p>Now we can write portable <abbr class="abbr">SIMD</abbr> code:
</p>
<div class="example">
<pre class="example-preformatted">use std::simd::{f32x8, Simd};

fn add_vectors(a: &amp;[f32], b: &amp;[f32], result: &amp;mut [f32]) {
    let chunks = a.len() / 8;

    // Process 8 elements at a time
    for i in 0..chunks {
        let idx = i * 8;

        // Load 8 f32s into SIMD registers
        let va = Simd::&lt;f32, 8&gt;::from_slice(&amp;a[idx..]);
        let vb = Simd::&lt;f32, 8&gt;::from_slice(&amp;b[idx..]);

        // Parallel addition
        let vc = va + vb;

        // Store results
        vc.copy_to_slice(&amp;mut result[idx..]);
    }

    // Handle remainder elements
    for i in (chunks * 8)..a.len() {
        result[i] = a[i] + b[i];
    }
}
</pre></div>

<p>The type <code class="code">f32x8</code> represents a vector of eight 32-bit floats. Operations on
this type compile to parallel <abbr class="abbr">SIMD</abbr> instructions. On x86-64, the addition
<code class="code">va + vb</code> becomes a single <code class="code">vaddps</code> instruction operating on eight
floats simultaneously.
</p>
<h4 class="subsubheading" id="SIMD-Types-and-Operations"><span>SIMD Types and Operations<a class="copiable-link" href="#SIMD-Types-and-Operations"> &#182;</a></span></h4>

<a class="index-entry-id" id="index-SIMD-types"></a>
<a class="index-entry-id" id="index-vector-width"></a>
<p>Rust provides <abbr class="abbr">SIMD</abbr> vectors of various widths and element types:
</p>
<div class="example">
<pre class="example-preformatted">use std::simd::*;

// Floating-point vectors
let a: f32x4  = Simd::splat(1.0);  // [1.0, 1.0, 1.0, 1.0]
let b: f64x2  = Simd::from_array([2.0, 3.0]);

// Integer vectors
let c: i32x8  = Simd::from_array([1, 2, 3, 4, 5, 6, 7, 8]);
let d: u64x4  = Simd::splat(42);

// Common operations work element-wise
let sum = a + Simd::splat(2.0);     // [3.0, 3.0, 3.0, 3.0]
let prod = c * Simd::splat(2);       // [2, 4, 6, 8, 10, 12, 14, 16]
let max_vals = c.simd_max(Simd::splat(5));  // clamp to minimum 5
</pre></div>

<p>The generic <code class="code">Simd&lt;T, N&gt;</code> type has <code class="code">N</code> lanes of type <code class="code">T</code>. Type
aliases like <code class="code">f32x4</code> are provided for common sizes. The width <code class="code">N</code>
must be a power of two and supported by the target architecture (typically 2, 4,
8, 16, 32, or 64).
</p>
<p>Beyond arithmetic, <abbr class="abbr">SIMD</abbr> supports:
</p>
<div class="example">
<pre class="example-preformatted">// Comparisons produce mask vectors
let mask = a.simd_gt(Simd::splat(0.0));  // element-wise &gt; 0

// Masked selection (similar to ternary operator)
let result = mask.select(a, Simd::splat(0.0));  // max(a, 0)

// Reductions
let sum: f32 = a.reduce_sum();
let max: f32 = a.reduce_max();
let all_positive = a.simd_gt(Simd::splat(0.0)).all();
</pre></div>

<h4 class="subsubheading" id="Auto_002dVectorization_003a-When-the-Compiler-Does-It-for-You"><span>Auto-Vectorization: When the Compiler Does It for You<a class="copiable-link" href="#Auto_002dVectorization_003a-When-the-Compiler-Does-It-for-You"> &#182;</a></span></h4>

<a class="index-entry-id" id="index-auto_002dvectorization"></a>
<a class="index-entry-id" id="index-compiler-optimization"></a>
<a class="index-entry-id" id="index-LLVM"></a>
<p>Explicit <abbr class="abbr">SIMD</abbr> provides full control, but modern compilers can often
vectorize scalar code automatically. Rust&#8217;s <abbr class="abbr">LLVM</abbr> backend includes
sophisticated auto-vectorization passes that recognize vectorizable patterns.
</p>
<p>Consider this simple scalar code:
</p>
<div class="example">
<pre class="example-preformatted">pub fn scale_array(data: &amp;mut [f32], factor: f32) {
    for x in data.iter_mut() {
        *x *= factor;
    }
}
</pre></div>

<p>With optimization enabled (<code class="code">-C opt-level=3</code>), the compiler generates
<abbr class="abbr">SIMD</abbr> instructions automatically:
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">; Assembly output (x86-64, conceptual)
scale_array:
    vbroadcastss ymm0, xmm0    ; broadcast factor to 8-wide
.loop:
    vmulps       ymm1, ymm0, [rsi]  ; multiply 8 floats at once
    vmovups      [rsi], ymm1        ; store results
    add          rsi, 32            ; advance 8 * 4 bytes
    cmp          rsi, rdx
    jne          .loop
</pre></div></div>

<p>The compiler recognized the loop pattern and automatically generated code that
processes eight floats per iteration using <abbr class="abbr">AVX</abbr> instructions.
</p>
<p>Auto-vectorization works best when:
</p>
<ul class="itemize mark-bullet">
<li>Loops have no data dependencies between iterations
</li><li>Access patterns are regular and contiguous
</li><li>Iteration counts are known or bounded
</li><li>Operations are <abbr class="abbr">SIMD</abbr>-friendly (arithmetic, logical, min/max)
</li></ul>

<h4 class="subsubheading" id="Writing-Vectorization_002dFriendly-Code"><span>Writing Vectorization-Friendly Code<a class="copiable-link" href="#Writing-Vectorization_002dFriendly-Code"> &#182;</a></span></h4>

<a class="index-entry-id" id="index-vectorization-patterns"></a>
<a class="index-entry-id" id="index-performance-optimization"></a>
<p>Not all code vectorizes easily. Understanding what helps (and hurts)
auto-vectorization enables writing faster code without explicit <abbr class="abbr">SIMD</abbr>:
</p>
<p><strong class="strong">Good: Flat, contiguous iteration</strong>
</p>
<div class="example">
<pre class="example-preformatted">// Vectorizes well
fn sum_positive(data: &amp;[f32]) -&gt; f32 {
    data.iter()
        .copied()
        .filter(|&amp;x| x &gt; 0.0)
        .sum()
}
</pre></div>

<p><strong class="strong">Bad: Complex control flow</strong>
</p>
<div class="example">
<pre class="example-preformatted">// Hard to vectorize (branches per element)
fn complex_logic(data: &amp;[f32]) -&gt; f32 {
    let mut sum = 0.0;
    for &amp;x in data {
        if x &gt; 0.0 {
            if x &lt; 10.0 {
                sum += x * 2.0;
            } else {
                sum += x.sqrt();
            }
        }
    }
    sum
}
</pre></div>

<p><strong class="strong">Good: Branchless with masks</strong>
</p>
<div class="example">
<pre class="example-preformatted">// Vectorizable version using masking
fn complex_logic_vectorizable(data: &amp;[f32]) -&gt; f32 {
    data.iter()
        .map(|&amp;x| {
            let doubled = x * 2.0;
            let sqrted = x.sqrt();
            let use_sqrt = x &gt;= 10.0;
            let result = if use_sqrt { sqrted } else { doubled };
            if x &gt; 0.0 { result } else { 0.0 }
        })
        .sum()
}
</pre></div>

<p><strong class="strong">Use <code class="code">#[inline]</code> for small functions:</strong>
</p>
<div class="example">
<pre class="example-preformatted">#[inline]
fn process(x: f32) -&gt; f32 {
    x * x + 2.0 * x + 1.0
}

pub fn apply(data: &amp;mut [f32]) {
    for x in data.iter_mut() {
        *x = process(*x);  // Inlined, then vectorized
    }
}
</pre></div>

<h4 class="subsubheading" id="Benchmarking-SIMD-Improvements"><span>Benchmarking SIMD Improvements<a class="copiable-link" href="#Benchmarking-SIMD-Improvements"> &#182;</a></span></h4>

<a class="index-entry-id" id="index-benchmarking-1"></a>
<a class="index-entry-id" id="index-performance-measurement"></a>
<a class="index-entry-id" id="index-criterion"></a>
<p>To verify <abbr class="abbr">SIMD</abbr> benefits, benchmark with <code class="code">criterion</code>:
</p>
<div class="example">
<pre class="example-preformatted">use criterion::{black_box, criterion_group, criterion_main, Criterion};

fn bench_dot_product(c: &amp;mut Criterion) {
    let a: Vec&lt;f32&gt; = (0..10000).map(|i| i as f32).collect();
    let b: Vec&lt;f32&gt; = (0..10000).map(|i| (i * 2) as f32).collect();

    c.bench_function(&quot;dot_scalar&quot;, |bencher| {
        bencher.iter(|| {
            dot_product_scalar(black_box(&amp;a), black_box(&amp;b))
        })
    });

    c.bench_function(&quot;dot_simd&quot;, |bencher| {
        bencher.iter(|| {
            dot_product_simd(black_box(&amp;a), black_box(&amp;b))
        })
    });
}

fn dot_product_scalar(a: &amp;[f32], b: &amp;[f32]) -&gt; f32 {
    a.iter().zip(b).map(|(x, y)| x * y).sum()
}

fn dot_product_simd(a: &amp;[f32], b: &amp;[f32]) -&gt; f32 {
    use std::simd::f32x8;

    let mut sum = f32x8::splat(0.0);
    let chunks = a.len() / 8;

    for i in 0..chunks {
        let idx = i * 8;
        let va = f32x8::from_slice(&amp;a[idx..]);
        let vb = f32x8::from_slice(&amp;b[idx..]);
        sum += va * vb;  // Fused multiply-add
    }

    sum.reduce_sum() +
        a[chunks * 8..]
            .iter()
            .zip(&amp;b[chunks * 8..])
            .map(|(x, y)| x * y)
            .sum::&lt;f32&gt;()
}

criterion_group!(benches, bench_dot_product);
criterion_main!(benches);
</pre></div>

<p>Typical results show 4-8× speedup:
</p>
<div class="example">
<pre class="example-preformatted">dot_scalar    time:   [8.234 µs 8.267 µs 8.305 µs]
dot_simd      time:   [1.045 µs 1.052 µs 1.061 µs]
                      ↑ 7.8× faster
</pre></div>

<h4 class="subsubheading" id="Connection-to-Sequence-Operations"><span>Connection to Sequence Operations<a class="copiable-link" href="#Connection-to-Sequence-Operations"> &#182;</a></span></h4>

<a class="index-entry-id" id="index-sequence-processing"></a>
<a class="index-entry-id" id="index-functional-programming-2"></a>
<a class="index-entry-id" id="index-iterator-combinators"></a>
<p>The iterator combinators we&#8217;ve used throughout this book (<code class="code">map</code>,
<code class="code">filter</code>, <code class="code">fold</code>) compose beautifully with <abbr class="abbr">SIMD</abbr>. The key
insight is that <abbr class="abbr">SIMD</abbr> is itself a form of sequence processing—operating
on sequences of data in parallel.
</p>
<p>Consider <code class="code">map</code> over a slice:
</p>
<div class="example">
<pre class="example-preformatted">// Conceptual transformation
data.iter().map(|&amp;x| x * 2.0).collect()

// Sequential execution: [a, b, c, d] → [2a, 2b, 2c, 2d]
// Each element processed one at a time

// SIMD execution: [a, b, c, d] → [2a, 2b, 2c, 2d]
// All elements processed simultaneously
</pre></div>

<p>The operation is the same; only the execution strategy differs. This connection
runs deep: many <abbr class="abbr">SIMD</abbr> algorithms mirror functional programming patterns:
</p>
<div class="example">
<pre class="example-preformatted">// Map
vec.iter().map(|&amp;x| x * 2.0)
↔
Simd::splat(2.0) * simd_vec

// Filter (using masks)
vec.iter().filter(|&amp;&amp;x| x &gt; 0.0)
↔
mask.select(simd_vec, Simd::splat(0.0))

// Reduce
vec.iter().sum()
↔
simd_vec.reduce_sum()
</pre></div>

<p>The correspondence between sequential iterator operations and parallel
<abbr class="abbr">SIMD</abbr> operations reveals a fundamental unity: both are ways of expressing
bulk operations on sequences. <abbr class="abbr">SIMD</abbr> is the hardware embodiment of
&#8220;apply this operation to all elements&#8221;—the essence of <code class="code">map</code>.
</p>
<h4 class="subsubheading" id="SIMD-in-the-Real-World"><span>SIMD in the Real World<a class="copiable-link" href="#SIMD-in-the-Real-World"> &#182;</a></span></h4>

<a class="index-entry-id" id="index-applications"></a>
<a class="index-entry-id" id="index-use-cases"></a>
<p><abbr class="abbr">SIMD</abbr> achieves dramatic speedups in domains involving regular,
data-parallel computation:
</p>
<ul class="itemize mark-bullet">
<li><strong class="strong">Image processing:</strong> Filters, transformations, color space conversions
</li><li><strong class="strong">Signal processing:</strong> <abbr class="abbr">FFT</abbr>, convolution, correlation
</li><li><strong class="strong">Linear algebra:</strong> Matrix multiplication, vector operations (<abbr class="abbr">BLAS</abbr>)
</li><li><strong class="strong">Compression:</strong> Huffman coding, DEFLATE, video codecs
</li><li><strong class="strong">Cryptography:</strong> Block ciphers, hashing (when side-channel safe)
</li><li><strong class="strong">Machine learning:</strong> Inference, training, activation functions
</li></ul>

<p>Libraries like <code class="code">nalgebra</code> (linear algebra) and <code class="code">image</code> (image
processing) use <abbr class="abbr">SIMD</abbr> extensively under the hood, providing high-level
abstractions backed by low-level optimization.
</p>
<h4 class="subsubheading" id="Limitations-and-Caveats-1"><span>Limitations and Caveats<a class="copiable-link" href="#Limitations-and-Caveats-1"> &#182;</a></span></h4>

<a class="index-entry-id" id="index-SIMD-limitations"></a>
<a class="index-entry-id" id="index-portability"></a>
<p>While powerful, <abbr class="abbr">SIMD</abbr> has limitations:
</p>
<p><strong class="strong">Irregular data patterns:</strong> Scattered memory access patterns prevent
vectorization. Structures-of-arrays (<abbr class="abbr">SoA</abbr>) layout often vectorizes better
than array-of-structures (<abbr class="abbr">AoS</abbr>):
</p>
<div class="example">
<pre class="example-preformatted">// Array-of-Structures (AoS) - poor for SIMD
struct Point { x: f32, y: f32, z: f32 }
let points: Vec&lt;Point&gt; = ...;

// Structure-of-Arrays (SoA) - good for SIMD
struct Points {
    x: Vec&lt;f32&gt;,
    y: Vec&lt;f32&gt;,
    z: Vec&lt;f32&gt;,
}
</pre></div>

<p><strong class="strong">Branching:</strong> Heavy branching within vectorized loops reduces benefits.
Modern <abbr class="abbr">SIMD</abbr> has masked operations, but they still execute both paths.
</p>
<p><strong class="strong">Small datasets:</strong> Overhead of <abbr class="abbr">SIMD</abbr> setup can exceed benefits for
small inputs. Always benchmark.
</p>
<p><strong class="strong">Portability:</strong> While <code class="code">std::simd</code> is portable, not all vector widths
are available on all platforms. Feature detection may be needed:
</p>
<div class="example">
<pre class="example-preformatted">#[cfg(target_feature = &quot;avx2&quot;)]
fn fast_path(data: &amp;[f32]) -&gt; f32 {
    // Use 256-bit SIMD
}

#[cfg(not(target_feature = &quot;avx2&quot;))]
fn fast_path(data: &amp;[f32]) -&gt; f32 {
    // Fallback to scalar or 128-bit SIMD
}
</pre></div>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-5_002e24a"></a>Exercise 5.24a:</strong> Implement three versions of a
function that normalizes a vector (divides each element by the magnitude): (1) a
scalar version using iterators, (2) an explicitly vectorized version using
<code class="code">std::simd</code>, and (3) a version designed to trigger auto-vectorization.
Benchmark all three with <code class="code">criterion</code> for vectors of length 1,000, 10,000,
and 100,000. Use <code class="code">cargo asm</code> or <code class="code">cargo llvm-ir</code> to inspect the
generated assembly. How does the compiler&#8217;s auto-vectorized code compare to your
explicit <abbr class="abbr">SIMD</abbr> implementation? What patterns in your code helped or
hindered auto-vectorization?
</p></blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-5_002e25a"></a>Exercise 5.25a:</strong> The classic problem of computing
the Mandelbrot set is embarrassingly parallel at the pixel level but involves
complex iteration with early exit conditions. Implement a Mandelbrot set
renderer using <abbr class="abbr">SIMD</abbr> to compute multiple pixels simultaneously. The
challenge is handling the variable iteration count—different points escape at
different times. Experiment with two strategies: (1) using <abbr class="abbr">SIMD</abbr> masks to
&#8220;turn off&#8221; lanes that have escaped, continuing until all lanes finish, and (2)
processing points in batches sorted by their expected iteration count. Which
approach is faster? How does the performance compare to a scalar implementation?
What does this teach you about the interaction between control flow and data
parallelism?
</p></blockquote>

<hr />
</div>
<div class="subsection-level-extent" id="g_t5_002e4_002e3">
<h4 class="subsection" id="Conditionals_002c-Assignments_002c-and-Definitions"><span>5.4.4 Conditionals, Assignments, and Definitions<a class="copiable-link" href="#Conditionals_002c-Assignments_002c-and-Definitions"> &#182;</a></span></h4>

<p>As with the metacircular evaluator, special forms are handled by selectively
evaluating fragments of the expression.  For an <code class="code">if</code> expression, we must
evaluate the predicate and decide, based on the value of predicate, whether to
evaluate the consequent or the alternative.
</p>
<p>Before evaluating the predicate, we save the <code class="code">if</code> expression itself so
that we can later extract the consequent or alternative.  We also save the
environment, which we will need later in order to evaluate the consequent or
the alternative, and we save <code class="code">continue</code>, which we will need later in order
to return to the evaluation of the expression that is waiting for the value of
the <code class="code">if</code>.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">ev_if
  (save exp)   <span class="r">; save expression for later</span>
  (save env)
  (save continue)
  (assign continue (label ev_if_decide))
  (assign exp (op if_predicate) (reg exp))
  <span class="r">; evaluate the predicate:</span>
  (goto (label eval_dispatch))
</pre></div>

<p>When we return from evaluating the predicate, we test whether it was true or
false and, depending on the result, place either the consequent or the
alternative in <code class="code">exp</code> before going to <code class="code">eval_dispatch</code>.  Notice that
restoring <code class="code">env</code> and <code class="code">continue</code> here sets up <code class="code">eval_dispatch</code> to
have the correct environment and to continue at the right place to receive the
value of the <code class="code">if</code> expression.
</p>
<div class="example">
<pre class="example-preformatted">// ev-if-decide
Label(&quot;ev-if-decide&quot;.into()),
Restore(&quot;continue&quot;.into()),
Restore(&quot;env&quot;.into()),
Restore(&quot;exp&quot;.into()),
Test(Op(&quot;is-true&quot;.into(), vec![Reg(&quot;val&quot;.into())])),
Branch(&quot;ev-if-consequent&quot;.into()),
Label(&quot;ev-if-alternative&quot;.into()),
Assign(&quot;exp&quot;.into(), Op(&quot;if-alternative&quot;.into(), vec![Reg(&quot;exp&quot;.into())])),
Goto(Label(&quot;eval-dispatch&quot;.into())),
Label(&quot;ev-if-consequent&quot;.into()),
Assign(&quot;exp&quot;.into(), Op(&quot;if-consequent&quot;.into(), vec![Reg(&quot;exp&quot;.into())])),
Goto(Label(&quot;eval-dispatch&quot;.into())),
</pre></div>

<h4 class="subsubheading" id="Assignments-and-definitions-1"><span>Assignments and definitions<a class="copiable-link" href="#Assignments-and-definitions-1"> &#182;</a></span></h4>

<p>Assignments are handled by <code class="code">ev_assignment</code>, which is reached from
<code class="code">eval_dispatch</code> with the assignment expression in <code class="code">exp</code>.  The code at
<code class="code">ev_assignment</code> first evaluates the value part of the expression and then
installs the new value in the environment.  <code class="code">Set-variable-value!</code> is
assumed to be available as a machine operation.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">ev_assignment
  (assign unev
          (op assignment_variable)
          (reg exp))
  (save unev)   <span class="r">; save variable for later</span>
  (assign exp
          (op assignment_value)
          (reg exp))
  (save env)
  (save continue)
  (assign continue
          (label ev_assignment_1))
  <span class="r">; evaluate the assignment value:</span>
  (goto (label eval_dispatch))
ev_assignment_1
  (restore continue)
  (restore env)
  (restore unev)
  (perform (op set_variable_value)
           (reg unev)
           (reg val)
           (reg env))
  (assign val
          (const ok))
  (goto (reg continue))
</pre></div>

<p>Definitions are handled in a similar way:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">ev_definition
  (assign unev
          (op definition_variable)
          (reg exp))
  (save unev)   <span class="r">; save variable for later</span>
  (assign exp
          (op definition_value)
          (reg exp))
  (save env)
  (save continue)
  (assign continue (label ev_definition_1))
  <span class="r">; evaluate the definition value:</span>
  (goto (label eval_dispatch))
ev_definition_1
  (restore continue)
  (restore env)
  (restore unev)
  (perform (op define_variable)
           (reg unev)
           (reg val)
           (reg env))
  (assign val (const ok))
  (goto (reg continue))
</pre></div>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-5_002e23"></a>Exercise 5.23:</strong> Extend the evaluator to handle
derived expressions such as <code class="code">cond</code>, <code class="code">let</code>, and so on
(<a class="ref" href="4_002e1.xhtml#g_t4_002e1_002e2">Representing Expressions</a>).  You may &#8220;cheat&#8221; and assume that the syntax transformers such
as <code class="code">cond_to_if</code> are available as machine operations.<a class="footnote" id="DOCF288" href="#FOOT288"><sup>288</sup></a>
</p></blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-5_002e24"></a>Exercise 5.24:</strong> Implement <code class="code">cond</code> as a new
basic special form without reducing it to <code class="code">if</code>.  You will have to
construct a loop that tests the predicates of successive <code class="code">cond</code> clauses
until you find one that is true, and then use <code class="code">ev_sequence</code> to evaluate
the actions of the clause.
</p></blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-5_002e25"></a>Exercise 5.25:</strong> Modify the evaluator so that it
uses normal-order evaluation, based on the lazy evaluator of <a class="ref" href="4_002e2.xhtml#g_t4_002e2">Variations on a Scheme &#8212; Lazy Evaluation</a>.
</p></blockquote>

<hr />
</div>
<div class="subsection-level-extent" id="g_t5_002e4_002e4">
<h4 class="subsection" id="Running-the-Evaluator"><span>5.4.5 Running the Evaluator<a class="copiable-link" href="#Running-the-Evaluator"> &#182;</a></span></h4>

<p>With the implementation of the explicit-control evaluator we come to the end of
a development, begun in <a class="ref" href="Chapter-1.xhtml">Building Abstractions with Procedures</a>, in which we have explored successively
more precise models of the evaluation process.  We started with the relatively
informal substitution model, then extended this in <a class="ref" href="Chapter-3.xhtml">Modularity, Objects, and State</a> to the
environment model, which enabled us to deal with state and change.  In the
metacircular evaluator of <a class="ref" href="Chapter-4.xhtml">Metalinguistic Abstraction</a>, we used Scheme itself as a language
for making more explicit the environment structure constructed during
evaluation of an expression.  Now, with register machines, we have taken a
close look at the evaluator&#8217;s mechanisms for storage management, argument
passing, and control.  At each new level of description, we have had to raise
issues and resolve ambiguities that were not apparent at the previous, less
precise treatment of evaluation.  To understand the behavior of the
explicit-control evaluator, we can simulate it and monitor its performance.
</p>
<p>We will install a driver loop in our evaluator machine.  This plays the role of
the <code class="code">driver_loop</code> procedure of <a class="ref" href="4_002e1.xhtml#g_t4_002e1_002e4">Running the Evaluator as a Program</a>.  The evaluator will
repeatedly print a prompt, read an expression, evaluate the expression by going
to <code class="code">eval_dispatch</code>, and print the result.  The following instructions form
the beginning of the explicit-control evaluator&#8217;s controller
sequence:<a class="footnote" id="DOCF289" href="#FOOT289"><sup>289</sup></a>
</p>
<div class="example lisp">
<pre class="lisp-preformatted">read_eval_print_loop
  (perform (op initialize_stack))
  (perform (op prompt_for_input)
           (const &quot;;;; EC-Eval input:&quot;))
  (assign exp (op read))
  (assign env (op get_global_environment))
  (assign continue (label print_result))
  (goto (label eval_dispatch))
print_result
  (perform (op announce_output)
           (const &quot;;;; EC-Eval value:&quot;))
  (perform (op user_print) (reg val))
  (goto (label read_eval_print_loop))
</pre></div>

<p>When we encounter an error in a procedure (such as the &#8220;unknown procedure type
error&#8221; indicated at <code class="code">apply_dispatch</code>), we print an error message and
return to the driver loop.<a class="footnote" id="DOCF290" href="#FOOT290"><sup>290</sup></a>
</p>
<div class="example lisp">
<pre class="lisp-preformatted">unknown_expression_type
  (assign
   val
   (const unknown_expression_type_error))
  (goto (label signal_error))
unknown_procedure_type
  <span class="r">; clean up stack (from <code class="code">apply_dispatch</code>):</span>
  (restore continue)
  (assign
   val
   (const unknown_procedure_type_error))
  (goto (label signal_error))
signal_error
  (perform (op user_print) (reg val))
  (goto (label read_eval_print_loop))
</pre></div>

<p>For the purposes of the simulation, we initialize the stack each time through
the driver loop, since it might not be empty after an error (such as an
undefined variable) interrupts an evaluation.<a class="footnote" id="DOCF291" href="#FOOT291"><sup>291</sup></a>
</p>
<p>If we combine all the code fragments presented in
<a class="ref" href="#g_t5_002e4_002e1">The Core of the Explicit-Control Evaluator</a>&#8211;<a class="ref" href="#g_t5_002e4_002e4">Running the Evaluator</a>, we can create an evaluator machine model that we can
run using the register-machine simulator of <a class="ref" href="5_002e2.xhtml#g_t5_002e2">A Register-Machine Simulator</a>.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">let mut eceval = make_machine(
    vec![&quot;exp&quot;, &quot;env&quot;, &quot;val&quot;, &quot;proc&quot;, &quot;argl&quot;, &quot;continue&quot;, &quot;unev&quot;],
    eceval_operations,
    vec![
        Inst::Label(&quot;read_eval_print_loop&quot;.to_string()),
        // ... entire machine controller as given above ...
    ],
);
</pre></div>

<p>We must define Scheme procedures to simulate the operations used as primitives
by the evaluator.  These are the same procedures we used for the metacircular
evaluator in <a class="ref" href="4_002e1.xhtml#g_t4_002e1">The Metacircular Evaluator</a>, together with the few additional ones defined
in footnotes throughout <a class="ref" href="#g_t5_002e4">The Explicit-Control Evaluator</a>.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">let eceval_operations = vec![
    (&quot;is_self_evaluating&quot;, is_self_evaluating),
    // ... complete list of operations for eceval machine ...
];
</pre></div>

<p>Finally, we can initialize the global environment and run the evaluator:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">let global_env = setup_environment();

eceval.start();

<i class="i">;;; EC-Eval input:</i>
fn append(x, y) {
    if x.is_null() { y } else { cons(x.car(), append(x.cdr(), y)) }
}

<i class="i">;;; EC-Eval value:</i>
<i class="i">ok</i>

<i class="i">;;; EC-Eval input:</i>
append(list(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;), list(&quot;d&quot;, &quot;e&quot;, &quot;f&quot;))

<i class="i">;;; EC-Eval value:</i>
<i class="i">(a b c d e f)</i>
</pre></div>

<p>Of course, evaluating expressions in this way will take much longer than if we
had directly typed them into Scheme, because of the multiple levels of
simulation involved.  Our expressions are evaluated by the
explicit-control-evaluator machine, which is being simulated by a Scheme
program, which is itself being evaluated by the Scheme interpreter.
</p>
<h4 class="subsubheading" id="Monitoring-the-performance-of-the-evaluator"><span>Monitoring the performance of the evaluator<a class="copiable-link" href="#Monitoring-the-performance-of-the-evaluator"> &#182;</a></span></h4>

<p>Simulation can be a powerful tool to guide the implementation of evaluators.
Simulations make it easy not only to explore variations of the register-machine
design but also to monitor the performance of the simulated evaluator.  For
example, one important factor in performance is how efficiently the evaluator
uses the stack.  We can observe the number of stack operations required to
evaluate various expressions by defining the evaluator register machine with
the version of the simulator that collects statistics on stack use
(<a class="ref" href="5_002e2.xhtml#g_t5_002e2_002e4">Monitoring Machine Performance</a>), and adding an instruction at the evaluator&#8217;s <code class="code">print_result</code>
entry point to print the statistics:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">print_result
  <span class="r">; added instruction:</span>
  (perform (op print_stack_statistics))
  (perform (op announce_output)
           (const &quot;;;; EC-Eval value:&quot;))
  <span class="r">…</span> <span class="r">; same as before</span>
</pre></div>

<p>Interactions with the evaluator now look like this:
</p>
<div class="example lisp">
<pre class="lisp-preformatted"><i class="i">;;; EC-Eval input:</i>
fn factorial(n) {
    if n == 1 { 1 } else { factorial(n - 1) * n }
}
<i class="i">(total-pushes = 3, maximum-depth = 3)</i>

<i class="i">;;; EC-Eval value:</i>
<i class="i">ok</i>

<i class="i">;;; EC-Eval input:</i>
factorial(5)
<i class="i">(total-pushes = 144, maximum-depth = 28)</i>

<i class="i">;;; EC-Eval value:</i>
<i class="i">120</i>
</pre></div>

<p>Note that the driver loop of the evaluator reinitializes the stack at the start
of each interaction, so that the statistics printed will refer only to stack
operations used to evaluate the previous expression.
</p>
<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-5_002e26"></a>Exercise 5.26:</strong> Use the monitored stack to
explore the tail-recursive property of the evaluator (<a class="ref" href="#g_t5_002e4_002e2">Sequence Evaluation and Tail Recursion</a>).
Start the evaluator and define the iterative <code class="code">factorial</code> procedure from
<a class="ref" href="1_002e2.xhtml#g_t1_002e2_002e1">Linear Recursion and Iteration</a>:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">fn factorial(n: u64) -&gt; u64 {
    fn iter(product: u64, counter: u64) -&gt; u64 {
        if counter &gt; n {
            product
        } else {
            iter(counter * product, counter + 1)
        }
    }
    iter(1, 1)
}
</pre></div>

<p>Run the procedure with some small values of <em class="math">n</em>.  Record the maximum stack
depth and the number of pushes required to compute <em class="math">{n!}</em> for each of these
values.
</p>
<ol class="enumerate" type="a" start="1">
<li> You will find that the maximum depth required to evaluate <em class="math">{n!}</em> is independent
of <em class="math">n</em>.  What is that depth?

</li><li> Determine from your data a formula in terms of <em class="math">n</em> for the total number of
push operations used in evaluating <em class="math">{n!}</em> for any <em class="math">{n ≥ 1}</em>.  Note that the
number of operations used is a linear function of <em class="math">n</em> and is thus determined
by two constants.

</li></ol>
</blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-5_002e27"></a>Exercise 5.27:</strong> For comparison with <a class="ref" href="#Exercise-5_002e26">Exercise 5.26</a>,
explore the behavior of the following procedure for computing factorials
recursively:
</p>
<div class="example">
<pre class="example-preformatted">fn factorial(n: i64) -&gt; i64 {
    if n == 1 { 1 } else { factorial(n - 1) * n }
}
</pre></div>

<p>By running this procedure with the monitored stack, determine, as a function of
<em class="math">n</em>, the maximum depth of the stack and the total number of pushes used in
evaluating <em class="math">{n!}</em> for <em class="math">{n ≥ 1}</em>.  (Again, these functions will be linear.)
Summarize your experiments by filling in the following table with the
appropriate expressions in terms of <em class="math">n</em>:
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
  <mtable columnalign="left left left" columnspacing="1em" rowspacing="4pt" columnlines="solid solid" rowlines="none solid none solid none">
    <mtr>
      <mtd></mtd>
      <mtd>
        <mi>a</mi>
        <mi>m</mi>
        <mi>p</mi>
        <mo>;</mo>
        <mtext>Maximum</mtext>
      </mtd>
      <mtd>
        <mi>a</mi>
        <mi>m</mi>
        <mi>p</mi>
        <mo>;</mo>
        <mtext>Number of</mtext>
      </mtd>
    </mtr>
    <mtr>
      <mtd></mtd>
      <mtd>
        <mi>a</mi>
        <mi>m</mi>
        <mi>p</mi>
        <mo>;</mo>
        <mtext>depth</mtext>
      </mtd>
      <mtd>
        <mi>a</mi>
        <mi>m</mi>
        <mi>p</mi>
        <mo>;</mo>
        <mtext>pushes</mtext>
      </mtd>
    </mtr>
    <mtr>
      <mtd>
        <mtext>Recursive</mtext>
      </mtd>
      <mtd>
        <mi>a</mi>
        <mi>m</mi>
        <mi>p</mi>
        <mo>;</mo>
      </mtd>
      <mtd>
        <mi>a</mi>
        <mi>m</mi>
        <mi>p</mi>
        <mo>;</mo>
      </mtd>
    </mtr>
    <mtr>
      <mtd>
        <mtext>factorial</mtext>
      </mtd>
      <mtd>
        <mi>a</mi>
        <mi>m</mi>
        <mi>p</mi>
        <mo>;</mo>
      </mtd>
      <mtd>
        <mi>a</mi>
        <mi>m</mi>
        <mi>p</mi>
        <mo>;</mo>
      </mtd>
    </mtr>
    <mtr>
      <mtd>
        <mtext>Iterative</mtext>
      </mtd>
      <mtd>
        <mi>a</mi>
        <mi>m</mi>
        <mi>p</mi>
        <mo>;</mo>
      </mtd>
      <mtd>
        <mi>a</mi>
        <mi>m</mi>
        <mi>p</mi>
        <mo>;</mo>
      </mtd>
    </mtr>
    <mtr>
      <mtd>
        <mtext>factorial</mtext>
      </mtd>
      <mtd>
        <mi>a</mi>
        <mi>m</mi>
        <mi>p</mi>
        <mo>;</mo>
      </mtd>
      <mtd>
        <mi>a</mi>
        <mi>m</mi>
        <mi>p</mi>
        <mo>;</mo>
      </mtd>
    </mtr>
  </mtable>
</math>
The maximum depth is a measure of the amount of space used by the evaluator in
carrying out the computation, and the number of pushes correlates well with the
time required.
</p></blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-5_002e28"></a>Exercise 5.28:</strong> Modify the definition of the
evaluator by changing <code class="code">eval_sequence</code> as described in <a class="ref" href="#g_t5_002e4_002e2">Sequence Evaluation and Tail Recursion</a>
so that the evaluator is no longer tail-recursive.  Rerun your experiments from
<a class="ref" href="#Exercise-5_002e26">Exercise 5.26</a> and <a class="ref" href="#Exercise-5_002e27">Exercise 5.27</a> to demonstrate that both versions
of the <code class="code">factorial</code> procedure now require space that grows linearly with
their input.
</p></blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-5_002e29"></a>Exercise 5.29:</strong> Monitor the stack operations in
the tree-recursive Fibonacci computation:
</p>
<div class="example">
<pre class="example-preformatted">fn fib(n: u64) -&gt; u64 {
    if n &lt; 2 { n } else { fib(n - 1) + fib(n - 2) }
}
</pre></div>

<ol class="enumerate" type="a" start="1">
<li> Give a formula in terms of <em class="math">n</em> for the maximum depth of the stack required to
compute <em class="math">{Fib(n)}</em> for <em class="math">{n ≥ 2}</em>.  Hint: In <a class="ref" href="1_002e2.xhtml#g_t1_002e2_002e2">Tree Recursion</a> we
argued that the space used by this process grows linearly with <em class="math">n</em>.

</li><li> Give a formula for the total number of pushes used to compute <em class="math">{Fib(n)}</em>
for <em class="math">{n ≥ 2}</em>.  You should find that the number of pushes (which correlates
well with the time used) grows exponentially with <em class="math">n</em>.  Hint: Let
<em class="math">{S(n)}</em> be the number of pushes used in computing <em class="math">{Fib(n)}</em>.  You
should be able to argue that there is a formula that expresses <em class="math">{S(n)}</em> in
terms of <em class="math">{S(n - 1)}</em>, <em class="math">{S(n - 2)}</em>, and some fixed &#8220;overhead&#8221;
constant <em class="math">k</em> that is independent of <em class="math">n</em>.  Give the formula, and say what
<em class="math">k</em> is.  Then show that <em class="math">{S(n)}</em> can be expressed as
<em class="math">{a·Fib(n + 1) + b}</em> and give the values of <em class="math">a</em> and <em class="math">b</em>.

</li></ol>
</blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-5_002e30"></a>Exercise 5.30:</strong> Our evaluator currently catches
and signals only two kinds of errors&#8212;unknown expression types and unknown
procedure types.  Other errors will take us out of the evaluator
read-eval-print loop.  When we run the evaluator using the register-machine
simulator, these errors are caught by the underlying Scheme system.  This is
analogous to the computer crashing when a user program makes an
error.<a class="footnote" id="DOCF292" href="#FOOT292"><sup>292</sup></a>  It is a
large project to make a real error system work, but it is well worth the effort
to understand what is involved here.
</p>
<ol class="enumerate" type="a" start="1">
<li> Errors that occur in the evaluation process, such as an attempt to access an
unbound variable, could be caught by changing the lookup operation to make it
return a distinguished condition code, which cannot be a possible value of any
user variable.  The evaluator can test for this condition code and then do what
is necessary to go to <code class="code">signal_error</code>.  Find all of the places in the
evaluator where such a change is necessary and fix them.  This is lots of work.

</li><li> Much worse is the problem of handling errors that are signaled by applying
primitive procedures, such as an attempt to divide by zero or an attempt to
extract the <code class="code">car</code> of a symbol.  In a professionally written high-quality
system, each primitive application is checked for safety as part of the
primitive.  For example, every call to <code class="code">car</code> could first check that the
argument is a pair.  If the argument is not a pair, the application would
return a distinguished condition code to the evaluator, which would then report
the failure.  We could arrange for this in our register-machine simulator by
making each primitive procedure check for applicability and returning an
appropriate distinguished condition code on failure. Then the
<code class="code">primitive_apply</code> code in the evaluator can check for the condition code
and go to <code class="code">signal_error</code> if necessary.  Build this structure and make it
work.  This is a major project.

</li></ol>
</blockquote>

</div>
</div>
<div class="footnotes-segment">
<hr />
<h4 class="footnotes-heading">Footnotes</h4>

<h5 class="footnote-body-heading"><a id="FOOT283" href="#DOCF283">(283)</a></h5>
<p>The optimization of treating the last operand specially
is known as <a class="index-entry-id" id="index-evlis-tail-recursion"></a>
<em class="dfn">evlis tail recursion</em> (see <a class="ref" href="References.xhtml#Wand-1980">Wand 1980</a>).  We could be
somewhat more efficient in the argument evaluation loop if we made evaluation
of the first operand a special case too.  This would permit us to postpone
initializing <code class="code">argl</code> until after evaluating the first operand, so as to
avoid saving <code class="code">argl</code> in this case.  The compiler in <a class="ref" href="5_002e5.xhtml#g_t5_002e5">Compilation</a>
performs this optimization.  (Compare the <code class="code">construct_arglist</code> procedure of
<a class="ref" href="5_002e5.xhtml#g_t5_002e5_002e3">Compiling Combinations</a>.)</p>
<h5 class="footnote-body-heading"><a id="FOOT284" href="#DOCF284">(284)</a></h5>
<p>The order of operand
evaluation in the metacircular evaluator is determined by the order of
evaluation of the arguments to <code class="code">cons</code> in the procedure
<code class="code">list_of_values</code> of <a class="ref" href="4_002e1.xhtml#g_t4_002e1_002e1">The Core of the Evaluator</a> (see <a class="ref" href="4_002e1.xhtml#Exercise-4_002e1">Exercise 4.1</a>).</p>
<h5 class="footnote-body-heading"><a id="FOOT285" href="#DOCF285">(285)</a></h5>
<p>We saw in <a class="ref" href="5_002e1.xhtml#g_t5_002e1">Designing Register Machines</a> how to implement such a process with
a register machine that had no stack; the state of the process was stored in a
fixed set of registers.</p>
<h5 class="footnote-body-heading"><a id="FOOT286" href="#DOCF286">(286)</a></h5>
<p>This implementation of tail recursion in
<code class="code">ev_sequence</code> is one variety of a well-known optimization technique used
by many compilers.  In compiling a procedure that ends with a procedure call,
one can replace the call by a jump to the called procedure&#8217;s entry point.
Building this strategy into the interpreter, as we have done in this section,
provides the optimization uniformly throughout the language.</p>
<h5 class="footnote-body-heading"><a id="FOOT287" href="#DOCF287">(287)</a></h5>
<p>We can
define <code class="code">no-more-exps?</code> as follows:
</p>
<div class="example">
<pre class="example-preformatted">fn is_no_more_exps(seq: &amp;[Expr]) -&gt; bool {
    seq.is_empty()
}
</pre></div>
<h5 class="footnote-body-heading"><a id="FOOT288" href="#DOCF288">(288)</a></h5>
<p>This isn&#8217;t
really cheating.  In an actual implementation built from scratch, we would use
our explicit-control evaluator to interpret a Scheme program that performs
source-level transformations like <code class="code">cond_to_if</code> in a syntax phase that runs
before execution.</p>
<h5 class="footnote-body-heading"><a id="FOOT289" href="#DOCF289">(289)</a></h5>
<p>We assume here that <code class="code">read</code> and the various printing
operations are available as primitive machine operations, which is useful for
our simulation, but completely unrealistic in practice.  These are actually
extremely complex operations.  In practice, they would be implemented using
low-level input-output operations such as transferring single characters to and
from a device.
</p>
<p>To support the <code class="code">get_global_environment</code> operation we define
</p>
<div class="example lisp">
<pre class="lisp-preformatted">let global_env = setup_environment();

fn get_global_environment() -&gt; Environment {
    global_env.clone()
}
</pre></div>
<h5 class="footnote-body-heading"><a id="FOOT290" href="#DOCF290">(290)</a></h5>
<p>There are other errors that we would like
the interpreter to handle, but these are not so simple.  See <a class="ref" href="#Exercise-5_002e30">Exercise 5.30</a>.</p>
<h5 class="footnote-body-heading"><a id="FOOT291" href="#DOCF291">(291)</a></h5>
<p>We could perform the
stack initialization only after errors, but doing it in the driver loop will be
convenient for monitoring the evaluator&#8217;s performance, as described below.</p>
<h5 class="footnote-body-heading"><a id="FOOT292" href="#DOCF292">(292)</a></h5>
<p>Regrettably, this is the normal state of affairs in
conventional compiler-based language systems such as C.  In <abbr class="abbr">UNIX</abbr>(tm)
the system &#8220;dumps core,&#8221; and in <abbr class="abbr">DOS</abbr>/Windows(tm) it becomes
catatonic.  The Macintosh(tm) displays a picture of an exploding bomb and
offers you the opportunity to reboot the computer&#8212;if you&#8217;re lucky.</p>
</div>
<hr />
<div class="nav-panel">
<p>
Next: <a href="5_002e5.xhtml#g_t5_002e5" accesskey="n" rel="next">Compilation</a>, Previous: <a href="5_002e3.xhtml#g_t5_002e3_002e3" accesskey="p" rel="prev">Ownership as Compile-Time Garbage Collection</a>, Up: <a href="Chapter-5.xhtml" accesskey="u" rel="up">Computing with Register Machines</a> &#160; [<a href="index.xhtml#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Term-Index.xhtml" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
