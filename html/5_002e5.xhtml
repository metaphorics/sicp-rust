<!DOCTYPE html>
<html>
<!-- Created by GNU Texinfo 7.1, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>5.5 (Structure and Interpretation of Computer Programs, 2e)</title>

<meta name="description" content="5.5 (Structure and Interpretation of Computer Programs, 2e)">
<meta name="keywords" content="5.5 (Structure and Interpretation of Computer Programs, 2e)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2any">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="index.xhtml" rel="start" title="Top">
<link href="Term-Index.xhtml" rel="index" title="Term Index">
<link href="index.xhtml#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Chapter-5.xhtml" rel="up" title="Chapter 5">
<link href="References.xhtml" rel="next" title="References">
<link href="5_002e4.xhtml#g_t5_002e4" rel="prev" title="5.4">
<style type="text/css">
<!--
a.copiable-link {visibility: hidden; text-decoration: none; line-height: 0em}
div.example {margin-left: 3.2em}
span.r {font-family: initial; font-weight: normal; font-style: normal}
span:hover a.copiable-link {visibility: visible}
ul.mark-bullet {list-style-type: disc}
-->
</style>

<script src="js/jquery.min.js" type="text/javascript"></script>
<script src="js/footnotes.js" type="text/javascript"></script>
<script src="js/browsertest.js" type="text/javascript"></script>
</head>

<body lang="en">
<div class="section-level-extent" id="g_t5_002e5">
<div class="nav-panel">
<p>
Next: <a href="References.xhtml" accesskey="n" rel="next">References</a>, Previous: <a href="5_002e4.xhtml#g_t5_002e4" accesskey="p" rel="prev">The Explicit-Control Evaluator</a>, Up: <a href="Chapter-5.xhtml" accesskey="u" rel="up">Computing with Register Machines</a> &nbsp; [<a href="index.xhtml#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Term-Index.xhtml" title="Index" rel="index">Index</a>]</p>
</div>
<h3 class="section" id="Compilation"><span>5.5 Compilation<a class="copiable-link" href="#Compilation"> &para;</a></span></h3>

<p>The explicit-control evaluator of <a class="ref" href="5_002e4.xhtml#g_t5_002e4">The Explicit-Control Evaluator</a> is a register machine whose
controller interprets Scheme programs.  In this section we will see how to run
Scheme programs on a register machine whose controller is not a Scheme
interpreter.
</p>
<p>The explicit-control evaluator machine is universal&mdash;it can carry out any
computational process that can be described in Scheme.  The evaluator&rsquo;s
controller orchestrates the use of its data paths to perform the desired
computation.  Thus, the evaluator&rsquo;s data paths are universal: They are
sufficient to perform any computation we desire, given an appropriate
controller.<a class="footnote" id="DOCF293" href="#FOOT293"><sup>293</sup></a>
</p>
<p>Commercial general-purpose computers are register machines organized around a
collection of registers and operations that constitute an efficient and
convenient universal set of data paths.  The controller for a general-purpose
machine is an interpreter for a register-machine language like the one we have
been using.  This language is called the <a class="index-entry-id" id="index-native-language"></a>
<em class="dfn">native language</em> of the
machine, or simply <a class="index-entry-id" id="index-machine-language"></a>
<em class="dfn">machine language</em>.  Programs written in machine
language are sequences of instructions that use the machine&rsquo;s data paths.  For
example, the explicit-control evaluator&rsquo;s instruction sequence can be thought
of as a machine-language program for a general-purpose computer rather than as
the controller for a specialized interpreter machine.
</p>
<p>There are two common strategies for bridging the gap between higher-level
languages and register-machine languages.  The explicit-control evaluator
illustrates the strategy of interpretation.  An interpreter written in the
native language of a machine configures the machine to execute programs written
in a language (called the <a class="index-entry-id" id="index-source-language"></a>
<em class="dfn">source language</em>) that may differ from the
native language of the machine performing the evaluation.  The primitive
procedures of the source language are implemented as a library of subroutines
written in the native language of the given machine.  A program to be
interpreted (called the <a class="index-entry-id" id="index-source-program"></a>
<em class="dfn">source program</em>) is represented as a data
structure.  The interpreter traverses this data structure, analyzing the source
program.  As it does so, it simulates the intended behavior of the source
program by calling appropriate primitive subroutines from the library.
</p>
<p>In this section, we explore the alternative strategy of <a class="index-entry-id" id="index-compilation"></a>
<em class="dfn">compilation</em>.
A compiler for a given source language and machine translates a source program
into an equivalent program (called the <a class="index-entry-id" id="index-object-program"></a>
<em class="dfn">object program</em>) written in the
machine&rsquo;s native language.  The compiler that we implement in this section
translates programs written in Scheme into sequences of instructions to be
executed using the explicit-control evaluator machine&rsquo;s data
paths.<a class="footnote" id="DOCF294" href="#FOOT294"><sup>294</sup></a>
</p>
<p>Compared with interpretation, compilation can provide a great increase in the
efficiency of program execution, as we will explain below in the overview of
the compiler.  On the other hand, an interpreter provides a more powerful
environment for interactive program development and debugging, because the
source program being executed is available at run time to be examined and
modified.  In addition, because the entire library of primitives is present,
new programs can be constructed and added to the system during debugging.
</p>
<p>In view of the complementary advantages of compilation and interpretation,
modern program-development environments pursue a mixed strategy.  Lisp
interpreters are generally organized so that interpreted procedures and
compiled procedures can call each other.  This enables a programmer to compile
those parts of a program that are assumed to be debugged, thus gaining the
efficiency advantage of compilation, while retaining the interpretive mode of
execution for those parts of the program that are in the flux of interactive
development and debugging.  In <a class="ref" href="#g_t5_002e5_002e7">Interfacing Compiled Code to the Evaluator</a>, after we have implemented
the compiler, we will show how to interface it with our interpreter to produce
an integrated interpreter-compiler development system.
</p>
<h4 class="subsubheading" id="An-overview-of-the-compiler"><span>An overview of the compiler<a class="copiable-link" href="#An-overview-of-the-compiler"> &para;</a></span></h4>

<p>Our compiler is much like our interpreter, both in its structure and in the
function it performs.  Accordingly, the mechanisms used by the compiler for
analyzing expressions will be similar to those used by the interpreter.
Moreover, to make it easy to interface compiled and interpreted code, we will
design the compiler to generate code that obeys the same conventions of
register usage as the interpreter: The environment will be kept in the
<code class="code">env</code> register, argument lists will be accumulated in <code class="code">argl</code>, a
procedure to be applied will be in <code class="code">proc</code>, procedures will return their
answers in <code class="code">val</code>, and the location to which a procedure should return will
be kept in <code class="code">continue</code>.
</p>
<p>In Rust, the fundamental data structure of our compiler is the
<code class="code">InstructionSeq</code>, which contains not only the machine instructions but also
information about which registers are needed and which are modified:
</p>
<div class="example">
<pre class="example-preformatted">pub struct InstructionSeq {
    pub needs: HashSet&lt;Register&gt;,
    pub modifies: HashSet&lt;Register&gt;,
    pub statements: Vec&lt;Instruction&gt;,
}
</pre></div>

<p>This explicit tracking allows the compiler to generate optimized code by
avoiding unnecessary stack operations. In general, the compiler translates a
source program into an object program that performs essentially the same
register operations as would the interpreter in evaluating the same source
program.
</p>
<p>This description suggests a strategy for implementing a rudimentary compiler:
We traverse the expression in the same way the interpreter does.  When we
encounter a register instruction that the interpreter would perform in
evaluating the expression, we do not execute the instruction but instead
accumulate it into a sequence.  The resulting sequence of instructions will be
the object code.  Observe the efficiency advantage of compilation over
interpretation.  Each time the interpreter evaluates an expression&mdash;for
example, <code class="code">(f 84 96)</code>&mdash;it performs the work of classifying the expression
(discovering that this is a procedure application) and testing for the end of
the operand list (discovering that there are two operands).  With a compiler,
the expression is analyzed only once, when the instruction sequence is
generated at compile time.  The object code produced by the compiler contains
only the instructions that evaluate the operator and the two operands, assemble
the argument list, and apply the procedure (in <code class="code">proc</code>) to the arguments
(in <code class="code">argl</code>).
</p>
<p>This is the same kind of optimization we implemented in the analyzing evaluator
of <a class="ref" href="4_002e1.xhtml#g_t4_002e1_002e7">Separating Syntactic Analysis from Execution</a>.  But there are further opportunities to gain efficiency
in compiled code.  As the interpreter runs, it follows a process that must be
applicable to any expression in the language.  In contrast, a given segment of
compiled code is meant to execute some particular expression.  This can make a
big difference, for example in the use of the stack to save registers.  When
the interpreter evaluates an expression, it must be prepared for any
contingency.  Before evaluating a subexpression, the interpreter saves all
registers that will be needed later, because the subexpression might require an
arbitrary evaluation.  A compiler, on the other hand, can exploit the structure
of the particular expression it is processing to generate code that avoids
unnecessary stack operations.
</p>
<p>As a case in point, consider the combination <code class="code">(f 84 96)</code>.  Before the
interpreter evaluates the operator of the combination, it prepares for this
evaluation by saving the registers containing the operands and the environment,
whose values will be needed later.  The interpreter then evaluates the operator
to obtain the result in <code class="code">val</code>, restores the saved registers, and finally
moves the result from <code class="code">val</code> to <code class="code">proc</code>.  However, in the particular
expression we are dealing with, the operator is the symbol <code class="code">f</code>, whose
evaluation is accomplished by the machine operation
<code class="code">lookup_variable_value</code>, which does not alter any registers.  The compiler
that we implement in this section will take advantage of this fact and generate
code that evaluates the operator using the instruction
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(assign proc 
        (op lookup_variable_value)
        (const f)
        (reg env))
</pre></div>

<p>This code not only avoids the unnecessary saves and restores but also assigns
the value of the lookup directly to <code class="code">proc</code>, whereas the interpreter would
obtain the result in <code class="code">val</code> and then move this to <code class="code">proc</code>.
</p>
<p>A compiler can also optimize access to the environment.  Having analyzed the
code, the compiler can in many cases know in which frame a particular variable
will be located and access that frame directly, rather than performing the
<code class="code">lookup_variable_value</code> search.  We will discuss how to implement such
variable access in <a class="ref" href="#g_t5_002e5_002e6">Lexical Addressing</a>.  Until then, however, we will focus on
the kind of register and stack optimizations described above.  There are many
other optimizations that can be performed by a compiler, such as coding
primitive operations &ldquo;in line&rdquo; instead of using a general <code class="code">apply</code>
mechanism (see <a class="ref" href="#Exercise-5_002e38">Exercise 5.38</a>); but we will not emphasize these here.  Our
main goal in this section is to illustrate the compilation process in a
simplified (but still interesting) context.
</p>

<hr>
<div class="subsection-level-extent" id="g_t5_002e5_002e1">
<h4 class="subsection" id="Structure-of-the-Compiler"><span>5.5.1 Structure of the Compiler<a class="copiable-link" href="#Structure-of-the-Compiler"> &para;</a></span></h4>

<p>In <a class="ref" href="4_002e1.xhtml#g_t4_002e1_002e7">Separating Syntactic Analysis from Execution</a> we modified our original metacircular interpreter to
separate analysis from execution.  We analyzed each expression to produce an
execution procedure that took an environment as argument and performed the
required operations.  In our compiler, we will do essentially the same
analysis.  Instead of producing execution procedures, however, we will generate
sequences of instructions to be run by our register machine.
</p>
<p>The procedure <code class="code">compile</code> is the top-level dispatch in the compiler.  It
corresponds to the <code class="code">eval</code> procedure of <a class="ref" href="4_002e1.xhtml#g_t4_002e1_002e1">The Core of the Evaluator</a>, the
<code class="code">analyze</code> procedure of <a class="ref" href="4_002e1.xhtml#g_t4_002e1_002e7">Separating Syntactic Analysis from Execution</a>, and the <code class="code">eval_dispatch</code>
entry point of the explicit-control-evaluator in <a class="ref" href="5_002e4.xhtml#g_t5_002e4_002e1">The Core of the Explicit-Control Evaluator</a>.  The
compiler, like the interpreters, uses the expression-syntax procedures defined
in <a class="ref" href="4_002e1.xhtml#g_t4_002e1_002e2">Representing Expressions</a>.<a class="footnote" id="DOCF295" href="#FOOT295"><sup>295</sup></a>  <code class="code">Compile</code> performs a
case analysis on the syntactic type of the expression to be compiled.  For each
type of expression, it dispatches to a specialized <a class="index-entry-id" id="index-code-generator"></a>
<em class="dfn">code generator</em>:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">pub fn compile(expr: &amp;Expr, target: Register, linkage: &amp;Linkage) -&gt; InstructionSeq {
    match expr {
        Expr::Number(_) | Expr::String(_) =&gt; compile_self_evaluating(expr, target, linkage),
        Expr::Quote(_) =&gt; compile_quoted(expr, target, linkage),
        Expr::Symbol(_) =&gt; compile_variable(expr, target, linkage),
        Expr::Set { .. } =&gt; compile_assignment(expr, target, linkage),
        Expr::Define { .. } =&gt; compile_definition(expr, target, linkage),
        Expr::If { .. } =&gt; compile_if(expr, target, linkage),
        Expr::Lambda { .. } =&gt; compile_lambda(expr, target, linkage),
        Expr::Begin(exprs) =&gt; compile_sequence(exprs, target, linkage),
        Expr::Cond(clauses) =&gt; {
            // Convert cond to nested if
            let if_expr = cond_to_if(clauses);
            compile(&amp;if_expr, target, linkage)
        }
        Expr::Application { .. } =&gt; compile_application(expr, target, linkage),
    }
}
</pre></div>

<h4 class="subsubheading" id="Targets-and-linkages"><span>Targets and linkages<a class="copiable-link" href="#Targets-and-linkages"> &para;</a></span></h4>

<p><code class="code">Compile</code> and the code generators that it calls take two arguments in
addition to the expression to compile.  There is a <a class="index-entry-id" id="index-target"></a>
<em class="dfn">target</em>, which
specifies the register in which the compiled code is to return the value of the
expression.  There is also a <a class="index-entry-id" id="index-linkage-descriptor"></a>
<em class="dfn">linkage descriptor</em>, which describes how
the code resulting from the compilation of the expression should proceed when
it has finished its execution.  The linkage descriptor can require that the
code do one of the following three things:
</p>
<ul class="itemize mark-bullet">
<li>continue at the next instruction in sequence (this is specified by the linkage
descriptor <code class="code">next</code>),

</li><li>return from the procedure being compiled (this is specified by the linkage
descriptor <code class="code">return</code>), or

</li><li>jump to a named entry point (this is specified by using the designated label as
the linkage descriptor).

</li></ul>

<p>For example, compiling the expression <code class="code">5</code> (which is self-evaluating) with
a target of the <code class="code">val</code> register and a linkage of <code class="code">next</code> should produce
the instruction
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(assign val (const 5))
</pre></div>

<p>Compiling the same expression with a linkage of <code class="code">return</code> should produce
the instructions
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(assign val (const 5))
(goto (reg continue))
</pre></div>

<p>In the first case, execution will continue with the next instruction in the
sequence. In the second case, we will return from a procedure call.  In both
cases, the value of the expression will be placed into the target <code class="code">val</code>
register.
</p>
<h4 class="subsubheading" id="Instruction-sequences-and-stack-usage"><span>Instruction sequences and stack usage<a class="copiable-link" href="#Instruction-sequences-and-stack-usage"> &para;</a></span></h4>

<p>Each code generator returns an <a class="index-entry-id" id="index-instruction-sequence"></a>
<em class="dfn">instruction sequence</em> containing the
object code it has generated for the expression.  Code generation for a
compound expression is accomplished by combining the output from simpler code
generators for component expressions, just as evaluation of a compound
expression is accomplished by evaluating the component expressions.
</p>
<p>The simplest method for combining instruction sequences is a procedure called
<code class="code">append_instruction_sequences</code>.  It takes as arguments any number of
instruction sequences that are to be executed sequentially; it appends them and
returns the combined sequence.  That is, if <em class="math">{⟨\kern0.1em seq_1⟩}</em> 
and <em class="math">{⟨\kern0.1em seq_2⟩}</em> are sequences of instructions, then 
evaluating
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(append-instruction-sequences ⟨<var class="var">seq₁</var>⟩ ⟨<var class="var">seq₂</var>⟩)
</pre></div>

<p><b class="b">Rust (append instruction sequences):</b>
</p><div class="example">
<pre class="example-preformatted">pub fn append_instruction_sequences(
    seq1: InstructionSeq,
    seq2: InstructionSeq
) -&gt; InstructionSeq {
    let mut needs = seq1.needs.clone();
    needs.extend(
        seq2.needs.difference(&amp;seq1.modifies).cloned()
    );

    let mut modifies = seq1.modifies.clone();
    modifies.extend(seq2.modifies.iter().cloned());

    let mut statements = seq1.statements;
    statements.extend(seq2.statements);

    InstructionSeq { needs, modifies, statements }
}
</pre></div>

<p>produces the sequence
</p>
<div class="example lisp">
<pre class="lisp-preformatted">⟨<var class="var">seq₁</var>⟩
⟨<var class="var">seq₂</var>⟩
</pre></div>

<p>Whenever registers might need to be saved, the compiler&rsquo;s code generators use
<code class="code">preserving</code>, which is a more subtle method for combining instruction
sequences.  <code class="code">Preserving</code> takes three arguments: a set of registers and two
instruction sequences that are to be executed sequentially.  It appends the
sequences in such a way that the contents of each register in the set is
preserved over the execution of the first sequence, if this is needed for the
execution of the second sequence.  That is, if the first sequence modifies the
register and the second sequence actually needs the register&rsquo;s original
contents, then <code class="code">preserving</code> wraps a <code class="code">save</code> and a <code class="code">restore</code> of
the register around the first sequence before appending the sequences.
Otherwise, <code class="code">preserving</code> simply returns the appended instruction sequences.
Thus, for example,
<code class="code">(preserving (list ⟨<var class="var">reg₁</var>⟩ ⟨<var class="var">reg₂</var>⟩) ⟨<var class="var">seg₁</var>⟩ ⟨<var class="var">seg₂</var>⟩)</code>
produces one of the following four sequences of instructions, depending on how
<em class="math">{⟨\kern0.1em seq_1⟩}</em> and <em class="math">{⟨\kern0.1em seq_2⟩}</em> 
use <em class="math">{⟨\kern0.1em reg_1⟩}</em> and <em class="math">{⟨\kern0.1em reg_2⟩}</em>:
\[ % :83:

\begin{array}{l|l|l|l}
⟨\kern0.1em{seq_1}⟩                     &amp;
\text{(save}                            &amp;
\text{(save}                            &amp;
\text{(save} \kern1ex ⟨\kern0.1em{reg_2}⟩\text{)}    \\

⟨\kern0.1em{seq_2}⟩  		        &amp;
\kern1ex ⟨\kern0.1em{reg_1}⟩\text{)}    &amp;
\kern1ex ⟨\kern0.1em{reg_2}⟩\text{)}    &amp;
\text{(save} \kern1ex ⟨\kern0.1em{reg_1}⟩\text{)}    \\

                                        &amp;
⟨\kern0.1em{seq_1}⟩                     &amp;
⟨\kern0.1em{seq_1}⟩                     &amp;
⟨\kern0.1em{seq_1}⟩                                  \\

                                        &amp;
\text{(restore}                         &amp;
\text{(restore}                         &amp;
\text{(restore} \kern1ex ⟨\kern0.1em{reg_1}⟩\text{)} \\

                                        &amp;
\kern1ex ⟨\kern0.1em{reg_1}⟩\text{)}    &amp;
\kern1ex ⟨\kern0.1em{reg_2}⟩\text{)}    &amp;
\text{(restore} \kern1ex ⟨\kern0.1em{reg_2}⟩\text{)} \\

                                        &amp;
⟨\kern0.1em{seq_2}⟩                     &amp;
⟨\kern0.1em{seq_2}⟩                     &amp;
⟨\kern0.1em{seq_2}⟩
\end{array}
\]
</p>
<p>By using <code class="code">preserving</code> to combine instruction sequences the compiler avoids
unnecessary stack operations.  This also isolates the details of whether or not
to generate <code class="code">save</code> and <code class="code">restore</code> instructions within the
<code class="code">preserving</code> procedure, separating them from the concerns that arise in
writing each of the individual code generators.  In fact no <code class="code">save</code> or
<code class="code">restore</code> instructions are explicitly produced by the code generators.
</p>
<p>In principle, we could represent an instruction sequence simply as a list of
instructions.  <code class="code">Append-instruction-sequences</code> could then combine
instruction sequences by performing an ordinary list <code class="code">append</code>.  However,
<code class="code">preserving</code> would then be a complex operation, because it would have to
analyze each instruction sequence to determine how the sequence uses its
registers.  <code class="code">Preserving</code> would be inefficient as well as complex, because
it would have to analyze each of its instruction sequence arguments, even
though these sequences might themselves have been constructed by calls to
<code class="code">preserving</code>, in which case their parts would have already been analyzed.
To avoid such repetitious analysis we will associate with each instruction
sequence some information about its register use.  When we construct a basic
instruction sequence we will provide this information explicitly, and the
procedures that combine instruction sequences will derive register-use
information for the combined sequence from the information associated with the
component sequences.
</p>
<p>An instruction sequence will contain three pieces of information:
</p>
<ul class="itemize mark-bullet">
<li>the set of registers that must be initialized before the instructions in the
sequence are executed (these registers are said to be <a class="index-entry-id" id="index-needed"></a>
<em class="dfn">needed</em> by the
sequence),

</li><li>the set of registers whose values are modified by the instructions in the
sequence, and

</li><li>the actual instructions (also called <a class="index-entry-id" id="index-statements-1"></a>
<em class="dfn">statements</em>) in the sequence.

</li></ul>

<p>We will represent an instruction sequence as a list of its three parts.  The
constructor for instruction sequences is thus
</p>
<div class="example lisp">
<pre class="lisp-preformatted">pub struct InstructionSeq {
    pub needs: HashSet&lt;Register&gt;,
    pub modifies: HashSet&lt;Register&gt;,
    pub statements: Vec&lt;Instruction&gt;,
}

impl InstructionSeq {
    pub fn new(
        needs: HashSet&lt;Register&gt;,
        modifies: HashSet&lt;Register&gt;,
        statements: Vec&lt;Instruction&gt;,
    ) -&gt; Self {
        Self { needs, modifies, statements }
    }

    pub fn empty() -&gt; Self {
        Self::new(HashSet::new(), HashSet::new(), Vec::new())
    }
}
</pre></div>

<p>For example, the two-instruction sequence that looks up the value of the
variable <code class="code">x</code> in the current environment, assigns the result to <code class="code">val</code>,
and then returns, requires registers <code class="code">env</code> and <code class="code">continue</code> to have
been initialized, and modifies register <code class="code">val</code>.  This sequence would
therefore be constructed as
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(make_instruction_sequence
 '(env continue)
 '(val)
 '((assign val
           (op lookup_variable_value)
           (const x)
           (reg env))
   (goto (reg continue))))
</pre></div>

<p>We sometimes need to construct an instruction sequence with no statements:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">// In Rust, we use InstructionSeq::empty()
</pre></div>

<p>The procedures for combining instruction sequences are shown in 
<a class="ref" href="#g_t5_002e5_002e4">Combining Instruction Sequences</a>.
</p>
<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-5_002e31"></a>Exercise 5.31:</strong> In evaluating a procedure
application, the explicit-control evaluator always saves and restores the
<code class="code">env</code> register around the evaluation of the operator, saves and restores
<code class="code">env</code> around the evaluation of each operand (except the final one), saves
and restores <code class="code">argl</code> around the evaluation of each operand, and saves and
restores <code class="code">proc</code> around the evaluation of the operand sequence.  For each
of the following combinations, say which of these <code class="code">save</code> and
<code class="code">restore</code> operations are superfluous and thus could be eliminated by the
compiler&rsquo;s <code class="code">preserving</code> mechanism:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(f 'x 'y)
((f) 'x 'y)
(f (g 'x) y)
(f (g 'x) 'y)
</pre></div>
</blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-5_002e32"></a>Exercise 5.32:</strong> Using the <code class="code">preserving</code>
mechanism, the compiler will avoid saving and restoring <code class="code">env</code> around the
evaluation of the operator of a combination in the case where the operator is a
symbol.  We could also build such optimizations into the evaluator.  Indeed,
the explicit-control evaluator of <a class="ref" href="5_002e4.xhtml#g_t5_002e4">The Explicit-Control Evaluator</a> already performs a similar
optimization, by treating combinations with no operands as a special case.
</p>
<ol class="enumerate" type="a" start="1">
<li> Extend the explicit-control evaluator to recognize as a separate class of
expressions combinations whose operator is a symbol, and to take advantage of
this fact in evaluating such expressions.

</li><li> Alyssa P. Hacker suggests that by extending the evaluator to recognize more and
more special cases we could incorporate all the compiler&rsquo;s optimizations, and
that this would eliminate the advantage of compilation altogether.  What do you
think of this idea?

</li></ol>
</blockquote>

<hr>
</div>
<div class="subsection-level-extent" id="g_t5_002e5_002e2">
<h4 class="subsection" id="Compiling-Expressions"><span>5.5.2 Compiling Expressions<a class="copiable-link" href="#Compiling-Expressions"> &para;</a></span></h4>

<p>In this section and the next we implement the code generators to which the
<code class="code">compile</code> procedure dispatches.
</p>
<h4 class="subsubheading" id="Compiling-linkage-code"><span>Compiling linkage code<a class="copiable-link" href="#Compiling-linkage-code"> &para;</a></span></h4>

<p>In general, the output of each code generator will end with
instructions&mdash;generated by the procedure <code class="code">compile_linkage</code>&mdash;that
implement the required linkage.  If the linkage is <code class="code">return</code> then we must
generate the instruction <code class="code">(goto (reg continue))</code>.  This needs the
<code class="code">continue</code> register and does not modify any registers.  If the linkage is
<code class="code">next</code>, then we needn&rsquo;t include any additional instructions.  Otherwise,
the linkage is a label, and we generate a <code class="code">goto</code> to that label, an
instruction that does not need or modify any registers.<a class="footnote" id="DOCF296" href="#FOOT296"><sup>296</sup></a>
</p>
<div class="example lisp">
<pre class="lisp-preformatted">fn compile_linkage(linkage: &amp;Linkage) -&gt; InstructionSeq {
    match linkage {
        Linkage::Return =&gt; InstructionSeq::new(
            HashSet::from([Register::Continue]),
            HashSet::new(),
            vec![Instruction::Goto {
                destination: Box::new(InstructionValue::Reg(Register::Continue)),
            }],
        ),
        Linkage::Next =&gt; InstructionSeq::empty(),
        Linkage::Label(label) =&gt; InstructionSeq::new(
            HashSet::new(),
            HashSet::new(),
            vec![Instruction::Goto {
                destination: Box::new(InstructionValue::Label(label.clone())),
            }],
        ),
    }
}
</pre></div>

<p>The linkage code is appended to an instruction sequence by <code class="code">preserving</code>
the <code class="code">continue</code> register, since a <code class="code">return</code> linkage will require the
<code class="code">continue</code> register: If the given instruction sequence modifies
<code class="code">continue</code> and the linkage code needs it, <code class="code">continue</code> will be saved
and restored.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">fn end_with_linkage(linkage: &amp;Linkage, seq: InstructionSeq) -&gt; InstructionSeq {
    preserving(&amp;[Register::Continue], seq, compile_linkage(linkage))
}
   (compile_linkage linkage)))
</pre></div>

<h4 class="subsubheading" id="Compiling-simple-expressions"><span>Compiling simple expressions<a class="copiable-link" href="#Compiling-simple-expressions"> &para;</a></span></h4>

<p>The code generators for self-evaluating expressions, quotations, and variables
construct instruction sequences that assign the required value to the target
register and then proceed as specified by the linkage descriptor.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">fn compile_self_evaluating(expr: &amp;Expr, target: Register, linkage: &amp;Linkage) -&gt; InstructionSeq {
    let value = match expr {
        Expr::Number(n) =&gt; Value::Number(*n),
        Expr::String(s) =&gt; Value::String(s.clone()),
        _ =&gt; panic!(&quot;Not a self-evaluating expression&quot;),
    };

    let seq = InstructionSeq::new(
        HashSet::new(),
        HashSet::from([target]),
        vec![Instruction::Assign {
            target,
            source: Box::new(InstructionValue::Const(value)),
        }],
    );

    end_with_linkage(linkage, seq)
}

fn compile_quoted(expr: &amp;Expr, target: Register, linkage: &amp;Linkage) -&gt; InstructionSeq {
    let quoted_value = match expr {
        Expr::Quote(e) =&gt; expr_to_value(e),
        _ =&gt; panic!(&quot;Not a quoted expression&quot;),
    };

    let seq = InstructionSeq::new(
        HashSet::new(),
        HashSet::from([target]),
        vec![Instruction::Assign {
            target,
            source: Box::new(InstructionValue::Const(quoted_value)),
        }],
    );

    end_with_linkage(linkage, seq)
}

fn compile_variable(expr: &amp;Expr, target: Register, linkage: &amp;Linkage) -&gt; InstructionSeq {
    let var_name = match expr {
        Expr::Symbol(name) =&gt; name.clone(),
        _ =&gt; panic!(&quot;Not a variable&quot;),
    };

    let seq = InstructionSeq::new(
        HashSet::from([Register::Env]),
        HashSet::from([target]),
        vec![Instruction::Assign {
            target,
            source: Box::new(InstructionValue::Op {
                name: &quot;lookup-variable-value&quot;.to_string(),
                args: vec![
                    InstructionValue::Const(Value::Symbol(var_name)),
                    InstructionValue::Reg(Register::Env),
                ],
            }),
        }],
    );

    end_with_linkage(linkage, seq)
}
</pre></div>

<p>All these assignment instructions modify the target register, and the one that
looks up a variable needs the <code class="code">env</code> register.
</p>
<p>Assignments and definitions are handled much as they are in the interpreter.
We recursively generate code that computes the value to be assigned to the
variable, and append to it a two-instruction sequence that actually sets or
defines the variable and assigns the value of the whole expression (the symbol
<code class="code">ok</code>) to the target register.  The recursive compilation has target
<code class="code">val</code> and linkage <code class="code">next</code> so that the code will put its result into
<code class="code">val</code> and continue with the code that is appended after it.  The appending
is done preserving <code class="code">env</code>, since the environment is needed for setting or
defining the variable and the code for the variable value could be the
compilation of a complex expression that might modify the registers in
arbitrary ways.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">fn compile_assignment(expr: &amp;Expr, target: Register, linkage: &amp;Linkage) -&gt; InstructionSeq {
    let (var_name, value_expr) = match expr {
        Expr::Set { name, value } =&gt; (name.clone(), value.as_ref()),
        _ =&gt; panic!(&quot;Not an assignment&quot;),
    };

    let get_value_code = compile(value_expr, Register::Val, &amp;Linkage::Next);

    let set_code = InstructionSeq::new(
        HashSet::from([Register::Env, Register::Val]),
        HashSet::from([target]),
        vec![
            Instruction::Perform {
                operation: Box::new(InstructionValue::Op {
                    name: &quot;set-variable-value!&quot;.to_string(),
                    args: vec![
                        InstructionValue::Const(Value::Symbol(var_name)),
                        InstructionValue::Reg(Register::Val),
                        InstructionValue::Reg(Register::Env),
                    ],
                }),
            },
            Instruction::Assign {
                target,
                source: Box::new(InstructionValue::Const(Value::Ok)),
            },
        ],
    );

    end_with_linkage(
        linkage,
        preserving(&amp;[Register::Env], get_value_code, set_code),
    )
}

fn compile_definition(expr: &amp;Expr, target: Register, linkage: &amp;Linkage) -&gt; InstructionSeq {
    let (var_name, value_expr) = match expr {
        Expr::Define { name, value } =&gt; (name.clone(), value.as_ref()),
        _ =&gt; panic!(&quot;Not a definition&quot;),
    };

    let get_value_code = compile(value_expr, Register::Val, &amp;Linkage::Next);

    let define_code = InstructionSeq::new(
        HashSet::from([Register::Env, Register::Val]),
        HashSet::from([target]),
        vec![
            Instruction::Perform {
                operation: Box::new(InstructionValue::Op {
                    name: &quot;define-variable!&quot;.to_string(),
                    args: vec![
                        InstructionValue::Const(Value::Symbol(var_name)),
                        InstructionValue::Reg(Register::Val),
                        InstructionValue::Reg(Register::Env),
                    ],
                }),
            },
            Instruction::Assign {
                target,
                source: Box::new(InstructionValue::Const(Value::Ok)),
            },
        ],
    );

    end_with_linkage(
        linkage,
        preserving(&amp;[Register::Env], get_value_code, define_code),
    )
}
</pre></div>

<p>The appended two-instruction sequence requires <code class="code">env</code> and <code class="code">val</code> and
modifies the target.  Note that although we preserve <code class="code">env</code> for this
sequence, we do not preserve <code class="code">val</code>, because the <code class="code">get-value-code</code> is
designed to explicitly place its result in <code class="code">val</code> for use by this sequence.
(In fact, if we did preserve <code class="code">val</code>, we would have a bug, because this
would cause the previous contents of <code class="code">val</code> to be restored right after the
<code class="code">get-value-code</code> is run.)
</p>
<h4 class="subsubheading" id="Compiling-conditional-expressions"><span>Compiling conditional expressions<a class="copiable-link" href="#Compiling-conditional-expressions"> &para;</a></span></h4>

<p>The code for an <code class="code">if</code> expression compiled with a given target and linkage
has the form
</p>
<div class="example">
<pre class="example-preformatted">⟨<em class="emph">compilation of predicate, 
 target val, linkage next</em>⟩
Test(Op(&quot;is-false&quot;.into(), vec![Reg(Val)])),
Branch(&quot;false-branch&quot;.into()),
// true-branch
⟨<em class="emph">compilation of consequent with given 
  target and given linkage or after-if</em>⟩
// false-branch
Label(&quot;false-branch&quot;.into()),
⟨<em class="emph">compilation of alternative 
  with given target and linkage</em>⟩
// after-if
Label(&quot;after-if&quot;.into()),
</pre></div>

<p>To generate this code, we compile the predicate, consequent, and alternative,
and combine the resulting code with instructions to test the predicate result
and with newly generated labels to mark the true and false branches and the end
of the conditional.<a class="footnote" id="DOCF297" href="#FOOT297"><sup>297</sup></a>
</p>
<p>In this arrangement of code, we must branch around the true branch if the
test is false.  The only slight complication is in how the linkage for the true
branch should be handled.  If the linkage for the conditional is <code class="code">return</code>
or a label, then the true and false branches will both use this same linkage.
If the linkage is <code class="code">next</code>, the true branch ends with a jump around the code
for the false branch to the label at the end of the conditional.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">fn compile_if(expr: &amp;Expr, target: Register, linkage: &amp;Linkage) -&gt; InstructionSeq {
    let (predicate, consequent, alternative) = match expr {
        Expr::If {
            predicate,
            consequent,
            alternative,
        } =&gt; (
            predicate.as_ref(),
            consequent.as_ref(),
            alternative.as_ref(),
        ),
        _ =&gt; panic!(&quot;Not an if expression&quot;),
    };

    let t_branch = make_label(&quot;true-branch&quot;);
    let f_branch = make_label(&quot;false-branch&quot;);
    let after_if = make_label(&quot;after-if&quot;);

    let consequent_linkage = if linkage == &amp;Linkage::Next {
        Linkage::Label(after_if.clone())
    } else {
        linkage.clone()
    };

    let p_code = compile(predicate, Register::Val, &amp;Linkage::Next);
    let c_code = compile(consequent, target, &amp;consequent_linkage);
    let a_code = compile(alternative, target, linkage);

    let test_code = InstructionSeq::new(
        HashSet::from([Register::Val]),
        HashSet::new(),
        vec![
            Instruction::Test {
                condition: Box::new(InstructionValue::Op {
                    name: &quot;false?&quot;.to_string(),
                    args: vec![InstructionValue::Reg(Register::Val)],
                }),
            },
            Instruction::Branch {
                label: f_branch.clone(),
            },
        ],
    );

    let branches = parallel_instruction_sequences(
        append_instruction_sequences(
            InstructionSeq::new(
                HashSet::new(),
                HashSet::new(),
                vec![Instruction::Label { name: t_branch }],
            ),
            c_code,
        ),
        append_instruction_sequences(
            InstructionSeq::new(
                HashSet::new(),
                HashSet::new(),
                vec![Instruction::Label { name: f_branch }],
            ),
            a_code,
        ),
    );

    let after_if_label = InstructionSeq::new(
        HashSet::new(),
        HashSet::new(),
        vec![Instruction::Label { name: after_if }],
    );

    preserving(
        &amp;[Register::Env, Register::Continue],
        p_code,
        append_sequences(vec![test_code, branches, after_if_label]),
    )
}
</pre></div>

<p><code class="code">Env</code> is preserved around the predicate code because it could be needed by
the true and false branches, and <code class="code">continue</code> is preserved because it could
be needed by the linkage code in those branches.  The code for the true and
false branches (which are not executed sequentially) is appended using a
special combiner <code class="code">parallel_instruction_sequences</code> described in 
<a class="ref" href="#g_t5_002e5_002e4">Combining Instruction Sequences</a>.
</p>
<p>Note that <code class="code">cond</code> is a derived expression, so all that the compiler needs
to do handle it is to apply the <code class="code">cond_to_if</code> transformer (from 
<a class="ref" href="4_002e1.xhtml#g_t4_002e1_002e2">Representing Expressions</a>) and compile the resulting <code class="code">if</code> expression.
</p>
<h4 class="subsubheading" id="Compiling-sequences"><span>Compiling sequences<a class="copiable-link" href="#Compiling-sequences"> &para;</a></span></h4>

<p>The compilation of sequences (from procedure bodies or explicit <code class="code">begin</code>
expressions) parallels their evaluation.  Each expression of the sequence is
compiled&mdash;the last expression with the linkage specified for the sequence, and
the other expressions with linkage <code class="code">next</code> (to execute the rest of the
sequence).  The instruction sequences for the individual expressions are
appended to form a single instruction sequence, such that <code class="code">env</code> (needed
for the rest of the sequence) and <code class="code">continue</code> (possibly needed for the
linkage at the end of the sequence) are preserved.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">fn compile_sequence(exprs: &amp;[Expr], target: Register, linkage: &amp;Linkage) -&gt; InstructionSeq {
    if exprs.is_empty() {
        InstructionSeq::empty()
    } else if exprs.len() == 1 {
        compile(&amp;exprs[0], target, linkage)
    } else {
        preserving(
            &amp;[Register::Env, Register::Continue],
            compile(&amp;exprs[0], target, &amp;Linkage::Next),
            compile_sequence(&amp;exprs[1..], target, linkage),
        )
    }
}
</pre></div>

<h4 class="subsubheading" id="Compiling-lambda-expressions"><span>Compiling <code class="code">lambda</code> expressions<a class="copiable-link" href="#Compiling-lambda-expressions"> &para;</a></span></h4>

<p><code class="code">Lambda</code> expressions construct procedures.  The object code for a
<code class="code">lambda</code> expression must have the form
</p>
<div class="example lisp">
<pre class="lisp-preformatted">⟨<em class="emph">construct procedure object 
 and assign it to target register</em>⟩
⟨<var class="var">linkage</var>⟩
</pre></div>

<p>When we compile the <code class="code">lambda</code> expression, we also generate the code for the
procedure body.  Although the body won&rsquo;t be executed at the time of procedure
construction, it is convenient to insert it into the object code right after
the code for the <code class="code">lambda</code>.  If the linkage for the <code class="code">lambda</code>
expression is a label or <code class="code">return</code>, this is fine.  But if the linkage is
<code class="code">next</code>, we will need to skip around the code for the procedure body by
using a linkage that jumps to a label that is inserted after the body.  The
object code thus has the form
</p>
<div class="example lisp">
<pre class="lisp-preformatted">⟨<em class="emph">construct procedure object 
 and assign it to target register</em>⟩
 ⟨<em class="emph">code for given linkage</em>⟩ <em class="emph">or</em> 
  <code class="code">(goto (label after_lambda))</code>
 ⟨<em class="emph">compilation of procedure body</em>⟩
after_lambda
</pre></div>

<p><code class="code">Compile_lambda</code> generates the code for constructing the procedure object
followed by the code for the procedure body.  The procedure object will be
constructed at run time by combining the current environment (the environment
at the point of definition) with the entry point to the compiled procedure body
(a newly generated label).<a class="footnote" id="DOCF298" href="#FOOT298"><sup>298</sup></a>
</p>
<div class="example lisp">
<pre class="lisp-preformatted">fn compile_lambda(expr: &amp;Expr, target: Register, linkage: &amp;Linkage) -&gt; InstructionSeq {
    let (params, body) = match expr {
        Expr::Lambda { params, body } =&gt; (params, body),
        _ =&gt; panic!(&quot;Not a lambda expression&quot;),
    };

    let proc_entry = make_label(&quot;entry&quot;);
    let after_lambda = make_label(&quot;after-lambda&quot;);

    let lambda_linkage = if linkage == &amp;Linkage::Next {
        Linkage::Label(after_lambda.clone())
    } else {
        linkage.clone()
    };

    let make_proc = InstructionSeq::new(
        HashSet::from([Register::Env]),
        HashSet::from([target]),
        vec![Instruction::Assign {
            target,
            source: Box::new(InstructionValue::Op {
                name: &quot;make-compiled-procedure&quot;.to_string(),
                args: vec![
                    InstructionValue::Label(proc_entry.clone()),
                    InstructionValue::Reg(Register::Env),
                ],
            }),
        }],
    );

    let proc_body = compile_lambda_body(params, body, &amp;proc_entry);

    let after_lambda_label = InstructionSeq::new(
        HashSet::new(),
        HashSet::new(),
        vec![Instruction::Label { name: after_lambda }],
    );

    append_sequences(vec![
        tack_on_instruction_sequence(end_with_linkage(&amp;lambda_linkage, make_proc), proc_body),
        after_lambda_label,
    ])
}
</pre></div>

<p><code class="code">Compile_lambda</code> uses the special combiner
<code class="code">tack_on_instruction_sequence</code> rather than
<code class="code">append_instruction_sequences</code> (<a class="ref" href="#g_t5_002e5_002e4">Combining Instruction Sequences</a>) to append the procedure body to the
<code class="code">lambda</code> expression code, because the body is not part of the sequence of
instructions that will be executed when the combined sequence is entered;
rather, it is in the sequence only because that was a convenient place to put
it.
</p>
<p><code class="code">Compile_lambda_body</code> constructs the code for the body of the procedure.
This code begins with a label for the entry point.  Next come instructions that
will cause the run-time evaluation environment to switch to the correct
environment for evaluating the procedure body&mdash;namely, the definition
environment of the procedure, extended to include the bindings of the formal
parameters to the arguments with which the procedure is called.  After this
comes the code for the sequence of expressions that makes up the procedure
body.  The sequence is compiled with linkage <code class="code">return</code> and target
<code class="code">val</code> so that it will end by returning from the procedure with the
procedure result in <code class="code">val</code>.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">fn compile_lambda_body(params: &amp;[String], body: &amp;[Expr], entry_label: &amp;str) -&gt; InstructionSeq {
    let param_list = params
        .iter()
        .map(|p| Value::Symbol(p.clone()))
        .collect::&lt;Vec&lt;_&gt;&gt;();

    let entry = InstructionSeq::new(
        HashSet::from([Register::Env, Register::Proc, Register::Argl]),
        HashSet::from([Register::Env]),
        vec![
            Instruction::Label {
                name: entry_label.to_string(),
            },
            Instruction::Assign {
                target: Register::Env,
                source: Box::new(InstructionValue::Op {
                    name: &quot;compiled-procedure-env&quot;.to_string(),
                    args: vec![InstructionValue::Reg(Register::Proc)],
                }),
            },
            Instruction::Assign {
                target: Register::Env,
                source: Box::new(InstructionValue::Op {
                    name: &quot;extend-environment&quot;.to_string(),
                    args: vec![
                        InstructionValue::Const(Value::Symbol(format!(&quot;{:?}&quot;, param_list))),
                        InstructionValue::Reg(Register::Argl),
                        InstructionValue::Reg(Register::Env),
                    ],
                }),
            },
        ],
    );

    append_instruction_sequences(
        entry,
        compile_sequence(body, Register::Val, &amp;Linkage::Return),
    )
}
</pre></div>

<hr>
</div>
<div class="subsection-level-extent" id="g_t5_002e5_002e3">
<h4 class="subsection" id="Compiling-Combinations"><span>5.5.3 Compiling Combinations<a class="copiable-link" href="#Compiling-Combinations"> &para;</a></span></h4>

<p>The essence of the compilation process is the compilation of procedure
applications.  The code for a combination compiled with a given target and
linkage has the form
</p>
<div class="example lisp">
<pre class="lisp-preformatted">⟨<em class="emph">compilation of operator, 
 target <code class="code">proc</code>, linkage <code class="code">next</code></em>⟩
⟨<em class="emph">evaluate operands and construct 
 argument list in <code class="code">argl</code></em>⟩
⟨<em class="emph">compilation of procedure call 
 with given target and linkage</em>⟩
</pre></div>

<p>The registers <code class="code">env</code>, <code class="code">proc</code>, and <code class="code">argl</code> may have to be saved and
restored during evaluation of the operator and operands.  Note that this is the
only place in the compiler where a target other than <code class="code">val</code> is specified.
</p>
<p>The required code is generated by <code class="code">compile_application</code>.  This recursively
compiles the operator, to produce code that puts the procedure to be applied
into <code class="code">proc</code>, and compiles the operands, to produce code that evaluates the
individual operands of the application.  The instruction sequences for the
operands are combined (by <code class="code">construct_arglist</code>) with code that constructs
the list of arguments in <code class="code">argl</code>, and the resulting argument-list code is
combined with the procedure code and the code that performs the procedure call
(produced by <code class="code">compile_procedure_call</code>).  In appending the code sequences,
the <code class="code">env</code> register must be preserved around the evaluation of the operator
(since evaluating the operator might modify <code class="code">env</code>, which will be needed to
evaluate the operands), and the <code class="code">proc</code> register must be preserved around
the construction of the argument list (since evaluating the operands might
modify <code class="code">proc</code>, which will be needed for the actual procedure application).
<code class="code">Continue</code> must also be preserved throughout, since it is needed for the
linkage in the procedure call.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">fn compile_application(expr: &amp;Expr, target: Register, linkage: &amp;Linkage) -&gt; InstructionSeq {
    let (operator, operands) = match expr {
        Expr::Application { operator, operands } =&gt; (operator.as_ref(), operands),
        _ =&gt; panic!(&quot;Not an application&quot;),
    };

    let proc_code = compile(operator, Register::Proc, &amp;Linkage::Next);
    let operand_codes: Vec&lt;InstructionSeq&gt; = operands
        .iter()
        .map(|operand| compile(operand, Register::Val, &amp;Linkage::Next))
        .collect();

    preserving(
        &amp;[Register::Env, Register::Continue],
        proc_code,
        preserving(
            &amp;[Register::Proc, Register::Continue],
            construct_arglist(operand_codes),
            compile_procedure_call(target, linkage),
        ),
    )
}
</pre></div>

<p>The code to construct the argument list will evaluate each operand into
<code class="code">val</code> and then <code class="code">cons</code> that value onto the argument list being
accumulated in <code class="code">argl</code>.  Since we <code class="code">cons</code> the arguments onto
<code class="code">argl</code> in sequence, we must start with the last argument and end with the
first, so that the arguments will appear in order from first to last in the
resulting list.  Rather than waste an instruction by initializing <code class="code">argl</code>
to the empty list to set up for this sequence of evaluations, we make the first
code sequence construct the initial <code class="code">argl</code>.  The general form of the
argument-list construction is thus as follows:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">⟨<em class="emph">compilation of last operand, targeted to <code class="code">val</code></em>⟩
(assign argl (op list) (reg val))
⟨<em class="emph">compilation of next operand, targeted to <code class="code">val</code></em>⟩
(assign argl (op cons) (reg val) (reg argl))
<span class="r">…</span>
⟨<em class="emph">compilation of first operand, targeted to <code class="code">val</code></em>⟩
(assign argl (op cons) (reg val) (reg argl))
</pre></div>

<p><code class="code">Argl</code> must be preserved around each operand evaluation except the first
(so that arguments accumulated so far won&rsquo;t be lost), and <code class="code">env</code> must be
preserved around each operand evaluation except the last (for use by subsequent
operand evaluations).
</p>
<p>Compiling this argument code is a bit tricky, because of the special treatment
of the first operand to be evaluated and the need to preserve <code class="code">argl</code> and
<code class="code">env</code> in different places.  The <code class="code">construct_arglist</code> procedure takes
as arguments the code that evaluates the individual operands.  If there are no
operands at all, it simply emits the instruction
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(assign argl (const ()))
</pre></div>

<p>Otherwise, <code class="code">construct_arglist</code> creates code that initializes <code class="code">argl</code>
with the last argument, and appends code that evaluates the rest of the
arguments and adjoins them to <code class="code">argl</code> in succession.  In order to process
the arguments from last to first, we must reverse the list of operand code
sequences from the order supplied by <code class="code">compile_application</code>.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">fn construct_arglist(operand_codes: Vec&lt;InstructionSeq&gt;) -&gt; InstructionSeq {
    if operand_codes.is_empty() {
        InstructionSeq::new(
            HashSet::new(),
            HashSet::from([Register::Argl]),
            vec![Instruction::Assign {
                target: Register::Argl,
                source: Box::new(InstructionValue::Const(Value::Nil)),
            }],
        )
    } else {
        let mut reversed_codes = operand_codes;
        reversed_codes.reverse();

        let code_to_get_last_arg = append_instruction_sequences(
            reversed_codes[0].clone(),
            InstructionSeq::new(
                HashSet::from([Register::Val]),
                HashSet::from([Register::Argl]),
                vec![Instruction::Assign {
                    target: Register::Argl,
                    source: Box::new(InstructionValue::Op {
                        name: &quot;list&quot;.to_string(),
                        args: vec![InstructionValue::Reg(Register::Val)],
                    }),
                }],
            ),
        );

        if reversed_codes.len() == 1 {
            code_to_get_last_arg
        } else {
            preserving(
                &amp;[Register::Env],
                code_to_get_last_arg,
                code_to_get_rest_args(&amp;reversed_codes[1..]),
            )
        }
    }
}

fn code_to_get_rest_args(operand_codes: &amp;[InstructionSeq]) -&gt; InstructionSeq {
    let code_for_next_arg = preserving(
        &amp;[Register::Argl],
        operand_codes[0].clone(),
        InstructionSeq::new(
            HashSet::from([Register::Val, Register::Argl]),
            HashSet::from([Register::Argl]),
            vec![Instruction::Assign {
                target: Register::Argl,
                source: Box::new(InstructionValue::Op {
                    name: &quot;cons&quot;.to_string(),
                    args: vec![
                        InstructionValue::Reg(Register::Val),
                        InstructionValue::Reg(Register::Argl),
                    ],
                }),
            }],
        ),
    );

    if operand_codes.len() == 1 {
        code_for_next_arg
    } else {
        preserving(
            &amp;[Register::Env],
            code_for_next_arg,
            code_to_get_rest_args(&amp;operand_codes[1..]),
        )
    }
}
</pre></div>

<h4 class="subsubheading" id="Applying-procedures"><span>Applying procedures<a class="copiable-link" href="#Applying-procedures"> &para;</a></span></h4>

<p>After evaluating the elements of a combination, the compiled code must apply
the procedure in <code class="code">proc</code> to the arguments in <code class="code">argl</code>.  The code
performs essentially the same dispatch as the <code class="code">apply</code> procedure in the
metacircular evaluator of <a class="ref" href="4_002e1.xhtml#g_t4_002e1_002e1">The Core of the Evaluator</a> or the <code class="code">apply_dispatch</code>
entry point in the explicit-control evaluator of <a class="ref" href="5_002e4.xhtml#g_t5_002e4_002e1">The Core of the Explicit-Control Evaluator</a>.  It
checks whether the procedure to be applied is a primitive procedure or a
compiled procedure.  For a primitive procedure, it uses
<code class="code">apply_primitive_procedure</code>; we will see shortly how it handles compiled
procedures.  The procedure-application code has the following form:
</p>
<div class="example">
<pre class="example-preformatted">Test(Op(&quot;is-primitive-procedure&quot;.into(), vec![Reg(Proc)])),
Branch(&quot;primitive-branch&quot;.into()),
// compiled-branch
⟨<em class="emph">code to apply compiled procedure 
  with given target and appropriate linkage</em>⟩
// primitive-branch
Label(&quot;primitive-branch&quot;.into()),
Assign(target, Op(&quot;apply-primitive-procedure&quot;.into(), 
    vec![Reg(Proc), Reg(Argl)])),
⟨<var class="var">linkage</var>⟩
Label(&quot;after-call&quot;.into()),
</pre></div>

<p>Observe that the compiled branch must skip around the primitive branch.
Therefore, if the linkage for the original procedure call was <code class="code">next</code>, the
compound branch must use a linkage that jumps to a label that is inserted after
the primitive branch.  (This is similar to the linkage used for the true branch
in <code class="code">compile_if</code>.)
</p>
<div class="example lisp">
<pre class="lisp-preformatted">fn compile_procedure_call(target: Register, linkage: &amp;Linkage) -&gt; InstructionSeq {
    let primitive_branch = make_label(&quot;primitive-branch&quot;);
    let compiled_branch = make_label(&quot;compiled-branch&quot;);
    let after_call = make_label(&quot;after-call&quot;);

    let compiled_linkage = if linkage == &amp;Linkage::Next {
        Linkage::Label(after_call.clone())
    } else {
        linkage.clone()
    };

    let test_code = InstructionSeq::new(
        HashSet::from([Register::Proc]),
        HashSet::new(),
        vec![
            Instruction::Test {
                condition: Box::new(InstructionValue::Op {
                    name: &quot;primitive-procedure?&quot;.to_string(),
                    args: vec![InstructionValue::Reg(Register::Proc)],
                }),
            },
            Instruction::Branch {
                label: primitive_branch.clone(),
            },
        ],
    );

    let compiled_case = append_instruction_sequences(
        InstructionSeq::new(
            HashSet::new(),
            HashSet::new(),
            vec![Instruction::Label {
                name: compiled_branch,
            }],
        ),
        compile_proc_appl(target, &amp;compiled_linkage),
    );

    let primitive_case = append_instruction_sequences(
        InstructionSeq::new(
            HashSet::new(),
            HashSet::new(),
            vec![Instruction::Label {
                name: primitive_branch,
            }],
        ),
        end_with_linkage(
            linkage,
            InstructionSeq::new(
                HashSet::from([Register::Proc, Register::Argl]),
                HashSet::from([target]),
                vec![Instruction::Assign {
                    target,
                    source: Box::new(InstructionValue::Op {
                        name: &quot;apply-primitive-procedure&quot;.to_string(),
                        args: vec![
                            InstructionValue::Reg(Register::Proc),
                            InstructionValue::Reg(Register::Argl),
                        ],
                    }),
                }],
            ),
        ),
    );

    let after_call_label = InstructionSeq::new(
        HashSet::new(),
        HashSet::new(),
        vec![Instruction::Label { name: after_call }],
    );

    append_sequences(vec![
        test_code,
        parallel_instruction_sequences(compiled_case, primitive_case),
        after_call_label,
    ])
}
</pre></div>

<p>The primitive and compound branches, like the true and false branches in
<code class="code">compile_if</code>, are appended using <code class="code">parallel_instruction_sequences</code>
rather than the ordinary <code class="code">append_instruction_sequences</code>, because they will
not be executed sequentially.
</p>
<h4 class="subsubheading" id="Applying-compiled-procedures"><span>Applying compiled procedures<a class="copiable-link" href="#Applying-compiled-procedures"> &para;</a></span></h4>

<p>The code that handles procedure application is the most subtle part of the
compiler, even though the instruction sequences it generates are very short.  A
compiled procedure (as constructed by <code class="code">compile_lambda</code>) has an entry
point, which is a label that designates where the code for the procedure
starts.  The code at this entry point computes a result in <code class="code">val</code> and
returns by executing the instruction <code class="code">(goto (reg continue))</code>.  Thus, we
might expect the code for a compiled-procedure application (to be generated by
<code class="code">compile_proc_appl</code>) with a given target and linkage to look like this if
the linkage is a label
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(assign continue 
        (label proc_return))
 (assign val
         (op compiled_procedure_entry)
         (reg proc))
 (goto (reg val))
proc_return
 (assign ⟨<var class="var">target</var>⟩ 
         (reg val))   <span class="r">; included if target is not <code class="code">val</code></span>
 (goto (label ⟨<var class="var">linkage</var>⟩))   <span class="r">; linkage code</span>
</pre></div>

<p>or like this if the linkage is <code class="code">return</code>.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(save continue)
 (assign continue 
         (label proc_return))
 (assign val 
         (op compiled_procedure_entry)
         (reg proc))
 (goto (reg val))
proc_return
 (assign ⟨<var class="var">target</var>⟩
         (reg val))   <span class="r">; included if target is not <code class="code">val</code></span>
 (restore continue)
 (goto (reg continue))   <span class="r">; linkage code</span>
</pre></div>

<p>This code sets up <code class="code">continue</code> so that the procedure will return to a label
<code class="code">proc_return</code> and jumps to the procedure&rsquo;s entry point.  The code at
<code class="code">proc_return</code> transfers the procedure&rsquo;s result from <code class="code">val</code> to the
target register (if necessary) and then jumps to the location specified by the
linkage.  (The linkage is always <code class="code">return</code> or a label, because
<code class="code">compile_procedure_call</code> replaces a <code class="code">next</code> linkage for the
compound-procedure branch by an <code class="code">after_call</code> label.)
</p>
<p>In fact, if the target is not <code class="code">val</code>, that is exactly the code our compiler
will generate.<a class="footnote" id="DOCF299" href="#FOOT299"><sup>299</sup></a>  Usually, however, the target is
<code class="code">val</code> (the only time the compiler specifies a different register is when
targeting the evaluation of an operator to <code class="code">proc</code>), so the procedure
result is put directly into the target register and there is no need to return
to a special location that copies it.  Instead, we simplify the code by setting
up <code class="code">continue</code> so that the procedure will &ldquo;return&rdquo; directly to the place
specified by the caller&rsquo;s linkage:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">⟨<em class="emph">set up <code class="code">continue</code> for linkage</em>⟩
(assign val 
        (op compiled_procedure_entry)
        (reg proc))
(goto (reg val))
</pre></div>

<p>If the linkage is a label, we set up <code class="code">continue</code> so that the procedure will
return to that label.  (That is, the <code class="code">(goto (reg continue))</code> the procedure
ends with becomes equivalent to the <code class="code">(goto (label ⟨<var class="var">linkage</var>⟩))</code> at
<code class="code">proc_return</code> above.)
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(assign continue 
        (label ⟨<var class="var">linkage</var>⟩))
(assign val
        (op compiled_procedure_entry)
        (reg proc))
(goto (reg val))
</pre></div>

<p>If the linkage is <code class="code">return</code>, we don&rsquo;t need to set up <code class="code">continue</code> at
all: It already holds the desired location.  (That is, the <code class="code">(goto (reg
continue))</code> the procedure ends with goes directly to the place where the
<code class="code">(goto (reg continue))</code> at <code class="code">proc_return</code> would have gone.)
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(assign val
        (op compiled_procedure_entry)
        (reg proc))
(goto (reg val))
</pre></div>

<p>With this implementation of the <code class="code">return</code> linkage, the compiler generates
tail-recursive code.  Calling a procedure as the final step in a procedure body
does a direct transfer, without saving any information on the stack.
</p>
<p>Suppose instead that we had handled the case of a procedure call with a linkage
of <code class="code">return</code> and a target of <code class="code">val</code> as shown above for a non-<code class="code">val</code>
target.  This would destroy tail recursion.  Our system would still give the
same value for any expression.  But each time we called a procedure, we would
</p>
<p><b class="b">Rust (compiler registers):</b>
</p><div class="example">
<pre class="example-preformatted">#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum Register {
    Env,       // Environment register
    Proc,      // Procedure register
    Val,       // Value register
    Argl,      // Argument list register
    Continue,  // Continuation register
}
</pre></div>

<p>save <code class="code">continue</code> and return after the call to undo the (useless) save.
These extra saves would accumulate during a nest of procedure
calls.<a class="footnote" id="DOCF300" href="#FOOT300"><sup>300</sup></a>
</p>
<p><code class="code">Compile-proc-appl</code> generates the above procedure-application code by
considering four cases, depending on whether the target for the call is
<code class="code">val</code> and whether the linkage is <code class="code">return</code>.  Observe that the
instruction sequences are declared to modify all the registers, since executing
the procedure body can change the registers in arbitrary ways.<a class="footnote" id="DOCF301" href="#FOOT301"><sup>301</sup></a>
Also note that the code sequence for the case with target <code class="code">val</code> and
linkage <code class="code">return</code> is declared to need <code class="code">continue</code>: Even though
<code class="code">continue</code> is not explicitly used in the two-instruction sequence, we must
be sure that <code class="code">continue</code> will have the correct value when we enter the
compiled procedure.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">fn compile_proc_appl(target: Register, linkage: &amp;Linkage) -&gt; InstructionSeq {
    let all_regs_set: HashSet&lt;Register&gt; = ALL_REGS.iter().copied().collect();

    match (target, linkage) {
        (Register::Val, Linkage::Return) =&gt; {
            // Tail call optimization: just jump to procedure
            InstructionSeq::new(
                HashSet::from([Register::Proc, Register::Continue]),
                all_regs_set,
                vec![
                    Instruction::Assign {
                        target: Register::Val,
                        source: Box::new(InstructionValue::Op {
                            name: &quot;compiled-procedure-entry&quot;.to_string(),
                            args: vec![InstructionValue::Reg(Register::Proc)],
                        }),
                    },
                    Instruction::Goto {
                        destination: Box::new(InstructionValue::Reg(Register::Val)),
                    },
                ],
            )
        }
        (Register::Val, _) =&gt; {
            // Set continue to linkage target, then jump
            let continue_target = match linkage {
                Linkage::Label(label) =&gt; InstructionValue::Label(label.clone()),
                _ =&gt; panic!(&quot;Invalid linkage for val target&quot;),
            };

            InstructionSeq::new(
                HashSet::from([Register::Proc]),
                all_regs_set,
                vec![
                    Instruction::Assign {
                        target: Register::Continue,
                        source: Box::new(continue_target),
                    },
                    Instruction::Assign {
                        target: Register::Val,
                        source: Box::new(InstructionValue::Op {
                            name: &quot;compiled-procedure-entry&quot;.to_string(),
                            args: vec![InstructionValue::Reg(Register::Proc)],
                        }),
                    },
                    Instruction::Goto {
                        destination: Box::new(InstructionValue::Reg(Register::Val)),
                    },
                ],
            )
        }
        (_, Linkage::Return) =&gt; {
            panic!(&quot;Return linkage with target != val not supported&quot;);
        }
        (_, _) =&gt; {
            // Non-val target with label linkage
            let proc_return = make_label(&quot;proc-return&quot;);
            let linkage_label = match linkage {
                Linkage::Label(label) =&gt; label.clone(),
                _ =&gt; panic!(&quot;Invalid linkage&quot;),
            };

            InstructionSeq::new(
                HashSet::from([Register::Proc]),
                all_regs_set,
                vec![
                    Instruction::Assign {
                        target: Register::Continue,
                        source: Box::new(InstructionValue::Label(proc_return.clone())),
                    },
                    Instruction::Assign {
                        target: Register::Val,
                        source: Box::new(InstructionValue::Op {
                            name: &quot;compiled-procedure-entry&quot;.to_string(),
                            args: vec![InstructionValue::Reg(Register::Proc)],
                        }),
                    },
                    Instruction::Goto {
                        destination: Box::new(InstructionValue::Reg(Register::Val)),
                    },
                    Instruction::Label { name: proc_return },
                    Instruction::Assign {
                        target,
                        source: Box::new(InstructionValue::Reg(Register::Val)),
                    },
                    Instruction::Goto {
                        destination: Box::new(InstructionValue::Label(linkage_label)),
                    },
                ],
            )
        }
    }
}
</pre></div>

<hr>
</div>
<div class="subsection-level-extent" id="g_t5_002e5_002e4">
<h4 class="subsection" id="Combining-Instruction-Sequences"><span>5.5.4 Combining Instruction Sequences<a class="copiable-link" href="#Combining-Instruction-Sequences"> &para;</a></span></h4>

<p>This section describes the details on how instruction sequences are represented
and combined.  Recall from <a class="ref" href="#g_t5_002e5_002e1">Structure of the Compiler</a> that an instruction sequence is
represented as a list of the registers needed, the registers modified, and the
actual instructions.  We will also consider a label (symbol) to be a degenerate
case of an instruction sequence, which doesn&rsquo;t need or modify any registers.
So to determine the registers needed and modified by instruction sequences we
use the selectors
</p>
<div class="example lisp">
<pre class="lisp-preformatted">// In Rust, we use methods on the InstructionSeq struct:
// seq.needs_register(reg)
// seq.modifies_register(reg)
</pre></div>

<p>In terms of these predicates and selectors, we can implement the various
instruction sequence combiners used throughout the compiler.
</p>
<p>The basic combiner is <code class="code">append_instruction_sequences</code>.  This takes as
arguments an arbitrary number of instruction sequences that are to be executed
sequentially and returns an instruction sequence whose statements are the
statements of all the sequences appended together.  The subtle point is to
determine the registers that are needed and modified by the resulting sequence.
It modifies those registers that are modified by any of the sequences; it needs
those registers that must be initialized before the first sequence can be run
(the registers needed by the first sequence), together with those registers
needed by any of the other sequences that are not initialized (modified) by
sequences preceding it.
</p>
<p>The sequences are appended two at a time by <code class="code">append_2_sequences</code>.  This
takes two instruction sequences <code class="code">seq1</code> and <code class="code">seq2</code> and returns the
instruction sequence whose statements are the statements of <code class="code">seq1</code>
followed by the statements of <code class="code">seq2</code>, whose modified registers are those
registers that are modified by either <code class="code">seq1</code> or <code class="code">seq2</code>, and whose
needed registers are the registers needed by <code class="code">seq1</code> together with those
registers needed by <code class="code">seq2</code> that are not modified by <code class="code">seq1</code>.  (In
terms of set operations, the new set of needed registers is the union of the
set of registers needed by <code class="code">seq1</code> with the set difference of the registers
needed by <code class="code">seq2</code> and the registers modified by <code class="code">seq1</code>.)  Thus,
<code class="code">append_instruction_sequences</code> is implemented as follows:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">fn append_instruction_sequences(seq1: InstructionSeq, seq2: InstructionSeq) -&gt; InstructionSeq {
    let needs = set_union(&amp;seq1.needs, &amp;set_difference(&amp;seq2.needs, &amp;seq1.modifies));
    let modifies = set_union(&amp;seq1.modifies, &amp;seq2.modifies);
    let mut statements = seq1.statements;
    statements.extend(seq2.statements);
    InstructionSeq::new(needs, modifies, statements)
}

fn append_sequences(seqs: Vec&lt;InstructionSeq&gt;) -&gt; InstructionSeq {
    seqs.into_iter()
        .reduce(append_instruction_sequences)
        .unwrap_or_else(InstructionSeq::empty)
}
</pre></div>

<p>This procedure uses some simple operations for manipulating sets represented as
lists, similar to the (unordered) set representation described in 
<a class="ref" href="2_002e3.xhtml#g_t2_002e3_002e3">Example: Representing Sets</a>:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">// In Rust, we use HashSet operations:
fn set_union(s1: &amp;HashSet&lt;Register&gt;, s2: &amp;HashSet&lt;Register&gt;) -&gt; HashSet&lt;Register&gt; {
    s1.union(s2).copied().collect()
}

fn set_difference(s1: &amp;HashSet&lt;Register&gt;, s2: &amp;HashSet&lt;Register&gt;) -&gt; HashSet&lt;Register&gt; {
    s1.difference(s2).copied().collect()
}
</pre></div>

<p><code class="code">Preserving</code>, the second major instruction sequence combiner, takes a list
of registers <code class="code">regs</code> and two instruction sequences <code class="code">seq1</code> and
<code class="code">seq2</code> that are to be executed sequentially.  It returns an instruction
sequence whose statements are the statements of <code class="code">seq1</code> followed by the
statements of <code class="code">seq2</code>, with appropriate <code class="code">save</code> and <code class="code">restore</code>
instructions around <code class="code">seq1</code> to protect the registers in <code class="code">regs</code> that
are modified by <code class="code">seq1</code> but needed by <code class="code">seq2</code>.  To accomplish this,
<code class="code">preserving</code> first creates a sequence that has the required <code class="code">save</code>s
followed by the statements of <code class="code">seq1</code> followed by the required
<code class="code">restore</code>s.  This sequence needs the registers being saved and restored in
addition to the registers needed by <code class="code">seq1</code>, and modifies the registers
modified by <code class="code">seq1</code> except for the ones being saved and restored.  This
augmented sequence and <code class="code">seq2</code> are then appended in the usual way.  The
following procedure implements this strategy recursively, walking down the list
of registers to be preserved:<a class="footnote" id="DOCF302" href="#FOOT302"><sup>302</sup></a>
</p>
<div class="example lisp">
<pre class="lisp-preformatted">fn preserving(regs: &amp;[Register], seq1: InstructionSeq, seq2: InstructionSeq) -&gt; InstructionSeq {
    if regs.is_empty() {
        return append_instruction_sequences(seq1, seq2);
    }

    let first_reg = regs[0];
    let rest_regs = &amp;regs[1..];

    if seq1.modifies_register(first_reg) &amp;&amp; seq2.needs_register(first_reg) {
        // Need to save and restore this register
        let mut needs = seq1.needs.clone();
        needs.insert(first_reg);

        let modifies = set_difference(&amp;seq1.modifies, &amp;HashSet::from([first_reg]));

        let mut statements = vec![Instruction::Save {
            register: first_reg,
        }];
        statements.extend(seq1.statements);
        statements.push(Instruction::Restore {
            register: first_reg,
        });

        let protected_seq1 = InstructionSeq::new(needs, modifies, statements);
        preserving(rest_regs, protected_seq1, seq2)
    } else {
        // No save/restore needed for this register
        preserving(rest_regs, seq1, seq2)
    }
}
</pre></div>

<p>Another sequence combiner, <code class="code">tack_on_instruction_sequence</code>, is used by
<code class="code">compile_lambda</code> to append a procedure body to another sequence.  Because
the procedure body is not &ldquo;in line&rdquo; to be executed as part of the combined
sequence, its register use has no impact on the register use of the sequence in
which it is embedded.  We thus ignore the procedure body&rsquo;s sets of needed and
modified registers when we tack it onto the other sequence.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">fn tack_on_instruction_sequence(seq: InstructionSeq, body: InstructionSeq) -&gt; InstructionSeq {
    let mut statements = seq.statements;
    statements.extend(body.statements);
    InstructionSeq::new(seq.needs, seq.modifies, statements)
}
</pre></div>

<p><code class="code">Compile_if</code> and <code class="code">compile_procedure_call</code> use a special combiner
called <code class="code">parallel_instruction_sequences</code> to append the two alternative
branches that follow a test.  The two branches will never be executed
sequentially; for any particular evaluation of the test, one branch or the
other will be entered.  Because of this, the registers needed by the second
branch are still needed by the combined sequence, even if these are modified by
the first branch.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">fn parallel_instruction_sequences(
    seq1: InstructionSeq,
    seq2: InstructionSeq,
) -&gt; InstructionSeq {
    let needs = set_union(&amp;seq1.needs, &amp;seq2.needs);
    let modifies = set_union(&amp;seq1.modifies, &amp;seq2.modifies);
    let mut statements = seq1.statements;
    statements.extend(seq2.statements);
    InstructionSeq::new(needs, modifies, statements)
}
</pre></div>

<hr>
</div>
<div class="subsection-level-extent" id="g_t5_002e5_002e5">
<h4 class="subsection" id="An-Example-of-Compiled-Code"><span>5.5.5 An Example of Compiled Code<a class="copiable-link" href="#An-Example-of-Compiled-Code"> &para;</a></span></h4>

<p>Now that we have seen all the elements of the compiler, let us examine an
example of compiled code to see how things fit together.  We will compile the
definition of a recursive <code class="code">factorial</code> procedure by calling <code class="code">compile</code>:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">// Compile the factorial definition
let factorial_def = Expr::Define {
    name: &quot;factorial&quot;.to_string(),
    value: Box::new(Expr::Lambda {
        params: vec![&quot;n&quot;.to_string()],
        body: vec![Expr::If {
            predicate: Box::new(Expr::Application {
                operator: Box::new(Expr::Symbol(&quot;=&quot;.to_string())),
                operands: vec![Expr::Symbol(&quot;n&quot;.to_string()), Expr::Number(1)],
            }),
            consequent: Box::new(Expr::Number(1)),
            alternative: Box::new(Expr::Application {
                operator: Box::new(Expr::Symbol(&quot;*&quot;.to_string())),
                operands: vec![
                    Expr::Application {
                        operator: Box::new(Expr::Symbol(&quot;factorial&quot;.to_string())),
                        operands: vec![Expr::Application {
                            operator: Box::new(Expr::Symbol(&quot;-&quot;.to_string())),
                            operands: vec![Expr::Symbol(&quot;n&quot;.to_string()), Expr::Number(1)],
                        }],
                    },
                    Expr::Symbol(&quot;n&quot;.to_string()),
                ],
            }),
        }],
    }),
};

let seq = compile(&amp;factorial_def, Register::Val, &amp;Linkage::Next);
</pre></div>

<p>We have specified that the value of the definition expression should be
placed in the <code class="code">val</code> register.  We don&rsquo;t care what the compiled code does
after executing the definition, so our choice of <code class="code">next</code> as the linkage
descriptor is arbitrary.
</p>
<p><code class="code">Compile</code> determines that the expression is a definition, so it calls
<code class="code">compile_definition</code> to compile code to compute the value to be assigned
(targeted to <code class="code">val</code>), followed by code to install the definition, followed
by code to put the value of the definition (which is the symbol <code class="code">ok</code>)
into the target register, followed finally by the linkage code.  <code class="code">Env</code> is
preserved around the computation of the value, because it is needed in order to
install the definition.  Because the linkage is <code class="code">next</code>, there is no
linkage code in this case.  The skeleton of the compiled code is thus
</p>
<div class="example">
<pre class="example-preformatted">⟨<em class="emph">save env if modified by code to compute value</em>⟩
  ⟨<em class="emph">compilation of definition value, 
   target val, linkage next</em>⟩
  ⟨<em class="emph">restore env if saved above</em>⟩
  Perform(Op(&quot;define-variable&quot;.into(),
           vec![VExp::Const(Value::Symbol(&quot;factorial&quot;.into())),
                VExp::Reg(Register::Val),
                VExp::Reg(Register::Env)])),
  Assign(Register::Val, VExp::Const(Value::Ok))
</pre></div>

<p>The expression that is to be compiled to produce the value for the variable
<code class="code">factorial</code> is a <code class="code">lambda</code> expression whose value is the procedure
that computes factorials.  <code class="code">Compile</code> handles this by calling
<code class="code">compile_lambda</code>, which compiles the procedure body, labels it as a new
entry point, and generates the instruction that will combine the procedure body
at the new entry point with the run-time environment and assign the result to
<code class="code">val</code>.  The sequence then skips around the compiled procedure code, which
is inserted at this point.  The procedure code itself begins by extending the
procedure&rsquo;s definition environment by a frame that binds the formal parameter
<code class="code">n</code> to the procedure argument.  Then comes the actual procedure body.
Since this code for the value of the variable doesn&rsquo;t modify the <code class="code">env</code>
register, the optional <code class="code">save</code> and <code class="code">restore</code> shown above aren&rsquo;t
generated.  (The procedure code at <code class="code">entry2</code> isn&rsquo;t executed at this point,
so its use of <code class="code">env</code> is irrelevant.)  Therefore, the skeleton for the
compiled code becomes
</p>
<div class="example">
<pre class="example-preformatted">  Assign(Register::Val, Op(&quot;make-compiled-procedure&quot;.into(),
              vec![VExp::Label(&quot;entry2&quot;.into()),
                   VExp::Reg(Register::Env)])),
  Goto(GotoDest::Label(&quot;after-lambda1&quot;.into())),
Label(&quot;entry2&quot;.into()),
  Assign(Register::Env, Op(&quot;compiled-procedure-env&quot;.into(),
              vec![VExp::Reg(Register::Proc)])),
  Assign(Register::Env, Op(&quot;extend-environment&quot;.into(),
              vec![VExp::Const(Value::Symbol(&quot;n&quot;.into())),
                   VExp::Reg(Register::Argl),
                   VExp::Reg(Register::Env)])),
  ⟨<em class="emph">compilation of procedure body</em>⟩
Label(&quot;after-lambda1&quot;.into()),
  Perform(Op(&quot;define-variable&quot;.into(),
           vec![VExp::Const(Value::Symbol(&quot;factorial&quot;.into())),
                VExp::Reg(Register::Val), 
                VExp::Reg(Register::Env)])),
  Assign(Register::Val, VExp::Const(Value::Ok))
</pre></div>

<p>A procedure body is always compiled (by <code class="code">compile_lambda_body</code>) as a
sequence with target <code class="code">val</code> and linkage <code class="code">return</code>.  The sequence in
this case consists of a single <code class="code">if</code> expression:
</p>
<div class="example">
<pre class="example-preformatted">if n == 1 {
    1
} else {
    factorial(n - 1) * n
}
</pre></div>

<p><code class="code">Compile_if</code> generates code that first computes the predicate (targeted to
<code class="code">val</code>), then checks the result and branches around the true branch if the
predicate is false.  <code class="code">Env</code> and <code class="code">continue</code> are preserved around the
predicate code, since they may be needed for the rest of the <code class="code">if</code>
expression.  Since the <code class="code">if</code> expression is the final expression (and only
expression) in the sequence making up the procedure body, its target is
<code class="code">val</code> and its linkage is <code class="code">return</code>, so the true and false branches are
both compiled with target <code class="code">val</code> and linkage <code class="code">return</code>.  (That is, the
value of the conditional, which is the value computed by either of its
branches, is the value of the procedure.)
</p>
<div class="example">
<pre class="example-preformatted">⟨<em class="emph">save continue, env if modified by 
 predicate and needed by branches</em>⟩
  ⟨<em class="emph">compilation of predicate, 
   target val, linkage next</em>⟩
  ⟨<em class="emph">restore continue, env if saved above</em>⟩
  Test(Op(&quot;is-false&quot;.into(), vec![Reg(Val)])),
  Branch(&quot;false-branch4&quot;.into()),
// true-branch5
  ⟨<em class="emph">compilation of true branch, 
   target val, linkage return</em>⟩
// false-branch4
Label(&quot;false-branch4&quot;.into()),
  ⟨<em class="emph">compilation of false branch, 
   target val, linkage return</em>⟩
Label(&quot;after-if3&quot;.into()),
</pre></div>

<p>The predicate <code class="code">(= n 1)</code> is a procedure call.  This looks up the operator
(the symbol <code class="code">=</code>) and places this value in <code class="code">proc</code>.  It then assembles
the arguments <code class="code">1</code> and the value of <code class="code">n</code> into <code class="code">argl</code>.  Then it
</p>
<p><b class="b">Rust (compile dispatch):</b>
</p><div class="example">
<pre class="example-preformatted">pub fn compile(
    expr: &amp;Expr,
    target: Register,
    linkage: Linkage
) -&gt; InstructionSeq {
    match expr {
        Expr::Number(n) =&gt; compile_self_evaluating(*n, target, linkage),
        Expr::Symbol(name) =&gt; compile_variable(name, target, linkage),
        Expr::Lambda { params, body } =&gt;
            compile_lambda(params, body, target, linkage),
        Expr::If { predicate, consequent, alternative } =&gt;
            compile_if(predicate, consequent, alternative, target, linkage),
        Expr::Application { operator, operands } =&gt;
            compile_application(operator, operands, target, linkage),
        // ... other cases ...
    }
}
</pre></div>

<p>tests whether <code class="code">proc</code> contains a primitive or a compound procedure, and
dispatches to a primitive branch or a compound branch accordingly.  Both
branches resume at the <code class="code">after_call</code> label.  The requirements to preserve
registers around the evaluation of the operator and operands don&rsquo;t result in
any saving of registers, because in this case those evaluations don&rsquo;t modify
the registers in question.
</p>
<div class="example">
<pre class="example-preformatted">  Assign(Proc, Op(&quot;lookup-variable-value&quot;.into(),
               vec![VExp::Const(Value::Symbol(&quot;=&quot;.into())), 
                    VExp::Reg(Env)])),
  Assign(Val, VExp::Const(Value::Number(1))),
  Assign(Argl, Op(&quot;list&quot;.into(), vec![VExp::Reg(Val)])),
  Assign(Val, Op(&quot;lookup-variable-value&quot;.into(),
              vec![VExp::Const(Value::Symbol(&quot;n&quot;.into())),
                   VExp::Reg(Env)])),
  Assign(Argl, Op(&quot;cons&quot;.into(), vec![VExp::Reg(Val), VExp::Reg(Argl)])),
  Test(Op(&quot;is-primitive-procedure&quot;.into(), vec![Reg(Proc)])),
  Branch(&quot;primitive-branch17&quot;.into()),
// compiled-branch16
Label(&quot;compiled-branch16&quot;.into()),
  Assign(Continue, Label(&quot;after-call15&quot;.into())),
  Assign(Val, Op(&quot;compiled-procedure-entry&quot;.into(),
              vec![VExp::Reg(Proc)])),
  Goto(GotoDest::Reg(Val)),
// primitive-branch17
Label(&quot;primitive-branch17&quot;.into()),
  Assign(Val, Op(&quot;apply-primitive-procedure&quot;.into(),
              vec![VExp::Reg(Proc),
                   VExp::Reg(Argl)])),
Label(&quot;after-call15&quot;.into()),
</pre></div>

<p>The true branch, which is the constant 1, compiles (with target <code class="code">val</code> and
linkage <code class="code">return</code>) to
</p>
<div class="example">
<pre class="example-preformatted">Assign(Val, VExp::Const(Value::Number(1))),
Goto(Reg(Continue)),
</pre></div>

<p>The code for the false branch is another procedure call, where the procedure
is the value of the symbol <code class="code">*</code>, and the arguments are <code class="code">n</code> and the
result of another procedure call (a call to <code class="code">factorial</code>).  Each of these
calls sets up <code class="code">proc</code> and <code class="code">argl</code> and its own primitive and compound
branches.  <a class="ref" href="#Figure-5_002e17">Figure 5.17</a> shows the complete compilation of the definition
of the <code class="code">factorial</code> procedure.  Notice that the possible <code class="code">save</code> and
<code class="code">restore</code> of <code class="code">continue</code> and <code class="code">env</code> around the predicate, shown
above, are in fact generated, because these registers are modified by the
procedure call in the predicate and needed for the procedure call and the
<code class="code">return</code> linkage in the branches.
</p>
<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Figure-5_002e17"></a>Figure 5.17:</strong> <em class="math">\downarrow</em> Compilation of the definition of the <code class="code">factorial</code> procedure.
</p>
<div class="example">
<pre class="example-preformatted">vec![
    // construct the procedure and skip over code
    Assign(Val, Op(&quot;make-compiled-procedure&quot;.into(), 
        vec![Label(&quot;entry2&quot;.into()), Reg(Env)])),
    Goto(Label(&quot;after-lambda1&quot;.into())),
// entry2
Label(&quot;entry2&quot;.into()),
    Assign(Env, Op(&quot;compiled-procedure-env&quot;.into(), vec![Reg(Proc)])),
    Assign(Env, Op(&quot;extend-environment&quot;.into(), 
        vec![Const(Symbol(&quot;n&quot;.into())), Reg(Argl), Reg(Env)])),
    // begin actual procedure body
    Save(Continue),
    Save(Env),
    // compute (= n 1)
    Assign(Proc, Op(&quot;lookup-variable-value&quot;.into(), 
        vec![Const(Symbol(&quot;=&quot;.into())), Reg(Env)])),
    Assign(Val, Const(1)),
    Assign(Argl, Op(&quot;list&quot;.into(), vec![Reg(Val)])),
    Assign(Val, Op(&quot;lookup-variable-value&quot;.into(), 
        vec![Const(Symbol(&quot;n&quot;.into())), Reg(Env)])),
    Assign(Argl, Op(&quot;cons&quot;.into(), vec![Reg(Val), Reg(Argl)])),
    Test(Op(&quot;is-primitive-procedure&quot;.into(), vec![Reg(Proc)])),
    Branch(&quot;primitive-branch17&quot;.into()),
// compiled-branch16
Label(&quot;compiled-branch16&quot;.into()),
    Assign(Continue, Label(&quot;after-call15&quot;.into())),
    Assign(Val, Op(&quot;compiled-procedure-entry&quot;.into(), vec![Reg(Proc)])),
    Goto(Reg(Val)),
// primitive-branch17
Label(&quot;primitive-branch17&quot;.into()),
    Assign(Val, Op(&quot;apply-primitive-procedure&quot;.into(), 
        vec![Reg(Proc), Reg(Argl)])),
// after-call15
Label(&quot;after-call15&quot;.into()),
    Restore(Env),
    Restore(Continue),
    Test(Op(&quot;is-false&quot;.into(), vec![Reg(Val)])),
    Branch(&quot;false-branch4&quot;.into()),
// true-branch5
Label(&quot;true-branch5&quot;.into()),
    Assign(Val, Const(1)),
    Goto(Reg(Continue)),
// false-branch4
Label(&quot;false-branch4&quot;.into()),
    // compute (* (factorial (- n 1)) n)
    Assign(Proc, Op(&quot;lookup-variable-value&quot;.into(), 
        vec![Const(Symbol(&quot;*&quot;.into())), Reg(Env)])),
    Save(Continue),
    Save(Proc),
    Assign(Val, Op(&quot;lookup-variable-value&quot;.into(), 
        vec![Const(Symbol(&quot;n&quot;.into())), Reg(Env)])),
    Assign(Argl, Op(&quot;list&quot;.into(), vec![Reg(Val)])),
    Save(Argl),
    // compute (factorial (- n 1))
    Assign(Proc, Op(&quot;lookup-variable-value&quot;.into(), 
        vec![Const(Symbol(&quot;factorial&quot;.into())), Reg(Env)])),
    Save(Proc),
    // compute (- n 1)
    Assign(Proc, Op(&quot;lookup-variable-value&quot;.into(), 
        vec![Const(Symbol(&quot;-&quot;.into())), Reg(Env)])),
    Assign(Val, Const(1)),
    Assign(Argl, Op(&quot;list&quot;.into(), vec![Reg(Val)])),
    Assign(Val, Op(&quot;lookup-variable-value&quot;.into(), 
        vec![Const(Symbol(&quot;n&quot;.into())), Reg(Env)])),
    Assign(Argl, Op(&quot;cons&quot;.into(), vec![Reg(Val), Reg(Argl)])),
    Test(Op(&quot;is-primitive-procedure&quot;.into(), vec![Reg(Proc)])),
    Branch(&quot;primitive-branch8&quot;.into()),
// compiled-branch7
Label(&quot;compiled-branch7&quot;.into()),
    Assign(Continue, Label(&quot;after-call6&quot;.into())),
    Assign(Val, Op(&quot;compiled-procedure-entry&quot;.into(), vec![Reg(Proc)])),
    Goto(Reg(Val)),
// primitive-branch8
Label(&quot;primitive-branch8&quot;.into()),
    Assign(Val, Op(&quot;apply-primitive-procedure&quot;.into(), 
        vec![Reg(Proc), Reg(Argl)])),
// after-call6
Label(&quot;after-call6&quot;.into()),
    Assign(Argl, Op(&quot;list&quot;.into(), vec![Reg(Val)])),
    Restore(Proc),
    Test(Op(&quot;is-primitive-procedure&quot;.into(), vec![Reg(Proc)])),
    Branch(&quot;primitive-branch11&quot;.into()),
// compiled-branch10
Label(&quot;compiled-branch10&quot;.into()),
    Assign(Continue, Label(&quot;after-call9&quot;.into())),
    Assign(Val, Op(&quot;compiled-procedure-entry&quot;.into(), vec![Reg(Proc)])),
    Goto(Reg(Val)),
// primitive-branch11
Label(&quot;primitive-branch11&quot;.into()),
    Assign(Val, Op(&quot;apply-primitive-procedure&quot;.into(), 
        vec![Reg(Proc), Reg(Argl)])),
// after-call9
Label(&quot;after-call9&quot;.into()),
    Restore(Argl),
    Assign(Argl, Op(&quot;cons&quot;.into(), vec![Reg(Val), Reg(Argl)])),
    Restore(Proc),
    Restore(Continue),
    // apply *
    Test(Op(&quot;is-primitive-procedure&quot;.into(), vec![Reg(Proc)])),
    Branch(&quot;primitive-branch14&quot;.into()),
// compiled-branch13
Label(&quot;compiled-branch13&quot;.into()),
    Assign(Val, Op(&quot;compiled-procedure-entry&quot;.into(), vec![Reg(Proc)])),
    Goto(Reg(Val)),
// primitive-branch14
Label(&quot;primitive-branch14&quot;.into()),
    Assign(Val, Op(&quot;apply-primitive-procedure&quot;.into(), 
        vec![Reg(Proc), Reg(Argl)])),
    Goto(Reg(Continue)),
// after-call12, after-if3, after-lambda1
Label(&quot;after-lambda1&quot;.into()),
    Perform(Op(&quot;define-variable&quot;.into(), 
        vec![Const(Symbol(&quot;factorial&quot;.into())), Reg(Val), Reg(Env)])),
    Assign(Val, Const(Value::Ok)),
]
</pre></div>
</blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-5_002e33"></a>Exercise 5.33:</strong> Consider the following definition
of a factorial procedure, which is slightly different from the one given above:
</p>
<div class="example">
<pre class="example-preformatted">fn factorial_alt(n: i64) -&gt; i64 {
    if n == 1 {
        1
    } else {
        n * factorial_alt(n - 1)
    }
}
</pre></div>

<p>Compile this procedure and compare the resulting code with that produced for
<code class="code">factorial</code>.  Explain any differences you find.  Does either program
execute more efficiently than the other?
</p></blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-5_002e34"></a>Exercise 5.34:</strong> Compile the iterative factorial
procedure
</p>
<div class="example">
<pre class="example-preformatted">fn factorial(n: u64) -&gt; u64 {
    fn iter(product: u64, counter: u64) -&gt; u64 {
        if counter &gt; n {
            product
        } else {
            iter(counter * product, counter + 1)
        }
    }
    iter(1, 1)
}
</pre></div>

<p>Annotate the resulting code, showing the essential difference between the code
for iterative and recursive versions of <code class="code">factorial</code> that makes one process
build up stack space and the other run in constant stack space.
</p></blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-5_002e35"></a>Exercise 5.35:</strong> What expression was compiled to
produce the code shown in <a class="ref" href="#Figure-5_002e18">Figure 5.18</a>?
</p></blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Figure-5_002e18"></a>Figure 5.18:</strong> <em class="math">\downarrow</em> An example of compiler output.  See
<a class="ref" href="#Exercise-5_002e35">Exercise 5.35</a>.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">vec![
    Assign(Val, Op(&quot;make-compiled-procedure&quot;.into(), 
        vec![Label(&quot;entry16&quot;.into()), Reg(Env)])),
    Goto(Label(&quot;after-lambda15&quot;.into())),
// entry16
Label(&quot;entry16&quot;.into()),
    Assign(Env, Op(&quot;compiled-procedure-env&quot;.into(), vec![Reg(Proc)])),
    Assign(Env, Op(&quot;extend-environment&quot;.into(), 
        vec![Const(Value::Symbol(&quot;x&quot;.into())), Reg(Argl), Reg(Env)])),
    Assign(Proc, Op(&quot;lookup-variable-value&quot;.into(), 
        vec![Const(Value::Symbol(&quot;+&quot;.into())), Reg(Env)])),
    Save(Continue), Save(Proc), Save(Env),
    Assign(Proc, Op(&quot;lookup-variable-value&quot;.into(), 
        vec![Const(Value::Symbol(&quot;g&quot;.into())), Reg(Env)])),
    Save(Proc),
    Assign(Proc, Op(&quot;lookup-variable-value&quot;.into(), 
        vec![Const(Value::Symbol(&quot;+&quot;.into())), Reg(Env)])),
    Assign(Val, Const(Value::Number(2))),
    Assign(Argl, Op(&quot;list&quot;.into(), vec![Reg(Val)])),
    Assign(Val, Op(&quot;lookup-variable-value&quot;.into(), 
        vec![Const(Value::Symbol(&quot;x&quot;.into())), Reg(Env)])),
    Assign(Argl, Op(&quot;cons&quot;.into(), vec![Reg(Val), Reg(Argl)])),
    Test(Op(&quot;is-primitive-procedure&quot;.into(), vec![Reg(Proc)])),
    Branch(&quot;primitive-branch19&quot;.into()),
// compiled-branch18
Label(&quot;compiled-branch18&quot;.into()),
    Assign(Continue, Label(&quot;after-call17&quot;.into())),
    Assign(Val, Op(&quot;compiled-procedure-entry&quot;.into(), vec![Reg(Proc)])),
    Goto(Reg(Val)),
// primitive-branch19
Label(&quot;primitive-branch19&quot;.into()),
    Assign(Val, Op(&quot;apply-primitive-procedure&quot;.into(), vec![Reg(Proc), Reg(Argl)])),
// after-call17
Label(&quot;after-call17&quot;.into()),
    Assign(Argl, Op(&quot;list&quot;.into(), vec![Reg(Val)])),
    Restore(Proc),
    Test(Op(&quot;is-primitive-procedure&quot;.into(), vec![Reg(Proc)])),
    Branch(&quot;primitive-branch22&quot;.into()),
// compiled-branch21
Label(&quot;compiled-branch21&quot;.into()),
    Assign(Continue, Label(&quot;after-call20&quot;.into())),
    Assign(Val, Op(&quot;compiled-procedure-entry&quot;.into(), vec![Reg(Proc)])),
    Goto(Reg(Val)),
// primitive-branch22
Label(&quot;primitive-branch22&quot;.into()),
    Assign(Val, Op(&quot;apply-primitive-procedure&quot;.into(), vec![Reg(Proc), Reg(Argl)])),
// after-call20
Label(&quot;after-call20&quot;.into()),
    Assign(Argl, Op(&quot;list&quot;.into(), vec![Reg(Val)])),
    Restore(Env),
    Assign(Val, Op(&quot;lookup-variable-value&quot;.into(), 
        vec![Const(Value::Symbol(&quot;x&quot;.into())), Reg(Env)])),
    Assign(Argl, Op(&quot;cons&quot;.into(), vec![Reg(Val), Reg(Argl)])),
    Restore(Proc),
    Restore(Continue),
    Test(Op(&quot;is-primitive-procedure&quot;.into(), vec![Reg(Proc)])),
    Branch(&quot;primitive-branch25&quot;.into()),
// compiled-branch24
Label(&quot;compiled-branch24&quot;.into()),
    Assign(Val, Op(&quot;compiled-procedure-entry&quot;.into(), vec![Reg(Proc)])),
    Goto(Reg(Val)),
// primitive-branch25
Label(&quot;primitive-branch25&quot;.into()),
    Assign(Val, Op(&quot;apply-primitive-procedure&quot;.into(), vec![Reg(Proc), Reg(Argl)])),
    Goto(Reg(Continue)),
// after-call23
Label(&quot;after-lambda15&quot;.into()),
    Perform(Op(&quot;define-variable&quot;.into(), 
        vec![Const(Value::Symbol(&quot;f&quot;.into())), Reg(Val), Reg(Env)])),
    Assign(Val, Const(Value::Ok)),
]
</pre></div>
</blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-5_002e36"></a>Exercise 5.36:</strong> What order of evaluation does our
compiler produce for operands of a combination?  Is it left-to-right,
right-to-left, or some other order?  Where in the compiler is this order
determined?  Modify the compiler so that it produces some other order of
evaluation.  (See the discussion of order of evaluation for the
explicit-control evaluator in <a class="ref" href="5_002e4.xhtml#g_t5_002e4_002e1">The Core of the Explicit-Control Evaluator</a>.)  How does changing the
order of operand evaluation affect the efficiency of the code that constructs
the argument list?
</p></blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-5_002e37"></a>Exercise 5.37:</strong> One way to understand the
compiler&rsquo;s <code class="code">preserving</code> mechanism for optimizing stack usage is to see
what extra operations would be generated if we did not use this idea.  Modify
<code class="code">preserving</code> so that it always generates the <code class="code">save</code> and
<code class="code">restore</code> operations.  Compile some simple expressions and identify the
unnecessary stack operations that are generated.  Compare the code to that
generated with the <code class="code">preserving</code> mechanism intact.
</p></blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-5_002e38"></a>Exercise 5.38:</strong> Our compiler is clever about
avoiding unnecessary stack operations, but it is not clever at all when it
comes to compiling calls to the primitive procedures of the language in terms
of the primitive operations supplied by the machine.  For example, consider how
much code is compiled to compute <code class="code">(+ a 1)</code>: The code sets up an argument
list in <code class="code">argl</code>, puts the primitive addition procedure (which it finds by
looking up the symbol <code class="code">+</code> in the environment) into <code class="code">proc</code>, and tests
whether the procedure is primitive or compound.  The compiler always generates
code to perform the test, as well as code for primitive and compound branches
(only one of which will be executed).  We have not shown the part of the
controller that implements primitives, but we presume that these instructions
make use of primitive arithmetic operations in the machine&rsquo;s data paths.
Consider how much less code would be generated if the compiler could
<a class="index-entry-id" id="index-open_002dcode"></a>
<em class="dfn">open-code</em> primitives&mdash;that is, if it could generate code to directly
use these primitive machine operations.  The expression <code class="code">(+ a 1)</code> might be
compiled into something as simple as<a class="footnote" id="DOCF303" href="#FOOT303"><sup>303</sup></a>
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(assign val (op lookup_variable_value) 
            (const a) 
            (reg env))
(assign val (op +)
            (reg val)
            (const 1))
</pre></div>

<p>In this exercise we will extend our compiler to support open coding of selected
primitives.  Special-purpose code will be generated for calls to these
primitive procedures instead of the general procedure-application code.  In
order to support this, we will augment our machine with special argument
registers <code class="code">arg1</code> and <code class="code">arg2</code>.  The primitive arithmetic operations of
the machine will take their inputs from <code class="code">arg1</code> and <code class="code">arg2</code>. The
results may be put into <code class="code">val</code>, <code class="code">arg1</code>, or <code class="code">arg2</code>.
</p>
<p>The compiler must be able to recognize the application of an open-coded
primitive in the source program.  We will augment the dispatch in the
<code class="code">compile</code> procedure to recognize the names of these primitives in addition
to the reserved words (the special forms) it currently
recognizes.<a class="footnote" id="DOCF304" href="#FOOT304"><sup>304</sup></a> For each special
form our compiler has a code generator.  In this exercise we will construct a
family of code generators for the open-coded primitives.
</p>
<ol class="enumerate" type="a" start="1">
<li> The open-coded primitives, unlike the special forms, all need their operands
evaluated.  Write a code generator <code class="code">spread_arguments</code> for use by all the
open-coding code generators.  <code class="code">Spread-arguments</code> should take an operand
list and compile the given operands targeted to successive argument registers.
Note that an operand may contain a call to an open-coded primitive, so argument
registers will have to be preserved during operand evaluation.

</li><li> For each of the primitive procedures <code class="code">=</code>, <code class="code">*</code>, <code class="code">-</code>, and
<code class="code">+</code>, write a code generator that takes a combination with that operator,
together with a target and a linkage descriptor, and produces code to spread
the arguments into the registers and then perform the operation targeted to the
given target with the given linkage.  You need only handle expressions with two
operands.  Make <code class="code">compile</code> dispatch to these code generators.

</li><li> Try your new compiler on the <code class="code">factorial</code> example.  Compare the resulting
code with the result produced without open coding.

</li><li> Extend your code generators for <code class="code">+</code> and <code class="code">*</code> so that they can handle
expressions with arbitrary numbers of operands.  An expression with more than
two operands will have to be compiled into a sequence of operations, each with
only two inputs.

</li></ol>
</blockquote>

<hr>
</div>
<div class="subsection-level-extent" id="g_t5_002e5_002e6">
<h4 class="subsection" id="Lexical-Addressing"><span>5.5.6 Lexical Addressing<a class="copiable-link" href="#Lexical-Addressing"> &para;</a></span></h4>

<p>One of the most common optimizations performed by compilers is the optimization
of variable lookup.  Our compiler, as we have implemented it so far, generates
code that uses the <code class="code">lookup_variable_value</code> operation of the evaluator
machine.  This searches for a variable by comparing it with each variable that
is currently bound, working frame by frame outward through the run-time
environment.  This search can be expensive if the frames are deeply nested or
if there are many variables.  For example, consider the problem of looking up
the value of <code class="code">x</code> while evaluating the expression <code class="code">(* x y z)</code> in an
application of the procedure that is returned by
</p>
<div class="example">
<pre class="example-preformatted">{
    let x = 3;
    let y = 4;
    |a, b, c, d, e| {
        let y = a * b * x;
        let z = c + d + x;
        x * y * z
    }
}
</pre></div>

<p>This expression involves nested scopes. The variables are bound in a sequence of
environments. For example, when <code class="code">x * y * z</code> is evaluated, <code class="code">x</code> is
found in the outermost scope, while <code class="code">y</code> and <code class="code">z</code> are in the innermost
scope.
</p>
<p>Since a <code class="code">let</code> expression is conceptually equivalent to an
immediately-invoked closure, this expression is equivalent to:
</p>
<div class="example">
<pre class="example-preformatted">(|x, y| {
    |a, b, c, d, e| {
        (|y, z| {
            x * y * z
        })(a * b * x, c * d * x)
    }
})(3, 4)
</pre></div>

<p>Each time <code class="code">lookup_variable_value</code> searches for <code class="code">x</code>, it must determine
that the symbol <code class="code">x</code> is not <code class="code">eq?</code> to <code class="code">y</code> or <code class="code">z</code> (in the
first frame), nor to <code class="code">a</code>, <code class="code">b</code>, <code class="code">c</code>, <code class="code">d</code>, or <code class="code">e</code> (in
the second frame).  We will assume, for the moment, that our programs do not
use definition&mdash;that variables are bound only with <code class="code">lambda</code>.  Because
our language is lexically scoped, the run-time environment for any expression
will have a structure that parallels the lexical structure of the program in
which the expression appears.<a class="footnote" id="DOCF305" href="#FOOT305"><sup>305</sup></a> Thus, the
compiler can know, when it analyzes the above expression, that each time the
procedure is applied the variable <code class="code">x</code> in <code class="code">(* x y z)</code> will be found
two frames out from the current frame and will be the first variable in that
frame.
</p>
<p>We can exploit this fact by inventing a new kind of variable-lookup operation,
<code class="code">lexical_address_lookup</code>, that takes as arguments an environment and a
<a class="index-entry-id" id="index-lexical-address"></a>
<em class="dfn">lexical address</em> that consists of two numbers: a <a class="index-entry-id" id="index-frame-number"></a>
<em class="dfn">frame number</em>, 
which specifies how many frames to pass over, and a
<a class="index-entry-id" id="index-displacement-number"></a>
<em class="dfn">displacement number</em>, which specifies how many variables to pass over
in that frame.  <code class="code">Lexical-address-lookup</code> will produce the value of the
variable stored at that lexical address relative to the current environment.
If we add the <code class="code">lexical_address_lookup</code> operation to our machine, we can
make the compiler generate code that references variables using this operation,
rather than <code class="code">lookup_variable_value</code>.  Similarly, our compiled code can use
a new <code class="code">lexical_address_set</code>  operation instead of
<code class="code">set_variable_value</code>.
</p>
<p>In order to generate such code, the compiler must be able to determine the
lexical address of a variable it is about to compile a reference to.  The
lexical address of a variable in a program depends on where one is in the code.
For example, in the following program, the address of <code class="code">x</code> in expression
<code class="code">⟨</code><var class="var">e1</var><code class="code">⟩</code> is (2, 0)&mdash;two frames back and the first variable in the frame.  At
that point <code class="code">y</code> is at address (0, 0) and <code class="code">c</code> is at address (1, 2).  In
expression <code class="code">⟨</code><var class="var">e2</var><code class="code">⟩</code>, <code class="code">x</code> is at (1, 0), <code class="code">y</code> is at (1, 1), and <code class="code">c</code>
is at (0, 2).
</p>
<div class="example">
<pre class="example-preformatted">(|x, y| {
    |a, b, c, d, e| {
        (|y, z| {
            ⟨<var class="var">e1</var>⟩
        })(⟨<var class="var">e2</var>⟩, c + d + x)
    }
})(3, 4)
</pre></div>

<p>One way for the compiler to produce code that uses lexical addressing is to
maintain a data structure called a <a class="index-entry-id" id="index-compile_002dtime-environment"></a>
<em class="dfn">compile-time environment</em>.  This
keeps track of which variables will be at which positions in which frames in
the run-time environment when a particular variable-access operation is
executed.  The compile-time environment is a list of frames, each containing a
list of variables.  (There will of course be no values bound to the variables,
since values are not computed at compile time.)  The compile-time environment
becomes an additional argument to <code class="code">compile</code> and is passed along to each
code generator.  The top-level call to <code class="code">compile</code> uses an empty
compile-time environment.  When a <code class="code">lambda</code> body is compiled,
<code class="code">compile_lambda_body</code> extends the compile-time environment by a frame
containing the procedure&rsquo;s parameters, so that the sequence making up the body
is compiled with that extended environment.  At each point in the compilation,
<code class="code">compile_variable</code> and <code class="code">compile_assignment</code> use the compile-time
environment in order to generate the appropriate lexical addresses.
</p>
<p><a class="ref" href="#Exercise-5_002e39">Exercise 5.39</a> through <a class="ref" href="#Exercise-5_002e43">Exercise 5.43</a> describe how to complete this
sketch of the lexical-addressing strategy in order to incorporate lexical
lookup into the compiler.  <a class="ref" href="#Exercise-5_002e44">Exercise 5.44</a> describes another use for the
compile-time environment.
</p>
<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-5_002e39"></a>Exercise 5.39:</strong> Write a procedure
<code class="code">lexical_address_lookup</code> that implements the new lookup operation.  It
should take two arguments&mdash;a lexical address and a run-time environment&mdash;and
return the value of the variable stored at the specified lexical address.
<code class="code">Lexical-address-lookup</code> should signal an error if the value of the
variable is the symbol <code class="code">*unassigned*</code>.<a class="footnote" id="DOCF306" href="#FOOT306"><sup>306</sup></a> Also write a procedure
<code class="code">lexical_address_set</code> that implements the operation that changes the
value of the variable at a specified lexical address.
</p></blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-5_002e40"></a>Exercise 5.40:</strong> Modify the compiler to maintain
the compile-time environment as described above.  That is, add a
compile_time_environment argument to <code class="code">compile</code> and the various code
generators, and extend it in <code class="code">compile_lambda_body</code>.
</p></blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-5_002e41"></a>Exercise 5.41:</strong> Write a procedure
<code class="code">find_variable</code> that takes as arguments a variable and a compile-time
environment and returns the lexical address of the variable with respect to
that environment.  For example, in the program fragment that is shown above,
the compile-time environment during the compilation of expression <code class="code">⟨</code><var class="var">e1</var><code class="code">⟩</code> is
<code class="code">((y z) (a b c d e) (x y))</code>.  <code class="code">Find-variable</code> should produce
</p>
<div class="example">
<pre class="example-preformatted">find_variable(&quot;c&quot;, &amp;[[&quot;y&quot;, &quot;z&quot;], [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;], [&quot;x&quot;, &quot;y&quot;]])
<i class="i">Some((1, 2))</i>

find_variable(&quot;x&quot;, &amp;[[&quot;y&quot;, &quot;z&quot;], [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;], [&quot;x&quot;, &quot;y&quot;]])
<i class="i">Some((2, 0))</i>

find_variable(&quot;w&quot;, &amp;[[&quot;y&quot;, &quot;z&quot;], [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;], [&quot;x&quot;, &quot;y&quot;]])
<i class="i">None</i>
</pre></div>
</blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-5_002e42"></a>Exercise 5.42:</strong> Using <code class="code">find_variable</code> from
<a class="ref" href="#Exercise-5_002e41">Exercise 5.41</a>, rewrite <code class="code">compile_variable</code> and
<code class="code">compile_assignment</code> to output lexical-address instructions.  In cases
where <code class="code">find_variable</code> returns <code class="code">not-found</code> (that is, where the
variable is not in the compile-time environment), you should have the code
generators use the evaluator operations, as before, to search for the binding.
(The only place a variable that is not found at compile time can be is in the
global environment, which is part of the run-time environment but is not part
of the compile-time environment.<a class="footnote" id="DOCF307" href="#FOOT307"><sup>307</sup></a>  Thus, if you wish, you may have the evaluator operations look
directly in the global environment, which can be obtained with the operation
<code class="code">(op get_global_environment)</code>, instead of having them search the whole
run-time environment found in <code class="code">env</code>.)  Test the modified compiler on a few
simple cases, such as the nested <code class="code">lambda</code> combination at the beginning of
this section.
</p></blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-5_002e43"></a>Exercise 5.43:</strong> We argued in <a class="ref" href="4_002e1.xhtml#g_t4_002e1_002e6">Internal Definitions</a>
that internal definitions for block structure should not be considered &ldquo;real&rdquo;
definitions.  Rather, a procedure body should be interpreted as if the
internal variables being defined were installed as ordinary <code class="code">lambda</code>
variables initialized to their correct values using <code class="code">set!</code>.  
<a class="ref" href="4_002e1.xhtml#g_t4_002e1_002e6">Internal Definitions</a> and <a class="ref" href="4_002e1.xhtml#Exercise-4_002e16">Exercise 4.16</a> showed how to modify the metacircular
interpreter to accomplish this by scanning out internal definitions.  Modify
the compiler to perform the same transformation before it compiles a procedure
body.
</p></blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-5_002e44"></a>Exercise 5.44:</strong> In this section we have focused
on the use of the compile-time environment to produce lexical addresses.  But
there are other uses for compile-time environments.  For instance, in
<a class="ref" href="#Exercise-5_002e38">Exercise 5.38</a> we increased the efficiency of compiled code by open-coding
primitive procedures.  Our implementation treated the names of open-coded
procedures as reserved words.  If a program were to rebind such a name, the
mechanism described in <a class="ref" href="#Exercise-5_002e38">Exercise 5.38</a> would still open-code it as a
primitive, ignoring the new binding.  For example, consider the procedure
</p>
<div class="example">
<pre class="example-preformatted">|plus, mult, a, b, x, y| {
    plus(mult(a, x), mult(b, y))
}
</pre></div>

<p>which computes a linear combination of <code class="code">x</code> and <code class="code">y</code>.  We might call it
with arguments <code class="code">+matrix</code>, <code class="code">*matrix</code>, and four matrices, but the
open-coding compiler would still open-code the <code class="code">+</code> and the <code class="code">*</code> in
<code class="code">(+ (* a x) (* b y))</code> as primitive <code class="code">+</code> and <code class="code">*</code>.  Modify the
open-coding compiler to consult the compile-time environment in order to
compile the correct code for expressions involving the names of primitive
procedures.  (The code will work correctly as long as the program does not
definition or <code class="code">set!</code> these names.)
</p></blockquote>

<hr>
</div>
<div class="subsection-level-extent" id="g_t5_002e5_002e7">
<h4 class="subsection" id="Interfacing-Compiled-Code-to-the-Evaluator"><span>5.5.7 Interfacing Compiled Code to the Evaluator<a class="copiable-link" href="#Interfacing-Compiled-Code-to-the-Evaluator"> &para;</a></span></h4>

<p>We have not yet explained how to load compiled code into the evaluator machine
or how to run it.  We will assume that the explicit-control-evaluator machine
has been defined as in <a class="ref" href="5_002e4.xhtml#g_t5_002e4_002e4">Running the Evaluator</a>, with the additional operations
specified in <a class="ref" href="#Footnote-323">Footnote 323</a>.  We will implement a procedure
<code class="code">compile_and_go</code> that compiles a Scheme expression, loads the resulting
object code into the evaluator machine, and causes the machine to run the code
in the evaluator global environment, print the result, and enter the
evaluator&rsquo;s driver loop.  We will also modify the evaluator so that interpreted
expressions can call compiled procedures as well as interpreted ones.  We can
then put a compiled procedure into the machine and use the evaluator to call
it:
</p>
<div class="example">
<pre class="example-preformatted">// In Rust, we would do this by compiling and then running the machine:
let factorial_def = Expr::Define {
    name: &quot;factorial&quot;.to_string(),
    value: Box::new(Expr::Lambda { /* ... */ }),
};

// Compile the expression
let seq = compile(&amp;factorial_def, Register::Val, &amp;Linkage::Return);
let instructions = assemble(seq.statements, &amp;machine.register_map, &amp;machine.operations);

// Load and run
machine.set_register(&quot;val&quot;, Value::InstructionPointer(0));
machine.set_register(&quot;flag&quot;, Value::Bool(true));
machine.start();
<i class="i">ok</i>

<i class="i">;;; EC-Eval input:</i>
factorial(5)

<i class="i">;;; EC-Eval value:</i>
<i class="i">120</i>
</pre></div>

<p>To allow the evaluator to handle compiled procedures (for example, to evaluate
the call to <code class="code">factorial</code> above), we need to change the code at
<code class="code">apply_dispatch</code> (<a class="ref" href="5_002e4.xhtml#g_t5_002e4_002e1">The Core of the Explicit-Control Evaluator</a>) so that it recognizes compiled
procedures (as distinct from compound or primitive procedures) and transfers
control directly to the entry point of the compiled code:<a class="footnote" id="DOCF308" href="#FOOT308"><sup>308</sup></a>
</p>
<div class="example">
<pre class="example-preformatted">// apply-dispatch
Label(&quot;apply-dispatch&quot;.into()),
match self.proc.as_ref().unwrap() {
    Value::Primitive(_) =&gt; { self.current_label = Label::PrimitiveApply; }
    Value::Procedure { .. } =&gt; { self.current_label = Label::CompoundApply; }
    Value::CompiledProcedure { .. } =&gt; { self.current_label = Label::CompiledApply; }
    _ =&gt; { self.current_label = Label::UnknownProcedureType; }
}

// compiled-apply
Label(&quot;compiled-apply&quot;.into()),
Restore(Continue),
Assign(Val, Op(&quot;compiled-procedure-entry&quot;.into(), vec![Reg(Proc)])),
Goto(Reg(Val)),
</pre></div>

<p>Note the restore of <code class="code">continue</code> at <code class="code">compiled_apply</code>.  Recall that the
evaluator was arranged so that at <code class="code">apply_dispatch</code>, the continuation would
be at the top of the stack.  The compiled code entry point, on the other hand,
expects the continuation to be in <code class="code">continue</code>, so <code class="code">continue</code> must be
restored before the compiled code is executed.
</p>
<p>To enable us to run some compiled code when we start the evaluator machine, we
add a <code class="code">branch</code> instruction at the beginning of the evaluator machine,
which causes the machine to go to a new entry point if the <code class="code">flag</code> register
is set.
</p>
<div class="example lisp">
<pre class="lisp-preformatted"><span class="r">;; branches if <code class="code">flag</code> is set:</span>
(branch (label external_entry)) 
read_eval_print_loop
  (perform (op initialize_stack))
  <span class="r">…</span>
</pre></div>

<p><code class="code">External_entry</code> assumes that the machine is started with <code class="code">val</code>
containing the location of an instruction sequence that puts a result into
<code class="code">val</code> and ends with <code class="code">(goto (reg continue))</code>.  Starting at this entry
point jumps to the location designated by <code class="code">val</code>, but first assigns
<code class="code">continue</code> so that execution will return to <code class="code">print_result</code>, which
prints the value in <code class="code">val</code> and then goes to the beginning of the
evaluator&rsquo;s read-eval-print loop.
</p>
<div class="example">
<pre class="example-preformatted">// external-entry
Label(&quot;external-entry&quot;.into()),
Perform(Op(&quot;initialize-stack&quot;.into(), vec![])),
Assign(Env, Op(&quot;get-global-environment&quot;.into(), vec![])),
Assign(Continue, Label(&quot;print-result&quot;.into())),
Goto(Reg(Val)),
</pre></div>

<p>Now we can use the following procedure to compile a procedure definition,
execute the compiled code, and run the read-eval-print loop so we can try the
procedure.  Because we want the compiled code to return to the location in
<code class="code">continue</code> with its result in <code class="code">val</code>, we compile the expression with a
target of <code class="code">val</code> and a linkage of <code class="code">return</code>.  In order to transform the
object code produced by the compiler into executable instructions for the
evaluator register machine, we use the procedure <code class="code">assemble</code> from the
register-machine simulator (<a class="ref" href="5_002e2.xhtml#g_t5_002e2_002e2">The Assembler</a>).
</p>
<div class="example">
<pre class="example-preformatted">fn compile_and_go(expression: &amp;Expr, machine: &amp;mut EvaluatorMachine) {
    let seq = compile(expression, Register::Val, &amp;Linkage::Return);
    // In our Rust implementation, we compile directly to ResolvedInst
    let instructions = assemble(seq.statements, ...);
    
    println!(&quot;Compiled {} instructions&quot;, instructions.len());
}
</pre></div>

<p>If we have set up stack monitoring, as at the end of <a class="ref" href="5_002e4.xhtml#g_t5_002e4_002e4">Running the Evaluator</a>, we
can examine the stack usage of compiled code:
</p>
<div class="example">
<pre class="example-preformatted">// Compiling factorial
let expr = Expr::Definition {
    var: &quot;factorial&quot;.into(),
    value: Box::new(Expr::Lambda { ... })
};
compile_and_go(&amp;expr, &amp;mut machine);

// (total-pushes = 0, maximum-depth = 0)

<i class="i">;;; EC-Eval input:</i>
(factorial 5)
<i class="i">(total-pushes = 31, maximum-depth = 14)</i>

<i class="i">;;; EC-Eval value:</i>
<i class="i">120</i>
</pre></div>

<p>Compare this example with the evaluation of <code class="code">(factorial 5)</code> using the
interpreted version of the same procedure, shown at the end of 
<a class="ref" href="5_002e4.xhtml#g_t5_002e4_002e4">Running the Evaluator</a>.  The interpreted version required 144 pushes and a maximum stack
depth of 28.  This illustrates the optimization that results from our
compilation strategy.
</p>
<h4 class="subsubheading" id="Interpretation-and-compilation"><span>Interpretation and compilation<a class="copiable-link" href="#Interpretation-and-compilation"> &para;</a></span></h4>

<p>With the programs in this section, we can now experiment with the alternative
execution strategies of interpretation and compilation.<a class="footnote" id="DOCF309" href="#FOOT309"><sup>309</sup></a>  An interpreter raises the machine to
the level of the user program; a compiler lowers the user program to the level
of the machine language.  We can regard the Scheme language (or any programming
language) as a coherent family of abstractions erected on the machine language.
Interpreters are good for interactive program development and debugging because
the steps of program execution are organized in terms of these abstractions,
and are therefore more intelligible to the programmer.  Compiled code can
execute faster, because the steps of program execution are organized in terms
of the machine language, and the compiler is free to make optimizations that
cut across the higher-level abstractions.<a class="footnote" id="DOCF310" href="#FOOT310"><sup>310</sup></a>
</p>
<p>The alternatives of interpretation and compilation also lead to different
strategies for porting languages to new computers. Suppose that we wish to
implement Lisp for a new machine.  One strategy is to begin with the
explicit-control evaluator of <a class="ref" href="5_002e4.xhtml#g_t5_002e4">The Explicit-Control Evaluator</a> and translate its instructions
to instructions for the new machine.  A different strategy is to begin with the
compiler and change the code generators so that they generate code for the new
machine.  The second strategy allows us to run any Lisp program on the new
machine by first compiling it with the compiler running on our original Lisp
system, and linking it with a compiled version of the run-time
library.<a class="footnote" id="DOCF311" href="#FOOT311"><sup>311</sup></a> Better yet, we can
compile the compiler itself, and run this on the new machine to compile other
Lisp programs.<a class="footnote" id="DOCF312" href="#FOOT312"><sup>312</sup></a>  Or we can compile one of the interpreters of 
<a class="ref" href="4_002e1.xhtml#g_t4_002e1">The Metacircular Evaluator</a> to produce an interpreter that runs on the new machine.
</p>
<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-5_002e45"></a>Exercise 5.45:</strong> By comparing the stack operations
used by compiled code to the stack operations used by the evaluator for the
same computation, we can determine the extent to which the compiler optimizes
use of the stack, both in speed (reducing the total number of stack operations)
and in space (reducing the maximum stack depth).  Comparing this optimized
stack use to the performance of a special-purpose machine for the same
computation gives some indication of the quality of the compiler.
</p>
<ol class="enumerate" type="a" start="1">
<li> <a class="ref" href="5_002e4.xhtml#Exercise-5_002e27">Exercise 5.27</a> asked you to determine, as a function of <em class="math">n</em>, the number
of pushes and the maximum stack depth needed by the evaluator to compute <em class="math">{n!}</em>
using the recursive factorial procedure given above.  <a class="ref" href="5_002e2.xhtml#Exercise-5_002e14">Exercise 5.14</a> asked
you to do the same measurements for the special-purpose factorial machine shown
in <a class="ref" href="5_002e1.xhtml#Figure-5_002e11">Figure 5.11</a>. Now perform the same analysis using the compiled
<code class="code">factorial</code> procedure.

<p>Take the ratio of the number of pushes in the compiled version to the number of
pushes in the interpreted version, and do the same for the maximum stack depth.
Since the number of operations and the stack depth used to compute <em class="math">{n!}</em>  are
linear in <em class="math">n</em>, these ratios should approach constants as <em class="math">n</em> becomes large.
What are these constants?  Similarly, find the ratios of the stack usage in the
special-purpose machine to the usage in the interpreted version.
</p>
<p>Compare the ratios for special-purpose versus interpreted code to the ratios
for compiled versus interpreted code.  You should find that the special-purpose
machine does much better than the compiled code, since the hand-tailored
controller code should be much better than what is produced by our rudimentary
general-purpose compiler.
</p>
</li><li> Can you suggest improvements to the compiler that would help it generate code
that would come closer in performance to the hand-tailored version?

</li></ol>
</blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-5_002e46"></a>Exercise 5.46:</strong> Carry out an analysis like the
one in <a class="ref" href="#Exercise-5_002e45">Exercise 5.45</a> to determine the effectiveness of compiling the
tree-recursive Fibonacci procedure
</p>
<div class="example">
<pre class="example-preformatted">fn fib(n: u64) -&gt; u64 {
    if n &lt; 2 { n } else { fib(n - 1) + fib(n - 2) }
}
</pre></div>

<p>compared to the effectiveness of using the special-purpose Fibonacci machine of
<a class="ref" href="5_002e1.xhtml#Figure-5_002e12">Figure 5.12</a>.  (For measurement of the interpreted performance, see
<a class="ref" href="5_002e4.xhtml#Exercise-5_002e29">Exercise 5.29</a>.)  For Fibonacci, the time resource used is not linear in
<em class="math">{n;}</em> hence the ratios of stack operations will not approach a limiting value
that is independent of <em class="math">n</em>.
</p></blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-5_002e47"></a>Exercise 5.47:</strong> This section described how to
modify the explicit-control evaluator so that interpreted code can call
compiled procedures.  Show how to modify the compiler so that compiled
procedures can call not only primitive procedures and compiled procedures, but
interpreted procedures as well.  This requires modifying
<code class="code">compile_procedure_call</code> to handle the case of compound (interpreted)
procedures.  Be sure to handle all the same <code class="code">target</code> and <code class="code">linkage</code>
combinations as in <code class="code">compile_proc_appl</code>.  To do the actual procedure
application, the code needs to jump to the evaluator&rsquo;s <code class="code">compound_apply</code>
entry point.  This label cannot be directly referenced in object code (since
the assembler requires that all labels referenced by the code it is assembling
be defined there), so we will add a register called <code class="code">compapp</code> to the
evaluator machine to hold this entry point, and add an instruction to
initialize it:
</p>
<div class="example">
<pre class="example-preformatted">Assign(&quot;compapp&quot;.into(), Label(&quot;compound-apply&quot;.into())),
// branches if flag is set:
Branch(&quot;external-entry&quot;.into()),
Label(&quot;read-eval-print-loop&quot;.into()),
// ...
</pre></div>

<p>To test your code, start by defining a procedure <code class="code">f</code> that calls a
procedure <code class="code">g</code>.  Use <code class="code">compile_and_go</code> to compile the definition of
<code class="code">f</code> and start the evaluator.  Now, typing at the evaluator, define
<code class="code">g</code> and try to call <code class="code">f</code>.
</p></blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-5_002e48"></a>Exercise 5.48:</strong> The <code class="code">compile_and_go</code>
interface implemented in this section is awkward, since the compiler can be
called only once (when the evaluator machine is started).  Augment the
compiler-interpreter interface by providing a <code class="code">compile_and_run</code> primitive
that can be called from within the explicit-control evaluator as follows:
</p>
<div class="example">
<pre class="example-preformatted"><i class="i">;;; EC-Eval input:</i>
compile_and_run(&quot;
fn factorial(n) {
    if n == 1 { 1 } else { factorial(n - 1) * n }
}
&quot;)

<i class="i">;;; EC-Eval value:</i>
<i class="i">ok</i>

<i class="i">;;; EC-Eval input:</i>
factorial(5)

<i class="i">;;; EC-Eval value:</i>
<i class="i">120</i>
</pre></div>
</blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-5_002e49"></a>Exercise 5.49:</strong> As an alternative to using the
explicit-control evaluator&rsquo;s read-eval-print loop, design a register machine
that performs a read-compile-execute-print loop.  That is, the machine should
run a loop that reads an expression, compiles it, assembles and executes the
resulting code, and prints the result.  This is easy to run in our simulated
setup, since we can arrange to call the procedures <code class="code">compile</code> and
<code class="code">assemble</code> as &ldquo;register-machine operations.&rdquo;
</p></blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-5_002e50"></a>Exercise 5.50:</strong> Use the compiler to compile the
metacircular evaluator of <a class="ref" href="4_002e1.xhtml#g_t4_002e1">The Metacircular Evaluator</a> and run this program using the
register-machine simulator.  (To compile more than one definition at a time,
you can package the definitions in a <code class="code">begin</code>.)  The resulting interpreter
will run very slowly because of the multiple levels of interpretation, but
getting all the details to work is an instructive exercise.
</p></blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-5_002e51"></a>Exercise 5.51:</strong> Develop a rudimentary
implementation of Scheme in C (or some other low-level language of your choice)
by translating the explicit-control evaluator of <a class="ref" href="5_002e4.xhtml#g_t5_002e4">The Explicit-Control Evaluator</a> into C.  In
order to run this code you will need to also provide appropriate
storage-allocation routines and other run-time support.
</p></blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-5_002e52"></a>Exercise 5.52:</strong> As a counterpoint to 
<a class="ref" href="#Exercise-5_002e51">Exercise 5.51</a>, modify the compiler so that it compiles Scheme procedures
into sequences of C instructions.  Compile the metacircular evaluator of
<a class="ref" href="4_002e1.xhtml#g_t4_002e1">The Metacircular Evaluator</a> to produce a Scheme interpreter written in C.
</p></blockquote>

</div>
</div>
<div class="footnotes-segment">
<hr>
<h4 class="footnotes-heading">Footnotes</h4>

<h5 class="footnote-body-heading"><a id="FOOT293" href="#DOCF293">(293)</a></h5>
<p>This is a theoretical statement.  We are not claiming that
the evaluator&rsquo;s data paths are a particularly convenient or efficient set of
data paths for a general-purpose computer.  For example, they are not very good
for implementing high-performance floating-point calculations or calculations
that intensively manipulate bit vectors.</p>
<h5 class="footnote-body-heading"><a id="FOOT294" href="#DOCF294">(294)</a></h5>
<p>Actually, the machine that runs compiled code can be simpler
than the interpreter machine, because we won&rsquo;t use the <code class="code">exp</code> and
<code class="code">unev</code> registers.  The interpreter used these to hold pieces of
unevaluated expressions.  With the compiler, however, these expressions get
built into the compiled code that the register machine will run.  For the same
reason, we don&rsquo;t need the machine operations that deal with expression syntax.
But compiled code will use a few additional machine operations (to represent
compiled procedure objects) that didn&rsquo;t appear in the explicit-control
evaluator machine.</p>
<h5 class="footnote-body-heading"><a id="FOOT295" href="#DOCF295">(295)</a></h5>
<p>Notice, however, that our compiler is a Scheme
program, and the syntax procedures that it uses to manipulate expressions are
the actual Scheme procedures used with the metacircular evaluator.  For the
explicit-control evaluator, in contrast, we assumed that equivalent syntax
operations were available as operations for the register machine.  (Of course,
when we simulated the register machine in Scheme, we used the actual Scheme
procedures in our register machine simulation.)</p>
<h5 class="footnote-body-heading"><a id="FOOT296" href="#DOCF296">(296)</a></h5>
<p>This procedure
uses a feature of Lisp called <a class="index-entry-id" id="index-backquote"></a>
<em class="dfn">backquote</em> (or <a class="index-entry-id" id="index-quasiquote"></a>
<em class="dfn">quasiquote</em>)
that is handy for constructing lists.  Preceding a list with a backquote symbol
is much like quoting it, except that anything in the list that is flagged with
a comma is evaluated.
</p>
<p>For example, if the value of <code class="code">linkage</code> is the symbol <code class="code">branch25</code>,
then the expression 
</p>
<div class="example lisp">
<pre class="lisp-preformatted">`((goto (label ,linkage)))
</pre></div>

<p>evaluates to the list 
</p>	
<div class="example lisp">
<pre class="lisp-preformatted">((goto (label branch25))) 
</pre></div>

<p>Similarly, if the value of <code class="code">x</code> is the list <code class="code">(a b c)</code>, then 
</p>
<div class="example lisp">
<pre class="lisp-preformatted">`(1 2 ,(car x)) 
</pre></div>

<p>evaluates to the list 
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(1 2 a)
</pre></div>
<h5 class="footnote-body-heading"><a id="FOOT297" href="#DOCF297">(297)</a></h5>
<p>We can&rsquo;t just use the labels <code class="code">true_branch</code>,
<code class="code">false_branch</code>, and <code class="code">after_if</code> as shown above, because there might be
more than one <code class="code">if</code> in the program.  The compiler uses the procedure
<code class="code">make_label</code> to generate labels.  <code class="code">Make-label</code> takes a symbol as
argument and returns a new symbol that begins with the given symbol.  For
example, successive calls to <code class="code">(make_label 'a)</code> would return <code class="code">a1</code>,
<code class="code">a2</code>, and so on.  <code class="code">Make-label</code> can be implemented similarly to the
generation of unique variable names in the query language, as follows:
</p>
<div class="example">
<pre class="example-preformatted">use std::sync::atomic::{AtomicUsize, Ordering};

static LABEL_COUNTER: AtomicUsize = AtomicUsize::new(0);

fn new_label_number() -&gt; usize {
    LABEL_COUNTER.fetch_add(1, Ordering::SeqCst)
}

fn make_label(name: &amp;str) -&gt; String {
    format!(&quot;{}-{}&quot;, name, new_label_number())
}
</pre></div>
<h5 class="footnote-body-heading"><a id="FOOT298" href="#DOCF298">(298)</a></h5>
<a class="anchor" id="Footnote-323"></a><p>We need
machine operations to implement a data structure for representing compiled
procedures, analogous to the structure for compound procedures described in
<a class="ref" href="4_002e1.xhtml#g_t4_002e1_002e3">Evaluator Data Structures</a>:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">// In Rust, the `Value::Procedure` variant (or `CompiledProcedure` struct)
// holds the entry point and environment.
// See `Value` enum definition in section 5.2.
</pre></div>
<h5 class="footnote-body-heading"><a id="FOOT299" href="#DOCF299">(299)</a></h5>
<p>Actually, we signal an error when the target is not
<code class="code">val</code> and the linkage is <code class="code">return</code>, since the only place we request
<code class="code">return</code> linkages is in compiling procedures, and our convention is that
procedures return their values in <code class="code">val</code>.</p>
<h5 class="footnote-body-heading"><a id="FOOT300" href="#DOCF300">(300)</a></h5>
<p>Making a compiler generate tail-recursive code might seem like
a straightforward idea.  But most compilers for common languages, including C
and Pascal, do not do this, and therefore these languages cannot represent
iterative processes in terms of procedure call alone.  The difficulty with tail
recursion in these languages is that their implementations use the stack to
store procedure arguments and local variables as well as return addresses.  The
Scheme implementations described in this book store arguments and variables in
memory to be garbage-collected.  The reason for using the stack for variables
and arguments is that it avoids the need for garbage collection in languages
that would not otherwise require it, and is generally believed to be more
efficient.  Sophisticated Lisp compilers can, in fact, use the stack for
arguments without destroying tail recursion.  (See <a class="ref" href="References.xhtml#Hanson-1990">Hanson 1990</a> for a
description.)  There is also some debate about whether stack allocation is
actually more efficient than garbage collection in the first place, but the
details seem to hinge on fine points of computer architecture.  (See <a class="ref" href="References.xhtml#Appel-1987">Appel 1987</a>
and <a class="ref" href="References.xhtml#Miller-and-Rozas-1994">Miller and Rozas 1994</a> for opposing views on this issue.)</p>
<h5 class="footnote-body-heading"><a id="FOOT301" href="#DOCF301">(301)</a></h5>
<p>The
variable <code class="code">all_regs</code> is bound to the list of names of all the registers:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">pub const ALL_REGS: &amp;[Register] = &amp;[
    Register::Env,
    Register::Proc,
    Register::Val,
    Register::Argl,
    Register::Continue,
];
</pre></div>
<h5 class="footnote-body-heading"><a id="FOOT302" href="#DOCF302">(302)</a></h5>
<p>Note that <code class="code">preserving</code> calls
<code class="code">append</code> with three arguments.  Though the definition of <code class="code">append</code>
shown in this book accepts only two arguments, Scheme standardly provides an
<code class="code">append</code> procedure that takes an arbitrary number of arguments.</p>
<h5 class="footnote-body-heading"><a id="FOOT303" href="#DOCF303">(303)</a></h5>
<p>We have used the same symbol
<code class="code">+</code> here to denote both the source-language procedure and the machine
operation.  In general there will not be a one-to-one correspondence between
primitives of the source language and primitives of the machine.</p>
<h5 class="footnote-body-heading"><a id="FOOT304" href="#DOCF304">(304)</a></h5>
<p>Making the primitives into reserved words is in general a
bad idea, since a user cannot then rebind these names to different procedures.
Moreover, if we add reserved words to a compiler that is in use, existing
programs that define procedures with these names will stop working.  See
<a class="ref" href="#Exercise-5_002e44">Exercise 5.44</a> for ideas on how to avoid this problem.</p>
<h5 class="footnote-body-heading"><a id="FOOT305" href="#DOCF305">(305)</a></h5>
<p>This is not true if we allow internal
definitions, unless we scan them out.  See <a class="ref" href="#Exercise-5_002e43">Exercise 5.43</a>.  </p>
<h5 class="footnote-body-heading"><a id="FOOT306" href="#DOCF306">(306)</a></h5>
<p>This is the modification
to variable lookup required if we implement the scanning method to eliminate
internal definitions (<a class="ref" href="#Exercise-5_002e43">Exercise 5.43</a>).  We will need to eliminate these
definitions in order for lexical addressing to work.</p>
<h5 class="footnote-body-heading"><a id="FOOT307" href="#DOCF307">(307)</a></h5>
<p>Lexical addresses cannot be used to
access variables in the global environment, because these names can be defined
and redefined interactively at any time.  With internal definitions scanned
out, as in <a class="ref" href="#Exercise-5_002e43">Exercise 5.43</a>, the only definitions the compiler sees are
those at top level, which act on the global environment.  Compilation of a
definition does not cause the defined name to be entered in the compile-time
environment.</p>
<h5 class="footnote-body-heading"><a id="FOOT308" href="#DOCF308">(308)</a></h5>
<p>Of course,
compiled procedures as well as interpreted procedures are compound
(nonprimitive).  For compatibility with the terminology used in the
explicit-control evaluator, in this section we will use &ldquo;compound&rdquo; to mean
interpreted (as opposed to compiled).</p>
<h5 class="footnote-body-heading"><a id="FOOT309" href="#DOCF309">(309)</a></h5>
<p>We can do even
better by extending the compiler to allow compiled code to call interpreted
procedures.  See <a class="ref" href="#Exercise-5_002e47">Exercise 5.47</a>.</p>
<h5 class="footnote-body-heading"><a id="FOOT310" href="#DOCF310">(310)</a></h5>
<p>Independent of the strategy
of execution, we incur significant overhead if we insist that errors
encountered in execution of a user program be detected and signaled, rather
than being allowed to kill the system or produce wrong answers.  For example,
an out-of-bounds array reference can be detected by checking the validity of
the reference before performing it.  The overhead of checking, however, can be
many times the cost of the array reference itself, and a programmer should
weigh speed against safety in determining whether such a check is desirable.  A
good compiler should be able to produce code with such checks, should avoid
redundant checks, and should allow programmers to control the extent and type
of error checking in the compiled code.
</p>
<p>Compilers for popular languages, such as C and C++, put hardly any
error-checking operations into running code, so as to make things run as fast
as possible.  As a result, it falls to programmers to explicitly provide error
checking.  Unfortunately, people often neglect to do this, even in critical
applications where speed is not a constraint.  Their programs lead fast and
dangerous lives.  For example, the notorious &ldquo;Worm&rdquo; that paralyzed the
Internet in 1988 exploited the <abbr class="abbr">UNIX</abbr>(tm) operating system&rsquo;s failure to
check whether the input buffer has overflowed in the finger daemon. (See
<a class="ref" href="References.xhtml#Spafford-1989">Spafford 1989</a>.)</p>
<h5 class="footnote-body-heading"><a id="FOOT311" href="#DOCF311">(311)</a></h5>
<p>Of course, with either the interpretation or the compilation
strategy we must also implement for the new machine storage allocation, input
and output, and all the various operations that we took as &ldquo;primitive&rdquo; in our
discussion of the evaluator and compiler.  One strategy for minimizing work
here is to write as many of these operations as possible in Lisp and then
compile them for the new machine.  Ultimately, everything reduces to a small
kernel (such as garbage collection and the mechanism for applying actual
machine primitives) that is hand-coded for the new machine.</p>
<h5 class="footnote-body-heading"><a id="FOOT312" href="#DOCF312">(312)</a></h5>
<p>This strategy leads to amusing tests of correctness of
the compiler, such as checking whether the compilation of a program on the new
machine, using the compiled compiler, is identical with the compilation of the
program on the original Lisp system.  Tracking down the source of differences
is fun but often frustrating, because the results are extremely sensitive to
minuscule details.</p>
</div>
<hr>
<div class="nav-panel">
<p>
Next: <a href="References.xhtml" accesskey="n" rel="next">References</a>, Previous: <a href="5_002e4.xhtml#g_t5_002e4" accesskey="p" rel="prev">The Explicit-Control Evaluator</a>, Up: <a href="Chapter-5.xhtml" accesskey="u" rel="up">Computing with Register Machines</a> &nbsp; [<a href="index.xhtml#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Term-Index.xhtml" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
