<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<!-- Created by GNU Texinfo 7.1, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Chapter 2 (Structure and Interpretation of Computer Programs, 2e)</title>

<meta name="description" content="Chapter 2 (Structure and Interpretation of Computer Programs, 2e)" />
<meta name="keywords" content="Chapter 2 (Structure and Interpretation of Computer Programs, 2e)" />
<meta name="resource-type" content="document" />
<meta name="distribution" content="global" />
<meta name="Generator" content="texi2any" />
<meta name="viewport" content="width=device-width,initial-scale=1" />

<link href="index.xhtml" rel="start" title="Top" />
<link href="Term-Index.xhtml" rel="index" title="Term Index" />
<link href="index.xhtml#SEC_Contents" rel="contents" title="Table of Contents" />
<link href="index.xhtml" rel="up" title="Top" />
<link href="2_002e1.xhtml#g_t2_002e1" rel="next" title="2.1" />
<link href="1_002e3.xhtml#g_t1_002e3_002e5" rel="prev" title="1.3.5" />
<style type="text/css">
<!--
a.copiable-link {visibility: hidden; text-decoration: none; line-height: 0em}
div.example {margin-left: 3.2em}
span:hover a.copiable-link {visibility: visible}
-->
</style>
<link href="css/style.css" rel="stylesheet" type="text/css" />
<link href="css/prettify.css" rel="stylesheet" type="text/css" />
<script src="js/highlight/prettify.js" type="text/javascript"></script>
<script src="js/highlight/lang-lisp.js" type="text/javascript"></script>
<script src="js/highlight/lang-rust.js" type="text/javascript"></script>
</head>

<body lang="en">
<div class="chapter-level-extent" id="Chapter-2">
<div class="nav-panel">
<p>
Next: <a href="2_002e1.xhtml#g_t2_002e1" accesskey="n" rel="next">Introduction to Data Abstraction</a>, Previous: <a href="1_002e3.xhtml#g_t1_002e3_002e5" accesskey="p" rel="prev">Iterator Combinators</a>, Up: <a href="index.xhtml" accesskey="u" rel="up">Top</a> &#160; [<a href="index.xhtml#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Term-Index.xhtml" title="Index" rel="index">Index</a>]</p>
</div>
<h2 class="chapter" id="Building-Abstractions-with-Data"><span>2 Building Abstractions with Data<a class="copiable-link" href="#Building-Abstractions-with-Data"> &#182;</a></span></h2>

<blockquote class="quotation">
<p>We now come to the decisive step of mathematical abstraction: we forget about
what the symbols stand for. &#8230; [The mathematician] need not be idle; there
are many operations which he may carry out with these symbols, without ever
having to look at the things they stand for.
</p>
<p>&#8212;Hermann Weyl, <cite class="cite">The Mathematical Way of Thinking</cite>
</p></blockquote>


<p>We concentrated in <a class="ref" href="Chapter-1.xhtml">Building Abstractions with Procedures</a> on computational processes and on the role
of procedures in program design.  We saw how to use primitive data (numbers)
and primitive operations (arithmetic operations), how to combine procedures to
form compound procedures through composition, conditionals, and the use of
parameters, and how to abstract procedures by using definition.  We saw that
a procedure can be regarded as a pattern for the local evolution of a process,
and we classified, reasoned about, and performed simple algorithmic analyses of
some common patterns for processes as embodied in procedures.  We also saw that
higher-order procedures enhance the power of our language by enabling us to
manipulate, and thereby to reason in terms of, general methods of computation.
This is much of the essence of programming.
</p>
<p>In this chapter we are going to look at more complex data.  All the procedures
in chapter 1 operate on simple numerical data, and simple data are not
sufficient for many of the problems we wish to address using computation.
Programs are typically designed to model complex phenomena, and more often than
not one must construct computational objects that have several parts in order
to model real-world phenomena that have several aspects.  Thus, whereas our
focus in chapter 1 was on building abstractions by combining procedures
to form compound procedures, we turn in this chapter to another key aspect of
any programming language: the means it provides for building abstractions by
combining data objects to form <a class="index-entry-id" id="index-compound-data"></a>
<em class="dfn">compound data</em>.
</p>
<p>Why do we want compound data in a programming language?  For the same reasons
that we want compound procedures: to elevate the conceptual level at which we
can design our programs, to increase the modularity of our designs, and to
enhance the expressive power of our language.  Just as the ability to define
procedures enables us to deal with processes at a higher conceptual level than
that of the primitive operations of the language, the ability to construct
compound data objects enables us to deal with data at a higher conceptual level
than that of the primitive data objects of the language.
</p>
<p>Consider the task of designing a system to perform arithmetic with rational
numbers.  We could imagine an operation <code class="code">add_rat</code> that takes two rational
numbers and produces their sum.  In terms of simple data, a rational number can
be thought of as two integers: a numerator and a denominator.  Thus, we could
design a program in which each rational number would be represented by two
integers (a numerator and a denominator) and where <code class="code">add_rat</code> would be
implemented by two procedures (one producing the numerator of the sum and one
producing the denominator).  But this would be awkward, because we would then
need to explicitly keep track of which numerators corresponded to which
denominators.  In a system intended to perform many operations on many rational
numbers, such bookkeeping details would clutter the programs substantially, to
say nothing of what they would do to our minds.  It would be much better if we
could &#8220;glue together&#8221; a numerator and denominator to form a pair&#8212;a
<a class="index-entry-id" id="index-compound-data-object"></a>
<em class="dfn">compound data object</em>&#8212;that our programs could manipulate in a way
that would be consistent with regarding a rational number as a single
conceptual unit.
</p>
<p>The use of compound data also enables us to increase the modularity of our
programs.  If we can manipulate rational numbers directly as objects in their
own right, then we can separate the part of our program that deals with
rational numbers per se from the details of how rational numbers may be
represented as pairs of integers.  The general technique of isolating the parts
of a program that deal with how data objects are represented from the parts of
a program that deal with how data objects are used is a powerful design
methodology called <a class="index-entry-id" id="index-data-abstraction"></a>
<em class="dfn">data abstraction</em>.  We will see how data
abstraction makes programs much easier to design, maintain, and modify.
</p>
<p>The use of compound data leads to a real increase in the expressive
power of our programming language.  Consider the idea of forming a
&#8220;linear combination&#8221; <em class="math">{ax + by}</em>.  We might like to write
a procedure that would accept <em class="math">a</em>, <em class="math">b</em>, <em class="math">x</em>, and <em class="math">y</em> as
arguments and return the value of <em class="math">{ax + by}</em>.  This
presents no difficulty if the arguments are to be numbers, because we
can readily define the function
</p>
<div class="example">
<pre class="example-preformatted">fn linear_combination(a: i64, b: i64, x: i64, y: i64) -&gt; i64 {
    a * x + b * y
}
</pre></div>

<p>But suppose we are not concerned only with numbers.  Suppose we would like to
express, in procedural terms, the idea that one can form linear combinations
whenever addition and multiplication are defined&#8212;for rational numbers,
complex numbers, polynomials, or whatever.  We could express this as a
function using trait bounds:
</p>
<div class="example">
<pre class="example-preformatted">use std::ops::{Add, Mul};

fn linear_combination&lt;T&gt;(a: T, b: T, x: T, y: T) -&gt; T
where
    T: Add&lt;Output = T&gt; + Mul&lt;Output = T&gt; + Copy,
{
    a * x + b * y
}
</pre></div>

<p>Here, the trait bounds <code class="code">Add&lt;Output = T&gt; + Mul&lt;Output = T&gt;</code> specify that
<code class="code">T</code> must support addition and multiplication operations. The key point is
that <code class="code">linear_combination</code> only needs to know that <code class="code">T</code> implements
these traits&#8212;the function works for any type that does, whether integers,
floating-point numbers, rational numbers, complex numbers, or polynomials.
From the perspective of the function, it is irrelevant what <code class="code">a</code>, <code class="code">b</code>,
<code class="code">x</code>, and <code class="code">y</code> are and even more irrelevant how they might happen to be
represented in terms of more primitive data.  This same example shows why it is
important that our programming language provide the ability to manipulate
compound objects directly: Without this, there is no way for a function such
as <code class="code">linear_combination</code> to work generically over different types.<a class="footnote" id="DOCF62" href="#FOOT62"><sup>62</sup></a>
</p>
<p>We begin this chapter by implementing the rational-number arithmetic system
mentioned above.  This will form the background for our discussion of compound
data and data abstraction.  As with compound procedures, the main issue to be
addressed is that of abstraction as a technique for coping with complexity, and
we will see how data abstraction enables us to erect suitable
<a class="index-entry-id" id="index-abstraction-barriers"></a>
<em class="dfn">abstraction barriers</em> between different parts of a program.
</p>
<p>We will see that the key to forming compound data is that a programming
language should provide some kind of &#8220;glue&#8221; so that data objects can be
combined to form more complex data objects.  There are many possible kinds of
glue.  Indeed, we will discover how to form compound data using no special
&#8220;data&#8221; operations at all, only procedures.  This will further blur the
distinction between &#8220;procedure&#8221; and &#8220;data,&#8221; which was already becoming
tenuous toward the end of chapter 1.  We will also explore some
conventional techniques for representing sequences and trees.  One key idea in
dealing with compound data is the notion of <a class="index-entry-id" id="index-closure-1"></a>
<em class="dfn">closure</em>&#8212;that the glue
we use for combining data objects should allow us to combine not only primitive
data objects, but compound data objects as well.  Another key idea is that
compound data objects can serve as <a class="index-entry-id" id="index-conventional-interfaces"></a>
<em class="dfn">conventional interfaces</em> for
combining program modules in mix-and-match ways.  We illustrate some of these
ideas by presenting a simple graphics language that exploits closure.
</p>
<p>We will then augment the representational power of our language by introducing
<a class="index-entry-id" id="index-symbolic-expressions"></a>
<em class="dfn">symbolic expressions</em>&#8212;data whose elementary parts can be arbitrary
symbols rather than only numbers.  We explore various alternatives for
representing sets of objects.  We will find that, just as a given numerical
function can be computed by many different computational processes, there are
many ways in which a given data structure can be represented in terms of
simpler objects, and the choice of representation can have significant impact
on the time and space requirements of processes that manipulate the data.  We
will investigate these ideas in the context of symbolic differentiation, the
representation of sets, and the encoding of information.
</p>
<p>Next we will take up the problem of working with data that may be represented
differently by different parts of a program.  This leads to the need to
implement <a class="index-entry-id" id="index-generic-operations"></a>
<em class="dfn">generic operations</em>, which must handle many different types
of data.  Maintaining modularity in the presence of generic operations requires
more powerful abstraction barriers than can be erected with simple data
abstraction alone.  In particular, we introduce <a class="index-entry-id" id="index-data_002ddirected-programming"></a>
<em class="dfn">data-directed programming</em> 
as a technique that allows individual data representations to be
designed in isolation and then combined <a class="index-entry-id" id="index-additively"></a>
<em class="dfn">additively</em> (i.e., without
modification).  To illustrate the power of this approach to system design, we
close the chapter by applying what we have learned to the implementation of a
package for performing symbolic arithmetic on polynomials, in which the
coefficients of the polynomials can be integers, rational numbers, complex
numbers, and even other polynomials.
</p>

</div>
<div class="footnotes-segment">
<hr />
<h4 class="footnotes-heading">Footnotes</h4>

<h5 class="footnote-body-heading"><a id="FOOT62" href="#DOCF62">(62)</a></h5>
<p>The
ability to directly manipulate procedures provides an analogous increase in the
expressive power of a programming language.  For example, in 
<a class="ref" href="1_002e3.xhtml#g_t1_002e3_002e1">Procedures as Arguments</a> we introduced the <code class="code">sum</code> procedure, which takes a procedure
<code class="code">term</code> as an argument and computes the sum of the values of <code class="code">term</code>
over some specified interval.  In order to define <code class="code">sum</code>, it is crucial
that we be able to speak of a procedure such as <code class="code">term</code> as an entity in its
own right, without regard for how <code class="code">term</code> might be expressed with more
primitive operations.  Indeed, if we did not have the notion of &#8220;a
procedure,&#8221; it is doubtful that we would ever even think of the possibility of
defining an operation such as <code class="code">sum</code>.  Moreover, insofar as performing the
summation is concerned, the details of how <code class="code">term</code> may be constructed from
more primitive operations are irrelevant.</p>
</div>
<hr />
<div class="nav-panel">
<p>
Next: <a href="2_002e1.xhtml#g_t2_002e1" accesskey="n" rel="next">Introduction to Data Abstraction</a>, Previous: <a href="1_002e3.xhtml#g_t1_002e3_002e5" accesskey="p" rel="prev">Iterator Combinators</a>, Up: <a href="index.xhtml" accesskey="u" rel="up">Top</a> &#160; [<a href="index.xhtml#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Term-Index.xhtml" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
