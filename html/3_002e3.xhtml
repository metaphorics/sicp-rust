<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<!-- Created by GNU Texinfo 7.1, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>3.3 (Structure and Interpretation of Computer Programs, 2e)</title>

<meta name="description" content="3.3 (Structure and Interpretation of Computer Programs, 2e)" />
<meta name="keywords" content="3.3 (Structure and Interpretation of Computer Programs, 2e)" />
<meta name="resource-type" content="document" />
<meta name="distribution" content="global" />
<meta name="Generator" content="texi2any" />
<meta name="viewport" content="width=device-width,initial-scale=1" />

<link href="index.xhtml" rel="start" title="Top" />
<link href="Term-Index.xhtml" rel="index" title="Term Index" />
<link href="index.xhtml#SEC_Contents" rel="contents" title="Table of Contents" />
<link href="Chapter-3.xhtml" rel="up" title="Chapter 3" />
<link href="3_002e4.xhtml#g_t3_002e4" rel="next" title="3.4" />
<link href="3_002e2.xhtml#g_t3_002e2" rel="prev" title="3.2" />
<style type="text/css">
<!--
a.copiable-link {visibility: hidden; text-decoration: none; line-height: 0em}
div.example {margin-left: 3.2em}
span.r {font-family: initial; font-weight: normal; font-style: normal}
span:hover a.copiable-link {visibility: visible}
ul.mark-bullet {list-style-type: disc}
-->
</style>

<script src="js/jquery.min.js" type="text/javascript"></script>
<script src="js/footnotes.js" type="text/javascript"></script>
<script src="js/browsertest.js" type="text/javascript"></script>
</head>

<body lang="en">
<div class="section-level-extent" id="g_t3_002e3">
<div class="nav-panel">
<p>
Next: <a href="3_002e4.xhtml#g_t3_002e4" accesskey="n" rel="next">Concurrency: Time Is of the Essence</a>, Previous: <a href="3_002e2.xhtml#g_t3_002e2" accesskey="p" rel="prev">The Environment Model of Evaluation</a>, Up: <a href="Chapter-3.xhtml" accesskey="u" rel="up">Modularity, Objects, and State</a> &#160; [<a href="index.xhtml#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Term-Index.xhtml" title="Index" rel="index">Index</a>]</p>
</div>
<h3 class="section" id="Modeling-with-Mutable-Data"><span>3.3 Modeling with Mutable Data<a class="copiable-link" href="#Modeling-with-Mutable-Data"> &#182;</a></span></h3>

<p><a class="ref" href="Chapter-2.xhtml">Building Abstractions with Data</a> dealt with compound data as a means for constructing computational
objects that have several parts, in order to model real-world objects that have
several aspects.  In that chapter we introduced the discipline of data
abstraction, according to which data structures are specified in terms of
constructors, which create data objects, and selectors, which access the parts
of compound data objects.  But we now know that there is another aspect of data
that chapter 2 did not address.  The desire to model systems composed of
objects that have changing state leads us to the need to modify compound data
objects, as well as to construct and select from them.  In order to model
compound objects with changing state, we will design data abstractions to
include, in addition to selectors and constructors, operations called
<a class="index-entry-id" id="index-mutators"></a>
<em class="dfn">mutators</em>, which modify data objects.  For instance, modeling a
banking system requires us to change account balances.  Thus, a data structure
for representing bank accounts might admit an operation
</p>
<div class="example">
<pre class="example-preformatted">account.balance.set(new_value);
</pre></div>

<p>that changes the balance of the designated account to the designated new value.
Data objects for which mutators are defined are known as <a class="index-entry-id" id="index-mutable-data-objects"></a>
<em class="dfn">mutable data objects</em>.
</p>
<p>Chapter 2 introduced pairs as a general-purpose &#8220;glue&#8221; for synthesizing
compound data.  We begin this section by defining basic mutators for pairs, so
that pairs can serve as building blocks for constructing mutable data objects.
These mutators greatly enhance the representational power of pairs, enabling us
to build data structures other than the sequences and trees that we worked with
in <a class="ref" href="2_002e2.xhtml#g_t2_002e2">Hierarchical Data and the Closure Property</a>.  We also present some examples of simulations in which
complex systems are modeled as collections of objects with local state.
</p>

<hr />
<div class="subsection-level-extent" id="g_t3_002e3_002e1">
<h4 class="subsection" id="Mutable-List-Structure"><span>3.3.1 Mutable List Structure<a class="copiable-link" href="#Mutable-List-Structure"> &#182;</a></span></h4>

<p>The basic operations on pairs&#8212;<code class="code">cons</code>, <code class="code">car</code>, and <code class="code">cdr</code>&#8212;can
be used to construct list structure and to select parts from list structure,
but they are incapable of modifying list structure.  The same is true of the
list operations we have used so far, such as <code class="code">append</code> and <code class="code">list</code>,
since these can be defined in terms of <code class="code">cons</code>, <code class="code">car</code>, and <code class="code">cdr</code>.
To modify list structures we need new operations.
</p>
<p>The primitive mutators for pairs are <code class="code">set_car</code> and
<code class="code">set_cdr</code>. <code class="code">Set_car</code> takes two arguments, the first of which must
be a mutable pair.  It modifies this pair, replacing the <code class="code">car</code> pointer by a
pointer to the second argument. <a class="footnote" id="DOCF137" href="#FOOT137"><sup>137</sup></a>
</p>
<p>As an example, suppose that <code class="code">x</code> is bound to the list <code class="code">((a b) c d)</code>
and <code class="code">y</code> to the list <code class="code">(e f)</code> as illustrated in <a class="ref" href="#Figure-3_002e12">Figure 3.12</a>.
Evaluating the expression <code class="code">x.set_car(y)</code> modifies the pair to which
<code class="code">x</code> is bound, replacing its <code class="code">car</code> by the value of <code class="code">y</code>.  The
result of the operation is shown in <a class="ref" href="#Figure-3_002e13">Figure 3.13</a>.  The structure <code class="code">x</code>
has been modified and would now be printed as <code class="code">((e f) c d)</code>.  The pairs
representing the list <code class="code">(a b)</code>, identified by the pointer that was
replaced, are now detached from the original structure.<a class="footnote" id="DOCF138" href="#FOOT138"><sup>138</sup></a>
</p>
<div class="float">
<a class="anchor" id="Figure-3_002e12"></a><img class="image" src="fig/chap3/Fig3.12b.std.svg" alt="fig/chap3/Fig3.12b" />
<div class="caption"><p><strong class="strong">Figure 3.12:</strong> Lists <code class="code">x</code>: <code class="code">((a b) c d)</code> and <code class="code">y</code>: <code class="code">(e f)</code>.</p></div></div>
<div class="float">
<a class="anchor" id="Figure-3_002e13"></a><img class="image" src="fig/chap3/Fig3.13b.std.svg" alt="fig/chap3/Fig3.13b" />
<div class="caption"><p><strong class="strong">Figure 3.13:</strong> Effect of <code class="code">x.set_car(y)</code> on the lists in <a class="ref" href="#Figure-3_002e12">Figure 3.12</a>.</p></div></div>
<p>Compare <a class="ref" href="#Figure-3_002e13">Figure 3.13</a> with <a class="ref" href="#Figure-3_002e14">Figure 3.14</a>, which illustrates the result
of executing <code class="code">let z = cons(y, x.cdr())</code> with <code class="code">x</code> and <code class="code">y</code>
bound to the original lists of <a class="ref" href="#Figure-3_002e12">Figure 3.12</a>.  The variable <code class="code">z</code> is now
bound to a new pair created by the <code class="code">cons</code> operation; the list to which
<code class="code">x</code> is bound is unchanged.
</p>
<div class="float">
<a class="anchor" id="Figure-3_002e14"></a><img class="image" src="fig/chap3/Fig3.14b.std.svg" alt="fig/chap3/Fig3.14b" />
<div class="caption"><p><strong class="strong">Figure 3.14:</strong> Effect of <code class="code">let z = cons(y, x.cdr())</code> on the lists in <a class="ref" href="#Figure-3_002e12">Figure 3.12</a>.</p></div></div>
<p>The <code class="code">set_cdr</code> (or similar mutator) operation is similar to <code class="code">set_car</code> (or similar mutator).  The only
difference is that the <code class="code">cdr</code> pointer of the pair, rather than the
<code class="code">car</code> pointer, is replaced.  The effect of executing <code class="code">(set-cdr! x y)</code>
on the lists of <a class="ref" href="#Figure-3_002e12">Figure 3.12</a> is shown in <a class="ref" href="#Figure-3_002e15">Figure 3.15</a>.  Here the
<code class="code">cdr</code> pointer of <code class="code">x</code> has been replaced by the pointer to <code class="code">(e
f)</code>.  Also, the list <code class="code">(c d)</code>, which used to be the <code class="code">cdr</code> of <code class="code">x</code>,
is now detached from the structure.
</p>
<div class="float">
<a class="anchor" id="Figure-3_002e15"></a><img class="image" src="fig/chap3/Fig3.15b.std.svg" alt="fig/chap3/Fig3.15b" />
<div class="caption"><p><strong class="strong">Figure 3.15:</strong> Effect of <code class="code">(set-cdr! x y)</code> on the lists in <a class="ref" href="#Figure-3_002e12">Figure 3.12</a>.</p></div></div>
<p><code class="code">Cons</code> builds new list structure by creating new pairs, while
<code class="code">set_car</code> (or similar mutator) and <code class="code">set_cdr</code> (or similar mutator) modify existing pairs.  Indeed, we could
implement <code class="code">cons</code> in terms of the two mutators, together with a procedure
<code class="code">get-new-pair</code>, which returns a new pair that is not part of any existing
list structure.  We obtain the new pair, set its <code class="code">car</code> and <code class="code">cdr</code>
pointers to the designated objects, and return the new pair as the result of
the <code class="code">cons</code>.<a class="footnote" id="DOCF139" href="#FOOT139"><sup>139</sup></a>
</p>
<div class="example">
<pre class="example-preformatted">// In Rust, tuples and structs are the natural equivalent
fn cons&lt;A, B&gt;(x: A, y: B) -&gt; (A, B) {
    (x, y)
}

// Or using a mutable pair structure:
struct Pair&lt;T&gt; {
    car: T,
    cdr: Option&lt;Box&lt;Pair&lt;T&gt;&gt;&gt;,
}
</pre></div>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-3_002e12"></a>Exercise 3.12:</strong> The following procedure for
appending lists was introduced in <a class="ref" href="2_002e2.xhtml#g_t2_002e2_002e1">Representing Sequences</a>:
</p>
<div class="example">
<pre class="example-preformatted">fn append&lt;T: Clone&gt;(x: &amp;[T], y: &amp;[T]) -&gt; Vec&lt;T&gt; {
    let mut result = x.to_vec();
    result.extend_from_slice(y);
    result
}
</pre></div>

<p><code class="code">Append</code> forms a new list by successively <code class="code">cons</code>ing the elements of
<code class="code">x</code> onto <code class="code">y</code>.  <code class="code">append_mut</code> is similar to
<code class="code">append</code>, but it is a mutator rather than a constructor.  It appends the
lists by splicing them together, modifying the final pair of <code class="code">x</code> so that
its <code class="code">cdr</code> is now <code class="code">y</code>.  (It is an error to call <code class="code">append!</code> with an
empty <code class="code">x</code>.)
</p>
<div class="example">
<pre class="example-preformatted">fn append_mut&lt;T&gt;(x: &amp;mut Vec&lt;T&gt;, y: Vec&lt;T&gt;) {
    x.extend(y);
}
</pre></div>

<p>Here <code class="code">last</code> is a method that returns the last element in a slice:
</p>
<div class="example">
<pre class="example-preformatted">fn last&lt;T&gt;(x: &amp;[T]) -&gt; Option&lt;&amp;T&gt; {
    x.last()
}
</pre></div>

<p>Consider the interaction
</p>
<div class="example">
<pre class="example-preformatted">let x = vec![&quot;a&quot;, &quot;b&quot;];
let y = vec![&quot;c&quot;, &quot;d&quot;];
let z = append(&amp;x, &amp;y);

z
// =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]

&amp;x[1..]
// ⟨response⟩  // Still [&quot;b&quot;]

let mut w = x.clone();
append_mut(&amp;mut w, y.clone());

w
// =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]

&amp;x[1..]
// ⟨response⟩  // Still [&quot;b&quot;] - x is unchanged
</pre></div>

<p>What are the missing <code class="code">⟨</code><var class="var">response</var><code class="code">⟩</code>s?  Draw box-and-pointer diagrams to
explain your answer.
</p></blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-3_002e13"></a>Exercise 3.13:</strong> Consider the following
<code class="code">make-cycle</code> procedure, which uses the <code class="code">last-pair</code> procedure defined
in <a class="ref" href="#Exercise-3_002e12">Exercise 3.12</a>:
</p>
<div class="example">
<pre class="example-preformatted">// Rust prevents cycles in owned data by design.
// To create cycles, use arena allocation or Rc&lt;RefCell&lt;T&gt;&gt;:
use std::rc::Rc;
use std::cell::RefCell;

struct Node&lt;T&gt; {
    value: T,
    next: Option&lt;Rc&lt;RefCell&lt;Node&lt;T&gt;&gt;&gt;&gt;,
}

fn make_cycle&lt;T&gt;(nodes: Vec&lt;Rc&lt;RefCell&lt;Node&lt;T&gt;&gt;&gt;&gt;) {
    if let Some(last) = nodes.last() {
        if let Some(first) = nodes.first() {
            last.borrow_mut().next = Some(Rc::clone(first));
        }
    }
}
</pre></div>

<p>Draw a box-and-pointer diagram that shows the structure <code class="code">z</code> created by
</p>
<div class="example">
<pre class="example-preformatted">// Creating a cycle in Rust requires explicit shared ownership
let a = Rc::new(RefCell::new(Node { value: &quot;a&quot;, next: None }));
let b = Rc::new(RefCell::new(Node { value: &quot;b&quot;, next: None }));
let c = Rc::new(RefCell::new(Node { value: &quot;c&quot;, next: None }));
a.borrow_mut().next = Some(Rc::clone(&amp;b));
b.borrow_mut().next = Some(Rc::clone(&amp;c));
c.borrow_mut().next = Some(Rc::clone(&amp;a)); // Creates cycle
</pre></div>

<p>What happens if we try to compute <code class="code">(last-pair z)</code>?
</p></blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-3_002e14"></a>Exercise 3.14:</strong> The following procedure is quite
useful, although obscure:
</p>
<div class="example">
<pre class="example-preformatted">// This is an in-place list reversal
fn mystery&lt;T&gt;(x: Vec&lt;T&gt;) -&gt; Vec&lt;T&gt; {
    let mut result = x;
    result.reverse();
    result
}

// For linked lists, the mutation version would be:
fn reverse_in_place&lt;T&gt;(mut x: Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt;) -&gt; Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt; {
    let mut prev = None;
    while let Some(mut node) = x {
        x = node.next.take();
        node.next = prev;
        prev = Some(node);
    }
    prev
}
</pre></div>

<p><code class="code">Loop</code> uses the &#8220;temporary&#8221; variable <code class="code">temp</code> to hold the old value
of the <code class="code">cdr</code> of <code class="code">x</code>, since the <code class="code">set_cdr</code> (or similar mutator)  on the next line
destroys the <code class="code">cdr</code>.  Explain what <code class="code">mystery</code> does in general.  Suppose
<code class="code">v</code> is defined by <code class="code">let v = list(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;);</code>. Draw the
box-and-pointer diagram that represents the list to which <code class="code">v</code> is bound.
Suppose that we now evaluate <code class="code">let w = mystery(v);</code>. Draw
box-and-pointer diagrams that show the structures <code class="code">v</code> and <code class="code">w</code> after
evaluating this expression.  What would be printed as the values of <code class="code">v</code>
and <code class="code">w</code>?
</p></blockquote>

<h4 class="subsubheading" id="Sharing-and-identity"><span>Sharing and identity<a class="copiable-link" href="#Sharing-and-identity"> &#182;</a></span></h4>

<p>We mentioned in <a class="ref" href="3_002e1.xhtml#g_t3_002e1_002e3">The Costs of Introducing Assignment</a> the theoretical issues of &#8220;sameness&#8221; and
&#8220;change&#8221; raised by the introduction of assignment.  These issues arise in
practice when individual pairs are <a class="index-entry-id" id="index-shared"></a>
<em class="dfn">shared</em> among different data
objects.  For example, consider the structure formed by
</p>
<div class="example">
<pre class="example-preformatted">let x = vec![&quot;a&quot;, &quot;b&quot;];
let z1 = (x.clone(), x.clone());  // In Rust, creates independent copies
// To share, use Rc:
use std::rc::Rc;
let x = Rc::new(vec![&quot;a&quot;, &quot;b&quot;]);
let z1 = (Rc::clone(&amp;x), Rc::clone(&amp;x));  // Both point to same data
</pre></div>

<p>As shown in <a class="ref" href="#Figure-3_002e16">Figure 3.16</a>, <code class="code">z1</code> is a pair whose <code class="code">car</code> and
<code class="code">cdr</code> both point to the same pair <code class="code">x</code>.  This sharing of <code class="code">x</code> by
the <code class="code">car</code> and <code class="code">cdr</code> of <code class="code">z1</code> is a consequence of the
straightforward way in which <code class="code">cons</code> is implemented.  In general, using
<code class="code">cons</code> to construct lists will result in an interlinked structure of pairs
in which many individual pairs are shared by many different structures.
</p>
<div class="float">
<a class="anchor" id="Figure-3_002e16"></a><img class="image" src="fig/chap3/Fig3.16b.std.svg" alt="fig/chap3/Fig3.16b" />
<div class="caption"><p><strong class="strong">Figure 3.16:</strong> The list <code class="code">z1</code> formed by <code class="code">(cons x x)</code>.</p></div></div>
<p>In contrast to <a class="ref" href="#Figure-3_002e16">Figure 3.16</a>, <a class="ref" href="#Figure-3_002e17">Figure 3.17</a> shows the structure created
by
</p>
<div class="example">
<pre class="example-preformatted">let z2 = (vec![&quot;a&quot;, &quot;b&quot;], vec![&quot;a&quot;, &quot;b&quot;]);  // Two distinct vectors
</pre></div>

<div class="float">
<a class="anchor" id="Figure-3_002e17"></a><img class="image" src="fig/chap3/Fig3.17b.std.svg" alt="fig/chap3/Fig3.17b" />
<div class="caption"><p><strong class="strong">Figure 3.17:</strong> The list <code class="code">z2</code> formed by <code class="code">(cons (list 'a 'b) (list 'a 'b))</code>.</p></div></div>
<p>In this structure, the pairs in the two <code class="code">(a b)</code> lists are distinct,
although the actual symbols are shared.<a class="footnote" id="DOCF140" href="#FOOT140"><sup>140</sup></a>
</p>
<p>When thought of as a list, <code class="code">z1</code> and <code class="code">z2</code> both represent &#8220;the same&#8221;
list, <code class="code">((a b) a b)</code>.  In general, sharing is completely undetectable if we
operate on lists using only <code class="code">cons</code>, <code class="code">car</code>, and <code class="code">cdr</code>.  However,
if we allow mutators on list structure, sharing becomes significant.  As an
example of the difference that sharing can make, consider the following
procedure, which modifies the <code class="code">car</code> of the structure to which it is
applied:
</p>
<div class="example">
<pre class="example-preformatted">// Using Rc&lt;RefCell&lt;Vec&lt;&amp;str&gt;&gt;&gt; to allow shared mutation
fn set_to_wow(x: &amp;(Rc&lt;RefCell&lt;Vec&lt;&amp;str&gt;&gt;&gt;, Rc&lt;RefCell&lt;Vec&lt;&amp;str&gt;&gt;&gt;)) {
    x.0.borrow_mut()[0] = &quot;wow&quot;;
}
</pre></div>

<p>Even though <code class="code">z1</code> and <code class="code">z2</code> are &#8220;the same&#8221; structure, applying
<code class="code">set-to-wow!</code> to them yields different results.  With <code class="code">z1</code>, altering
the <code class="code">car</code> also changes the <code class="code">cdr</code>, because in <code class="code">z1</code> the <code class="code">car</code>
and the <code class="code">cdr</code> are the same pair.  With <code class="code">z2</code>, the <code class="code">car</code> and
<code class="code">cdr</code> are distinct, so <code class="code">set-to-wow!</code> modifies only the <code class="code">car</code>:
</p>
<div class="example">
<pre class="example-preformatted">z1
// =&gt; ([&quot;a&quot;, &quot;b&quot;], [&quot;a&quot;, &quot;b&quot;])  -- same underlying Rc

set_to_wow(&amp;z1);
// =&gt; ([&quot;wow&quot;, &quot;b&quot;], [&quot;wow&quot;, &quot;b&quot;])  -- both changed!

z2
// =&gt; ([&quot;a&quot;, &quot;b&quot;], [&quot;a&quot;, &quot;b&quot;])  -- independent vectors

set_to_wow(&amp;z2);
// =&gt; ([&quot;wow&quot;, &quot;b&quot;], [&quot;a&quot;, &quot;b&quot;])  -- only first changed
</pre></div>

<p>One way to detect sharing in list structures is to use the predicate
<code class="code">eq?</code>, which we introduced in <a class="ref" href="2_002e3.xhtml#g_t2_002e3_002e1">Quotation</a> as a way to test whether
two symbols are equal.  More generally, <code class="code">(eq?  x y)</code> tests whether
<code class="code">x</code> and <code class="code">y</code> are the same object (that is, whether <code class="code">x</code> and
<code class="code">y</code> are equal as pointers).  Thus, with <code class="code">z1</code> and <code class="code">z2</code> as defined
in <a class="ref" href="#Figure-3_002e16">Figure 3.16</a> and <a class="ref" href="#Figure-3_002e17">Figure 3.17</a>, <code class="code">(eq?  (car z1) (cdr
z1))</code> is true and <code class="code">(eq? (car z2) (cdr z2))</code> is false.
</p>
<p>As will be seen in the following sections, we can exploit sharing to greatly
extend the repertoire of data structures that can be represented by pairs.  On
the other hand, sharing can also be dangerous, since modifications made to
structures will also affect other structures that happen to share the modified
parts.  The mutation operations <code class="code">set_car</code> (or similar mutator) and <code class="code">set_cdr</code> (or similar mutator) should be
used with care; unless we have a good understanding of how our data objects are
shared, mutation can have unanticipated results.<a class="footnote" id="DOCF141" href="#FOOT141"><sup>141</sup></a>
</p>
<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-3_002e15"></a>Exercise 3.15:</strong> Draw box-and-pointer diagrams to
explain the effect of <code class="code">set-to-wow!</code> on the structures <code class="code">z1</code> and
<code class="code">z2</code> above.
</p></blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-3_002e16"></a>Exercise 3.16:</strong> Ben Bitdiddle decides to write a
procedure to count the number of pairs in any list structure.  &#8220;It&#8217;s easy,&#8221;
he reasons.  &#8220;The number of pairs in any structure is the number in the
<code class="code">car</code> plus the number in the <code class="code">cdr</code> plus one more to count the current
pair.&#8221;  So Ben writes the following procedure:
</p>
<div class="example">
<pre class="example-preformatted">// Naive count - doesn't handle sharing correctly
fn count_pairs&lt;T&gt;(x: &amp;Node&lt;T&gt;) -&gt; usize {
    let car_count = match &amp;x.car {
        Some(node) =&gt; count_pairs(node),
        None =&gt; 0,
    };
    let cdr_count = match &amp;x.cdr {
        Some(node) =&gt; count_pairs(node),
        None =&gt; 0,
    };
    car_count + cdr_count + 1
}
</pre></div>

<p>Show that this procedure is not correct.  In particular, draw box-and-pointer
diagrams representing list structures made up of exactly three pairs for which
Ben&#8217;s procedure would return 3; return 4; return 7; never return at all.
</p></blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-3_002e17"></a>Exercise 3.17:</strong> Devise a correct version of the
<code class="code">count-pairs</code> procedure of <a class="ref" href="#Exercise-3_002e16">Exercise 3.16</a> that returns the number of
distinct pairs in any structure.  (Hint: Traverse the structure, maintaining an
auxiliary data structure that is used to keep track of which pairs have already
been counted.)
</p></blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-3_002e18"></a>Exercise 3.18:</strong> Write a procedure that examines a
list and determines whether it contains a cycle, that is, whether a program
that tried to find the end of the list by taking successive <code class="code">cdr</code>s would
go into an infinite loop.  <a class="ref" href="#Exercise-3_002e13">Exercise 3.13</a> constructed such lists.
</p></blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-3_002e19"></a>Exercise 3.19:</strong> Redo <a class="ref" href="#Exercise-3_002e18">Exercise 3.18</a> using an
algorithm that takes only a constant amount of space.  (This requires a very
clever idea.)
</p></blockquote>

<h4 class="subsubheading" id="Mutation-is-just-assignment"><span>Mutation is just assignment<a class="copiable-link" href="#Mutation-is-just-assignment"> &#182;</a></span></h4>

<p>When we introduced compound data, we observed in <a class="ref" href="2_002e1.xhtml#g_t2_002e1_002e3">What Is Meant by Data?</a> that pairs
can be represented purely in terms of procedures:
</p>
<div class="example">
<pre class="example-preformatted">// Pairs represented as closures returning enum values
enum PairOp&lt;T&gt; {
    Car,
    Cdr,
}

fn cons&lt;T: Clone&gt;(x: T, y: T) -&gt; impl Fn(PairOp&lt;T&gt;) -&gt; T {
    move |m| match m {
        PairOp::Car =&gt; x.clone(),
        PairOp::Cdr =&gt; y.clone(),
    }
}

fn car&lt;T&gt;(z: impl Fn(PairOp&lt;T&gt;) -&gt; T) -&gt; T { z(PairOp::Car) }
fn cdr&lt;T&gt;(z: impl Fn(PairOp&lt;T&gt;) -&gt; T) -&gt; T { z(PairOp::Cdr) }
</pre></div>

<p>The same observation is true for mutable data.  We can implement mutable data
objects as procedures using assignment and local state.  For instance, we can
extend the above pair implementation to handle <code class="code">set_car</code> (or similar mutator) and
<code class="code">set_cdr</code> (or similar mutator) in a manner analogous to the way we implemented bank accounts
using <code class="code">Account::new</code> in <a class="ref" href="3_002e1.xhtml#g_t3_002e1_002e1">Local State Variables</a>:
</p>
<div class="example">
<pre class="example-preformatted">// Mutable pair using Cell for interior mutability
use std::cell::Cell;

struct MutablePair&lt;T: Copy&gt; {
    car: Cell&lt;T&gt;,
    cdr: Cell&lt;T&gt;,
}

impl&lt;T: Copy&gt; MutablePair&lt;T&gt; {
    fn cons(x: T, y: T) -&gt; Self {
        MutablePair {
            car: Cell::new(x),
            cdr: Cell::new(y),
        }
    }

    fn car(&amp;self) -&gt; T { self.car.get() }
    fn cdr(&amp;self) -&gt; T { self.cdr.get() }
    fn set_car(&amp;self, v: T) { self.car.set(v); }
    fn set_cdr(&amp;self, v: T) { self.cdr.set(v); }
}
</pre></div>

<p>Assignment is all that is needed, theoretically, to account for the behavior of
mutable data.  As soon as we admit <code class="code">set!</code> to our language, we raise all
the issues, not only of assignment, but of mutable data in general.<a class="footnote" id="DOCF142" href="#FOOT142"><sup>142</sup></a>
</p>
<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-3_002e20"></a>Exercise 3.20:</strong> Draw environment diagrams to
illustrate the evaluation of the sequence of expressions
</p>
<div class="example">
<pre class="example-preformatted">let x = cons(1, 2);
let z = cons(x.clone(), x.clone());

z.cdr().set_car(17);

x.car()
<i class="i">17</i>
</pre></div>

<p>using the procedural implementation of pairs given above.  (Compare
<a class="ref" href="3_002e2.xhtml#Exercise-3_002e11">Exercise 3.11</a>.)
</p></blockquote>

<hr />
</div>
<div class="subsection-level-extent" id="g_t3_002e3_002e2">
<h4 class="subsection" id="Representing-Queues"><span>3.3.2 Representing Queues<a class="copiable-link" href="#Representing-Queues"> &#182;</a></span></h4>

<p>The mutators <code class="code">set_car</code> (or similar mutator) and <code class="code">set_cdr</code> (or similar mutator) enable us to use pairs to
construct data structures that cannot be built with <code class="code">cons</code>, <code class="code">car</code>,
and <code class="code">cdr</code> alone.  This section shows how to use pairs to represent a data
structure called a queue.  Section <a class="ref" href="#g_t3_002e3_002e3">Representing Tables</a> will show how to represent data
structures called tables.
</p>
<p>A <a class="index-entry-id" id="index-queue"></a>
<em class="dfn">queue</em> is a sequence in which items are inserted at one end (called
the <a class="index-entry-id" id="index-rear"></a>
<em class="dfn">rear</em> of the queue) and deleted from the other end (the
<a class="index-entry-id" id="index-front"></a>
<em class="dfn">front</em>).  <a class="ref" href="#Figure-3_002e18">Figure 3.18</a> shows an initially empty queue in which
the items <code class="code">a</code> and <code class="code">b</code> are inserted.  Then <code class="code">a</code> is removed,
<code class="code">c</code> and <code class="code">d</code> are inserted, and <code class="code">b</code> is removed.  Because items are
always removed in the order in which they are inserted, a queue is sometimes
called a <a class="index-entry-id" id="index-FIFO"></a>
<em class="dfn">FIFO</em> (first in, first out) buffer.
</p>
<div class="float">
<a class="anchor" id="Figure-3_002e18"></a><img class="image" src="fig/chap3/Fig3.18.std.svg" alt="fig/chap3/Fig3.18" />
<div class="caption"><p><strong class="strong">Figure 3.18:</strong> Queue operations.</p></div></div>
<p>In terms of data abstraction, we can regard a queue as defined by the following
set of operations:
</p>
<ul class="itemize mark-bullet">
<li>a constructor: <code class="code">(make-queue)</code> returns an empty queue (a queue containing
no items).

</li><li>two selectors:

<div class="example">
<pre class="example-preformatted">queue.is_empty()
</pre></div>

<p>tests if the queue is empty.
</p>
<div class="example">
<pre class="example-preformatted">queue.front()
</pre></div>

<p>returns the object at the front of the queue, signaling an error if the queue
is empty; it does not modify the queue.
</p>
</li><li>two mutators:

<div class="example">
<pre class="example-preformatted">queue.push_back(item)
</pre></div>

<p>inserts the item at the rear of the queue and returns the modified queue as its
value.
</p>
<div class="example">
<pre class="example-preformatted">queue.pop_front()
</pre></div>

<p>removes the item at the front of the queue and returns the modified queue as
its value, signaling an error if the queue is empty before the deletion.
</p>
</li></ul>

<p>Because a queue is a sequence of items, we could certainly represent it as an
ordinary list; the front of the queue would be the <code class="code">car</code> of the list,
inserting an item in the queue would amount to appending a new element at the
end of the list, and deleting an item from the queue would just be taking the
<code class="code">cdr</code> of the list.  However, this representation is inefficient, because
in order to insert an item we must scan the list until we reach the end.  Since
the only method we have for scanning a list is by successive <code class="code">cdr</code>
operations, this scanning requires <em class="math">{\Theta(n)}</em> steps for a list of <em class="math">n</em>
items.  A simple modification to the list representation overcomes this
disadvantage by allowing the queue operations to be implemented so that they
require <em class="math">{\Theta(1)}</em> steps; that is, so that the number of steps needed is
independent of the length of the queue.
</p>
<p>The difficulty with the list representation arises from the need to scan to
find the end of the list.  The reason we need to scan is that, although the
standard way of representing a list as a chain of pairs readily provides us
with a pointer to the beginning of the list, it gives us no easily accessible
pointer to the end.
</p>
<p>In Rust, the standard library provides <code class="code">std::collections::VecDeque</code>, which
efficiently handles insertions and deletions at both ends in <em class="math">{\Theta(1)}</em>
time. This replaces the need for manual pointer manipulation. However, to
understand the underlying principles, we can still represent a queue as a list, 
together with an additional pointer that indicates the final pair in the list.
</p>
<p>A queue can be represented, then, as a pair of pointers, <code class="code">front_ptr</code> and
<code class="code">rear_ptr</code>, which indicate, respectively, the first and last pairs in an
ordinary list. Since we would like the queue to be an identifiable object, we
can wrap these in a struct. <a class="ref" href="#Figure-3_002e19">Figure 3.19</a> illustrates this representation.
</p>
<div class="float">
<a class="anchor" id="Figure-3_002e19"></a><img class="image" src="fig/chap3/Fig3.19b.std.svg" alt="fig/chap3/Fig3.19b" />
<div class="caption"><p><strong class="strong">Figure 3.19:</strong> Implementation of a queue as a list with front and rear pointers.</p></div></div>
<p>To define the queue operations we use the following procedures, which enable us
to select and to modify the front and rear pointers of a queue:
</p>
<div class="example">
<pre class="example-preformatted">use std::collections::VecDeque;

// Rust's VecDeque provides efficient O(1) operations at both ends
struct Queue&lt;T&gt; {
    items: VecDeque&lt;T&gt;,
}
</pre></div>

<p>Now we can implement the actual queue operations.  We will consider a queue to
be empty if its front pointer is the empty list:
</p>
<div class="example">
<pre class="example-preformatted">fn is_empty(&amp;self) -&gt; bool {
    self.items.is_empty()
}
</pre></div>

<p>The <code class="code">Queue::new</code> constructor returns, as an initially empty queue, a pair
whose <code class="code">car</code> and <code class="code">cdr</code> are both the empty list:
</p>
<div class="example">
<pre class="example-preformatted">fn new() -&gt; Self {
    Queue { items: VecDeque::new() }
}
</pre></div>

<p>To select the item at the front of the queue, we return the <code class="code">car</code> of the
pair indicated by the front pointer:
</p>
<div class="example">
<pre class="example-preformatted">fn front(&amp;self) -&gt; Option&lt;&amp;T&gt; {
    self.items.front()
}
</pre></div>

<p>To insert an item in a queue, we follow the method whose result is indicated in
<a class="ref" href="#Figure-3_002e20">Figure 3.20</a>.  We first create a new pair whose <code class="code">car</code> is the item to
be inserted and whose <code class="code">cdr</code> is the empty list.  If the queue was initially
empty, we set the front and rear pointers of the queue to this new pair.
Otherwise, we modify the final pair in the queue to point to the new pair, and
also set the rear pointer to the new pair.
</p>
<div class="float">
<a class="anchor" id="Figure-3_002e20"></a><img class="image" src="fig/chap3/Fig3.20c.std.svg" alt="fig/chap3/Fig3.20c" />
<div class="caption"><p><strong class="strong">Figure 3.20:</strong> Result of using <code class="code">q.push_back(&quot;d&quot;)</code> on the queue of <a class="ref" href="#Figure-3_002e19">Figure 3.19</a>.</p></div></div>
<div class="example">
<pre class="example-preformatted">fn push_back(&amp;mut self, item: T) {
    self.items.push_back(item);
}
</pre></div>

<p>To delete the item at the front of the queue, we merely modify the front
pointer so that it now points at the second item in the queue, which can be
found by following the <code class="code">cdr</code> pointer of the first item (see 
<a class="ref" href="#Figure-3_002e21">Figure 3.21</a>):<a class="footnote" id="DOCF143" href="#FOOT143"><sup>143</sup></a>
</p>
<div class="example">
<pre class="example-preformatted">fn pop_front(&amp;mut self) -&gt; Option&lt;T&gt; {
    self.items.pop_front()
}
</pre></div>

<div class="float">
<a class="anchor" id="Figure-3_002e21"></a><img class="image" src="fig/chap3/Fig3.21c.std.svg" alt="fig/chap3/Fig3.21c" />
<div class="caption"><p><strong class="strong">Figure 3.21:</strong> Result of using <code class="code">q.pop_front()</code> on the queue of <a class="ref" href="#Figure-3_002e20">Figure 3.20</a>.</p></div></div>
<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-3_002e21"></a>Exercise 3.21:</strong> Ben Bitdiddle decides to test the
queue implementation described above.  He types in the procedures to the Lisp
interpreter and proceeds to try them out:
</p>
<div class="example">
<pre class="example-preformatted">let mut q1: Queue&lt;&amp;str&gt; = Queue::new();

q1.push_back(&quot;a&quot;);
// q1 = [&quot;a&quot;]

q1.push_back(&quot;b&quot;);
// q1 = [&quot;a&quot;, &quot;b&quot;]

q1.pop_front();
// =&gt; Some(&quot;a&quot;), q1 = [&quot;b&quot;]

q1.pop_front();
// =&gt; Some(&quot;b&quot;), q1 = []
</pre></div>

<p>&#8220;It&#8217;s all wrong!&#8221; he complains.  &#8220;The interpreter&#8217;s response shows that the
last item is inserted into the queue twice.  And when I delete both items, the
second <code class="code">b</code> is still there, so the queue isn&#8217;t empty, even though it&#8217;s
supposed to be.&#8221;  Eva Lu Ator suggests that Ben has misunderstood what is
happening.  &#8220;It&#8217;s not that the items are going into the queue twice,&#8221; she
explains.  &#8220;It&#8217;s just that the standard Lisp printer doesn&#8217;t know how to make
sense of the queue representation.  If you want to see the queue printed
correctly, you&#8217;ll have to define your own print procedure for queues.&#8221; Explain
what Eva Lu is talking about.  In particular, show why Ben&#8217;s examples produce
the printed results that they do.  Define a procedure <code class="code">print-queue</code> that
takes a queue as input and prints the sequence of items in the queue.
</p></blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-3_002e22"></a>Exercise 3.22:</strong> Instead of representing a queue
as a pair of pointers, we can build a queue as a procedure with local state.
The local state will consist of pointers to the beginning and the end of an
ordinary list.  Thus, the <code class="code">Queue::new</code> procedure will have the form
</p>
<div class="example">
<pre class="example-preformatted">struct Queue&lt;T&gt; {
    items: VecDeque&lt;T&gt;,
}

impl&lt;T&gt; Queue&lt;T&gt; {
    fn new() -&gt; Self { ... }
    fn push_back(&amp;mut self, item: T) { ... }
    fn pop_front(&amp;mut self) -&gt; Option&lt;T&gt; { ... }
    fn front(&amp;self) -&gt; Option&lt;&amp;T&gt; { ... }
    fn is_empty(&amp;self) -&gt; bool { ... }
}
</pre></div>

<p>Complete the definition of <code class="code">Queue::new</code> and provide implementations of the
queue operations using this representation.
</p></blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-3_002e23"></a>Exercise 3.23:</strong> A <a class="index-entry-id" id="index-deque"></a>
<em class="dfn">deque</em> (&#8220;double-ended
                                                                 queue&#8221;) is a sequence in which items can be inserted and deleted at either the
front or the rear.  Operations on deques are the constructor <code class="code">make-deque</code>,
the predicate <code class="code">empty-deque?</code>, selectors <code class="code">front-deque</code> and
<code class="code">rear-deque</code>, and mutators <code class="code">front-insert-deque!</code>,
<code class="code">rear-insert-deque!</code>, <code class="code">front-delete-deque!</code>, 
<code class="code">rear-delete-deque!</code>.  Show how to represent deques using pairs, and give
implementations of the operations.<a class="footnote" id="DOCF144" href="#FOOT144"><sup>144</sup></a>  
All operations should be accomplished in <em class="math">{\Theta(1)}</em> steps.
</p></blockquote>

<hr />
</div>
<div class="subsection-level-extent" id="g_t3_002e3_002e3">
<h4 class="subsection" id="Representing-Tables"><span>3.3.3 Representing Tables<a class="copiable-link" href="#Representing-Tables"> &#182;</a></span></h4>

<p>When we studied various ways of representing sets in <a class="ref" href="Chapter-2.xhtml">Building Abstractions with Data</a>, we
mentioned in <a class="ref" href="2_002e3.xhtml#g_t2_002e3_002e3">Example: Representing Sets</a> the task of maintaining a table of records
indexed by identifying keys.  In the implementation of data-directed
programming in <a class="ref" href="2_002e4.xhtml#g_t2_002e4_002e3">Data-Directed Programming and Additivity</a>, we made extensive use of two-dimensional
tables, in which information is stored and retrieved using two keys.  Here we
see how to build tables as mutable list structures.
</p>
<p>We first consider a one-dimensional table, in which each value is stored under
a single key.  We implement the table as a list of records, each of which is
A table can be implemented as a collection of key-value pairs. In Rust, the
<code class="code">std::collections::HashMap</code> provides an efficient implementation of a
table using a hash table. However, to understand the structure of a table,
we can also represent it as a list of records, where each record is
a pair consisting of a key and the associated value.
</p>
<h4 class="subsubheading" id="One_002ddimensional-tables"><span>One-dimensional tables<a class="copiable-link" href="#One_002ddimensional-tables"> &#182;</a></span></h4>

<p>In a one-dimensional table, each value is stored under a single key. In Rust,
we can easily perform lookups and insertions using the <code class="code">HashMap</code>:
</p>
<div class="example">
<pre class="example-preformatted">use std::collections::HashMap;

fn lookup&lt;K, V&gt;(key: &amp;K, table: &amp;HashMap&lt;K, V&gt;) -&gt; Option&lt;&amp;V&gt;
where
    K: Eq + std::hash::Hash,
{
    table.get(key)
}

fn insert&lt;K, V&gt;(key: K, value: V, table: &amp;mut HashMap&lt;K, V&gt;)
where
    K: Eq + std::hash::Hash,
{
    table.insert(key, value);
}
</pre></div>

<p>The hash map handles the underlying memory management and provides <em class="math">O(1)</em>
average time for lookups and insertions. If we were to build a table manually
using list structure, we would represent it as a <a class="index-entry-id" id="index-headed-list"></a>
<em class="dfn">headed list</em>, as shown
in <a class="ref" href="#Figure-3_002e22">Figure 3.22</a>.
</p>
<div class="float">
<a class="anchor" id="Figure-3_002e22"></a><p><strong class="strong">Figure 3.22:</strong> A table represented as a headed list.
</p></div>
<p>To construct a new table, we simply create a list containing the symbol
<code class="code">*table*</code>:
</p>
<div class="example">
<pre class="example-preformatted">fn make_table&lt;K, V&gt;() -&gt; HashMap&lt;K, V&gt; {
    HashMap::new()
}
</pre></div>

<h4 class="subsubheading" id="Two_002ddimensional-tables"><span>Two-dimensional tables<a class="copiable-link" href="#Two_002ddimensional-tables"> &#182;</a></span></h4>

<p>In a two-dimensional table, each value is indexed by two keys.  We can
construct such a table as a one-dimensional table in which each key identifies
a subtable.  <a class="ref" href="#Figure-3_002e23">Figure 3.23</a> shows the box-and-pointer diagram for the table
</p>
<div class="example">
<pre class="example-preformatted">math:  +: 43    letters:  a: 97
       -: 45              b: 98
       *: 42
</pre></div>

<p>which has two subtables.  (The subtables don&#8217;t need a special header symbol,
since the key that identifies the subtable serves this purpose.)
</p>
<div class="float">
<a class="anchor" id="Figure-3_002e23"></a><img class="image" src="fig/chap3/Fig3.23b.std.svg" alt="fig/chap3/Fig3.23b" />
<div class="caption"><p><strong class="strong">Figure 3.23:</strong> A two-dimensional table.</p></div></div>
<p>When we look up an item, we use the first key to identify the correct subtable.
Then we use the second key to identify the record within the subtable.
</p>
<div class="example">
<pre class="example-preformatted">// Two-dimensional table: HashMap&lt;K1, HashMap&lt;K2, V&gt;&gt;
fn lookup_2d&lt;K1, K2, V&gt;(
    key1: &amp;K1, key2: &amp;K2,
    table: &amp;HashMap&lt;K1, HashMap&lt;K2, V&gt;&gt;
) -&gt; Option&lt;&amp;V&gt;
where
    K1: Eq + std::hash::Hash,
    K2: Eq + std::hash::Hash,
{
    table.get(key1).and_then(|subtable| subtable.get(key2))
}
</pre></div>

<p>To insert a new item under a pair of keys, we use <code class="code">assoc</code> to see if there
is a subtable stored under the first key.  If not, we build a new subtable
containing the single record (<code class="code">key-2</code>, <code class="code">value</code>) and insert it into
the table under the first key.  If a subtable already exists for the first key,
we insert the new record into this subtable, using the insertion method for
one-dimensional tables described above:
</p>
<div class="example">
<pre class="example-preformatted">fn insert_2d&lt;K1, K2, V&gt;(
    key1: K1, key2: K2, value: V,
    table: &amp;mut HashMap&lt;K1, HashMap&lt;K2, V&gt;&gt;
)
where
    K1: Eq + std::hash::Hash,
    K2: Eq + std::hash::Hash,
{
    table.entry(key1).or_insert_with(HashMap::new).insert(key2, value);
}
</pre></div>

<h4 class="subsubheading" id="Creating-local-tables"><span>Creating local tables<a class="copiable-link" href="#Creating-local-tables"> &#182;</a></span></h4>

<p>The <code class="code">lookup</code> and <code class="code">insert</code> operations defined above take the table as
an argument.  This enables us to use programs that access more than one table.
Another way to deal with multiple tables is to have separate <code class="code">lookup</code> and
<code class="code">insert</code> procedures for each table.  We can do this by representing a
table procedurally, as an object that maintains an internal table as part of
its local state.  When sent an appropriate message, this &#8220;table object&#8221;
supplies the procedure with which to operate on the internal table.  Here is a
generator for two-dimensional tables represented in this fashion:
</p>
<div class="example">
<pre class="example-preformatted">struct Table&lt;K1, K2, V&gt;
where
    K1: Eq + std::hash::Hash,
    K2: Eq + std::hash::Hash,
{
    data: HashMap&lt;K1, HashMap&lt;K2, V&gt;&gt;,
}

impl&lt;K1, K2, V&gt; Table&lt;K1, K2, V&gt;
where
    K1: Eq + std::hash::Hash,
    K2: Eq + std::hash::Hash,
{
    fn new() -&gt; Self {
        Table { data: HashMap::new() }
    }

    fn lookup(&amp;self, key1: &amp;K1, key2: &amp;K2) -&gt; Option&lt;&amp;V&gt; {
        self.data.get(key1).and_then(|sub| sub.get(key2))
    }

    fn insert(&amp;mut self, key1: K1, key2: K2, value: V) {
        self.data.entry(key1)
            .or_insert_with(HashMap::new)
            .insert(key2, value);
    }
}
</pre></div>

<p>Using <code class="code">Table::new</code>, we could implement the <code class="code">get</code> and <code class="code">put</code>
operations used in <a class="ref" href="2_002e4.xhtml#g_t2_002e4_002e3">Data-Directed Programming and Additivity</a> for data-directed programming, as
follows:
</p>
<div class="example">
<pre class="example-preformatted">let mut operation_table: Table&lt;&amp;str, &amp;str, fn(...)&gt; = Table::new();
// Usage:
operation_table.insert(&quot;math&quot;, &quot;add&quot;, add_fn);
let op = operation_table.lookup(&amp;&quot;math&quot;, &amp;&quot;add&quot;);
</pre></div>

<p><code class="code">Get</code> takes as arguments two keys, and <code class="code">put</code> takes as arguments two
keys and a value.  Both operations access the same local table, which is
encapsulated within the object created by the call to <code class="code">Table::new</code>.
</p>
<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-3_002e24"></a>Exercise 3.24:</strong> In the table implementations
above, the keys are tested for equality using <code class="code">equal?</code> (called by
<code class="code">assoc</code>).  This is not always the appropriate test.  For instance, we
might have a table with numeric keys in which we don&#8217;t need an exact match to
the number we&#8217;re looking up, but only a number within some tolerance of it.
Design a table constructor <code class="code">Table::new</code> that takes as an argument a
<code class="code">same-key?</code> procedure that will be used to test &#8220;equality&#8221; of keys.
<code class="code">Make-table</code> should return a <code class="code">dispatch</code> procedure that can be used to
access appropriate <code class="code">lookup</code> and <code class="code">insert</code> procedures for a local
table.
</p></blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-3_002e25"></a>Exercise 3.25:</strong> Generalizing one- and
two-dimensional tables, show how to implement a table in which values are
stored under an arbitrary number of keys and different values may be stored
under different numbers of keys.  The <code class="code">lookup</code> and <code class="code">insert</code>
procedures should take as input a list of keys used to access the table.
</p></blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-3_002e26"></a>Exercise 3.26:</strong> To search a table as implemented
above, one needs to scan through the list of records.  This is basically the
unordered list representation of <a class="ref" href="2_002e3.xhtml#g_t2_002e3_002e3">Example: Representing Sets</a>.  For large tables, it may
be more efficient to structure the table in a different manner.  Describe a
table implementation where the (key, value) records are organized using a
binary tree, assuming that keys can be ordered in some way (e.g., numerically
or alphabetically).  (Compare <a class="ref" href="2_002e3.xhtml#Exercise-2_002e66">Exercise 2.66</a> of <a class="ref" href="Chapter-2.xhtml">Building Abstractions with Data</a>.)
</p></blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-3_002e27"></a>Exercise 3.27:</strong> <a class="index-entry-id" id="index-Memoization"></a>
<em class="dfn">Memoization</em> (also
called <a class="index-entry-id" id="index-tabulation-1"></a>
<em class="dfn">tabulation</em>) is a technique that enables a procedure to record,
in a local table, values that have previously been computed.  This technique
can make a vast difference in the performance of a program.  A memoized
procedure maintains a table in which values of previous calls are stored using
as keys the arguments that produced the values.  When the memoized procedure is
asked to compute a value, it first checks the table to see if the value is
already there and, if so, just returns that value.  Otherwise, it computes the
new value in the ordinary way and stores this in the table.  As an example of
memoization, recall from <a class="ref" href="1_002e2.xhtml#g_t1_002e2_002e2">Tree Recursion</a> the exponential process for
computing Fibonacci numbers:
</p>
<div class="example">
<pre class="example-preformatted">fn fib(n: u64) -&gt; u64 {
    match n {
        0 =&gt; 0,
        1 =&gt; 1,
        _ =&gt; fib(n - 1) + fib(n - 2),
    }
}
</pre></div>

<p>The memoized version of the same procedure is
</p>
<div class="example">
<pre class="example-preformatted">use std::collections::HashMap;
use std::cell::RefCell;

// Memoized Fibonacci using interior mutability
thread_local! {
    static MEMO: RefCell&lt;HashMap&lt;u64, u64&gt;&gt; = RefCell::new(HashMap::new());
}

fn memo_fib(n: u64) -&gt; u64 {
    MEMO.with(|memo| {
        if let Some(&amp;result) = memo.borrow().get(&amp;n) {
            return result;
        }
        let result = match n {
            0 =&gt; 0,
            1 =&gt; 1,
            _ =&gt; memo_fib(n - 1) + memo_fib(n - 2),
        };
        memo.borrow_mut().insert(n, result);
        result
    })
}
</pre></div>

<p>where the memoizer is defined as
</p>
<div class="example">
<pre class="example-preformatted">use std::collections::HashMap;
use std::hash::Hash;

/// Generic memoization wrapper
struct Memoized&lt;A, R, F&gt;
where
    A: Eq + Hash + Clone,
    R: Clone,
    F: FnMut(A) -&gt; R,
{
    cache: HashMap&lt;A, R&gt;,
    func: F,
}

impl&lt;A, R, F&gt; Memoized&lt;A, R, F&gt;
where
    A: Eq + Hash + Clone,
    R: Clone,
    F: FnMut(A) -&gt; R,
{
    fn new(func: F) -&gt; Self {
        Memoized { cache: HashMap::new(), func }
    }

    fn call(&amp;mut self, arg: A) -&gt; R {
        if let Some(result) = self.cache.get(&amp;arg) {
            return result.clone();
        }
        let result = (self.func)(arg.clone());
        self.cache.insert(arg, result.clone());
        result
    }
}
</pre></div>

<p>Draw an environment diagram to analyze the computation of <code class="code">(memo-fib 3)</code>.
Explain why <code class="code">memo-fib</code> computes the <em class="math">n^{\text{th}}</em> Fibonacci number in a number
of steps proportional to <em class="math">n</em>.  Would the scheme still work if we had simply
defined <code class="code">memo-fib</code> to be <code class="code">(memoize fib)</code>?
</p></blockquote>

<hr />
</div>
<div class="subsection-level-extent" id="g_t3_002e3_002e4">
<h4 class="subsection" id="A-Simulator-for-Digital-Circuits"><span>3.3.4 A Simulator for Digital Circuits<a class="copiable-link" href="#A-Simulator-for-Digital-Circuits"> &#182;</a></span></h4>

<p>Designing complex digital systems, such as computers, is an important
engineering activity.  Digital systems are constructed by interconnecting
simple elements.  Although the behavior of these individual elements is simple,
networks of them can have very complex behavior.  Computer simulation of
proposed circuit designs is an important tool used by digital systems
engineers.  In this section we design a system for performing digital logic
simulations.  This system typifies a kind of program called an
<a class="index-entry-id" id="index-event_002ddriven-simulation"></a>
<em class="dfn">event-driven simulation</em>, in which actions (&#8220;events&#8221;) trigger
further events that happen at a later time, which in turn trigger more events,
and so on.
</p>
<p>Our computational model of a circuit will be composed of objects that
correspond to the elementary components from which the circuit is constructed.
There are <a class="index-entry-id" id="index-wires"></a>
<em class="dfn">wires</em>, which carry <a class="index-entry-id" id="index-digital-signals"></a>
<em class="dfn">digital signals</em>.  A digital
signal may at any moment have only one of two possible values, 0 and 1.  There
are also various types of digital <a class="index-entry-id" id="index-function-boxes"></a>
<em class="dfn">function boxes</em>, which connect wires
carrying input signals to other output wires.  Such boxes produce output
signals computed from their input signals.  The output signal is delayed by a
time that depends on the type of the function box.  For example, an
<a class="index-entry-id" id="index-inverter"></a>
<em class="dfn">inverter</em> is a primitive function box that inverts its input.  If the
input signal to an inverter changes to 0, then one inverter-delay later the
inverter will change its output signal to 1.  If the input signal to an
inverter changes to 1, then one inverter-delay later the inverter will change
its output signal to 0.  We draw an inverter symbolically as in <a class="ref" href="#Figure-3_002e24">Figure 3.24</a>.  
An <a class="index-entry-id" id="index-and_002dgate"></a>
<em class="dfn">and-gate</em>, also shown in figure 3.24, is a primitive
function box with two inputs and one output.  It drives its output signal to a
value that is the <a class="index-entry-id" id="index-logical-and"></a>
<em class="dfn">logical and</em> of the inputs.  That is, if both of its
input signals become 1, then one and-gate-delay time later the and-gate will
force its output signal to be 1; otherwise the output will be 0.  An
<a class="index-entry-id" id="index-or_002dgate"></a>
<em class="dfn">or-gate</em> is a similar two-input primitive function box that drives its
output signal to a value that is the <a class="index-entry-id" id="index-logical-or"></a>
<em class="dfn">logical or</em> of the inputs.  That
is, the output will become 1 if at least one of the input signals is 1;
otherwise the output will become 0.
</p>
<div class="float">
<a class="anchor" id="Figure-3_002e24"></a><img class="image" src="fig/chap3/Fig3.24a.std.svg" alt="fig/chap3/Fig3.24a" />
<div class="caption"><p><strong class="strong">Figure 3.24:</strong> Primitive functions in the digital logic simulator.</p></div></div>
<p>We can connect primitive functions together to construct more complex
functions.  To accomplish this we wire the outputs of some function boxes to
the inputs of other function boxes.  For example, the <a class="index-entry-id" id="index-half_002dadder"></a>
<em class="dfn">half-adder</em>
circuit shown in <a class="ref" href="#Figure-3_002e25">Figure 3.25</a> consists of an or-gate, two and-gates, and
an inverter.  It takes two input signals, A and B, and has two output signals,
S and C.  S will become 1 whenever precisely one of A and B is 1, and C will
become 1 whenever A and B are both 1.  We can see from the figure that, because
of the delays involved, the outputs may be generated at different times.  Many
of the difficulties in the design of digital circuits arise from this fact.
</p>
<div class="float">
<a class="anchor" id="Figure-3_002e25"></a><img class="image" src="fig/chap3/Fig3.25c.std.svg" alt="fig/chap3/Fig3.25c" />
<div class="caption"><p><strong class="strong">Figure 3.25:</strong> A half-adder circuit.</p></div></div>
<p>We will now build a program for modeling the digital logic circuits we wish to
study.  The program will construct computational objects modeling the wires,
which will &#8220;hold&#8221; the signals.  Function boxes will be modeled by procedures
that enforce the correct relationships among the signals.
</p>
<p>One basic element of our simulation will be a procedure <code class="code">Wire::new</code>, which
constructs wires.  For example, we can construct six wires as follows:
</p>
<div class="example">
<pre class="example-preformatted">let a = Wire::new();
let b = Wire::new();
let c = Wire::new();
let d = Wire::new();
let e = Wire::new();
let s = Wire::new();
</pre></div>

<p>We attach a function box to a set of wires by calling a procedure that
constructs that kind of box.  The arguments to the constructor procedure are
the wires to be attached to the box.  For example, given that we can construct
and-gates, or-gates, and inverters, we can wire together the half-adder shown
in <a class="ref" href="#Figure-3_002e25">Figure 3.25</a>:
</p>
<div class="example">
<pre class="example-preformatted">circuit.or_gate(&amp;a, &amp;b, &amp;d);
// =&gt; Ok(())

circuit.and_gate(&amp;a, &amp;b, &amp;c);
// =&gt; Ok(())

circuit.inverter(&amp;c, &amp;e);
// =&gt; Ok(())

circuit.and_gate(&amp;d, &amp;e, &amp;s);
// =&gt; Ok(())
</pre></div>

<p>Better yet, we can explicitly name this operation by defining a procedure
<code class="code">half_adder</code> that constructs this circuit, given the four external wires
to be attached to the half-adder:
</p>
<div class="example">
<pre class="example-preformatted">fn half_adder(
    circuit: &amp;mut Circuit,
    a: &amp;Wire, b: &amp;Wire, s: &amp;Wire, c: &amp;Wire
) {
    let d = Wire::new();
    let e = Wire::new();
    circuit.or_gate(a, b, &amp;d);
    circuit.and_gate(a, b, c);
    circuit.inverter(c, &amp;e);
    circuit.and_gate(&amp;d, &amp;e, s);
}
</pre></div>

<p>The advantage of making this definition is that we can use <code class="code">half_adder</code>
itself as a building block in creating more complex circuits.  <a class="ref" href="#Figure-3_002e26">Figure 3.26</a>, 
for example, shows a <a class="index-entry-id" id="index-full_002dadder"></a>
<em class="dfn">full-adder</em> composed of two half-adders
and an or-gate.<a class="footnote" id="DOCF145" href="#FOOT145"><sup>145</sup></a> We can construct a full-adder as follows:
</p>
<div class="example">
<pre class="example-preformatted">fn full_adder(
    circuit: &amp;mut Circuit,
    a: &amp;Wire, b: &amp;Wire, c_in: &amp;Wire, sum: &amp;Wire, c_out: &amp;Wire
) {
    let c1 = Wire::new();
    let c2 = Wire::new();
    let s = Wire::new();
    half_adder(circuit, b, c_in, &amp;s, &amp;c1);
    half_adder(circuit, a, &amp;s, sum, &amp;c2);
    circuit.or_gate(&amp;c1, &amp;c2, c_out);
}
</pre></div>

<div class="float">
<a class="anchor" id="Figure-3_002e26"></a><img class="image" src="fig/chap3/Fig3.26.std.svg" alt="fig/chap3/Fig3.26" />
<div class="caption"><p><strong class="strong">Figure 3.26:</strong> A full-adder circuit.</p></div></div>
<p>Having defined <code class="code">full_adder</code> as a procedure, we can now use it as a
building block for creating still more complex circuits.  (For example, see
<a class="ref" href="#Exercise-3_002e30">Exercise 3.30</a>.)
</p>
<p>In essence, our simulator provides us with the tools to construct a language of
circuits.  If we adopt the general perspective on languages with which we
approached the study of Lisp in <a class="ref" href="1_002e1.xhtml#g_t1_002e1">The Elements of Programming</a>, we can say that the
primitive function boxes form the primitive elements of the language, that
wiring boxes together provides a means of combination, and that specifying
wiring patterns as procedures serves as a means of abstraction.
</p>
<h4 class="subsubheading" id="Primitive-function-boxes"><span>Primitive function boxes<a class="copiable-link" href="#Primitive-function-boxes"> &#182;</a></span></h4>

<p>The primitive function boxes implement the &#8220;forces&#8221; by which a change in the
signal on one wire influences the signals on other wires.  To build function
boxes, we use the following operations on wires:
</p>
<ul class="itemize mark-bullet">
<li><code class="code">(get-signal ⟨<var class="var">wire</var>⟩)</code>

<p>returns the current value of the signal on the wire.
</p>
</li><li><code class="code">set_signal(⟨<var class="var">wire</var>⟩, ⟨<var class="var">new_value</var>⟩)</code>

<p>changes the value of the signal on the wire to the new value.
</p>
</li><li><code class="code">(add-action! ⟨<var class="var">wire</var>⟩ ⟨<var class="var">procedure of no arguments</var>⟩)</code>

<p>asserts that the designated procedure should be run whenever the signal on the
wire changes value.  Such procedures are the vehicles by which changes in the
signal value on the wire are communicated to other wires.
</p>
</li></ul>

<p>In addition, we will make use of a procedure <code class="code">after-delay</code> that takes a
time delay and a procedure to be run and executes the given procedure after the
given delay.
</p>
<p>Using these procedures, we can define the primitive digital logic functions.
To connect an input to an output through an inverter, we use <code class="code">add_action</code>
to associate with the input wire a procedure that will be run whenever the
signal on the input wire changes value.  The procedure computes the
<code class="code">logical-not</code> of the input signal, and then, after one
<code class="code">inverter-delay</code>, sets the output signal to be this new value:
</p>
<div class="example">
<pre class="example-preformatted">impl Circuit {
    fn inverter(&amp;mut self, input: WireId, output: WireId) {
        let invert_action = move |circuit: &amp;mut Circuit| {
            let new_value = logical_not(circuit.get_signal(input));
            circuit.after_delay(INVERTER_DELAY, move |c| {
                c.set_signal(output, new_value);
            });
        };
        self.add_action(input, invert_action);
    }
}

fn logical_not(s: Signal) -&gt; Signal {
    match s {
        Signal::Low =&gt; Signal::High,
        Signal::High =&gt; Signal::Low,
    }
}
</pre></div>

<p>An and-gate is a little more complex.  The action procedure must be run if
either of the inputs to the gate changes.  It computes the <code class="code">logical-and</code>
(using a procedure analogous to <code class="code">logical-not</code>) of the values of the
signals on the input wires and sets up a change to the new value to occur on
the output wire after one <code class="code">and-gate-delay</code>.
</p>
<div class="example">
<pre class="example-preformatted">impl Circuit {
    fn and_gate(&amp;mut self, a1: WireId, a2: WireId, output: WireId) {
        let and_action = move |circuit: &amp;mut Circuit| {
            let new_value = logical_and(
                circuit.get_signal(a1),
                circuit.get_signal(a2)
            );
            circuit.after_delay(AND_GATE_DELAY, move |c| {
                c.set_signal(output, new_value);
            });
        };
        self.add_action(a1, and_action.clone());
        self.add_action(a2, and_action);
    }
}
</pre></div>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-3_002e28"></a>Exercise 3.28:</strong> Define an or-gate as a primitive
function box.  Your <code class="code">or-gate</code> constructor should be similar to
<code class="code">and-gate</code>.
</p></blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-3_002e29"></a>Exercise 3.29:</strong> Another way to construct an
or-gate is as a compound digital logic device, built from and-gates and
inverters.  Define a procedure <code class="code">or-gate</code> that accomplishes this.  What is
the delay time of the or-gate in terms of <code class="code">and-gate-delay</code> and
<code class="code">inverter-delay</code>?
</p></blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-3_002e30"></a>Exercise 3.30:</strong> <a class="ref" href="#Figure-3_002e27">Figure 3.27</a> shows a
<a class="index-entry-id" id="index-ripple_002dcarry-adder"></a>
<em class="dfn">ripple-carry adder</em> formed by stringing together <em class="math">n</em> full-adders.
This is the simplest form of parallel adder for adding two <em class="math">n</em>-bit binary
numbers.  The inputs <em class="math">A_1</em>, <em class="math">A_2</em>, <em class="math">A_3</em>, &#8230;, <em class="math">A_n</em> and 
<em class="math">B_1</em>, <em class="math">B_2</em>, <em class="math">B_3</em>,
&#8230;, <em class="math">B_n</em> are the two binary numbers to be added (each <em class="math">A_k</em> and
<em class="math">B_k</em> is a 0 or a 1).  The circuit generates <em class="math">S_1</em>, <em class="math">S_2</em>, 
<em class="math">S_3</em>, &#8230;, <em class="math">S_n</em>,
the <em class="math">n</em> bits of the sum, and <em class="math">C</em>, the carry from the addition.  Write a
procedure <code class="code">ripple-carry-adder</code> that generates this circuit.  The procedure
should take as arguments three lists of <em class="math">n</em> wires each&#8212;the <em class="math">A_k</em>, the
<em class="math">B_k</em>, and the <em class="math">S_k</em>&#8212;and also another wire <em class="math">C</em>.  The major drawback of the
ripple-carry adder is the need to wait for the carry signals to propagate.
What is the delay needed to obtain the complete output from an <em class="math">n</em>-bit
ripple-carry adder, expressed in terms of the delays for and-gates, or-gates,
and inverters?
</p></blockquote>

<div class="float">
<a class="anchor" id="Figure-3_002e27"></a><img class="image" src="fig/chap3/Fig3.27b.std.svg" alt="fig/chap3/Fig3.27b" />
<div class="caption"><p><strong class="strong">Figure 3.27:</strong> A ripple-carry adder for <em class="math">n</em>-bit numbers.</p></div></div>
<h4 class="subsubheading" id="Representing-wires"><span>Representing wires<a class="copiable-link" href="#Representing-wires"> &#182;</a></span></h4>

<p>A wire in our simulation will be a computational object with two local state
variables: a <code class="code">signal-value</code> (initially taken to be 0) and a collection of
<code class="code">action-procedures</code> to be run when the signal changes value.  We implement
the wire, using message-passing style, as a collection of local procedures
together with a <code class="code">dispatch</code> procedure that selects the appropriate local
operation, just as we did with the simple bank-account object in 
<a class="ref" href="3_002e1.xhtml#g_t3_002e1_002e1">Local State Variables</a>:
</p>
<div class="example">
<pre class="example-preformatted">use std::cell::Cell;

#[derive(Clone, Copy, PartialEq, Eq)]
enum Signal { Low, High }

struct Wire {
    signal: Cell&lt;Signal&gt;,
    actions: Vec&lt;Box&lt;dyn Fn(&amp;mut Circuit)&gt;&gt;,
}

impl Wire {
    fn new() -&gt; Self {
        Wire {
            signal: Cell::new(Signal::Low),
            actions: Vec::new(),
        }
    }

    fn get_signal(&amp;self) -&gt; Signal {
        self.signal.get()
    }

    fn set_signal(&amp;self, new_value: Signal, circuit: &amp;mut Circuit) {
        if self.signal.get() != new_value {
            self.signal.set(new_value);
            for action in &amp;self.actions {
                action(circuit);
            }
        }
    }

    fn add_action(&amp;mut self, action: Box&lt;dyn Fn(&amp;mut Circuit)&gt;) {
        self.actions.push(action);
    }
}
</pre></div>

<p>The local procedure <code class="code">set-my-signal!</code> tests whether the new signal value
changes the signal on the wire.  If so, it runs each of the action procedures,
using the following procedure <code class="code">call-each</code>, which calls each of the items
in a list of no-argument procedures:
</p>
<div class="example">
<pre class="example-preformatted">fn call_each&lt;F&gt;(procedures: &amp;[F])
where
    F: Fn(),
{
    for proc in procedures {
        proc();
    }
}
</pre></div>

<p>The local procedure <code class="code">accept-action-procedure!</code> adds the given procedure to
the list of procedures to be run, and then runs the new procedure once.  (See
<a class="ref" href="#Exercise-3_002e31">Exercise 3.31</a>.)
</p>
<p>With the local <code class="code">dispatch</code> procedure set up as specified, we can provide
the following procedures to access the local operations on
wires:<a class="footnote" id="DOCF146" href="#FOOT146"><sup>146</sup></a>
</p>
<div class="example">
<pre class="example-preformatted">// In Rust, these are simply method calls on Wire:
// wire.get_signal()
// wire.set_signal(new_value, circuit)
// wire.add_action(action)
//
// The dispatch-based message passing is replaced by
// direct method calls on the Wire struct.
</pre></div>

<p>Wires, which have time-varying signals and may be incrementally attached to
devices, are typical of mutable objects.  We have modeled them as procedures
with local state variables that are modified by assignment.  When a new wire is
created, a new set of state variables is allocated (by the <code class="code">let</code>
expression in <code class="code">Wire::new</code>) and a new <code class="code">dispatch</code> procedure is
constructed and returned, capturing the environment with the new state
variables.
</p>
<p>The wires are shared among the various devices that have been connected to
them.  Thus, a change made by an interaction with one device will affect all
the other devices attached to the wire.  The wire communicates the change to
its neighbors by calling the action procedures provided to it when the
connections were established.
</p>
<h4 class="subsubheading" id="The-agenda"><span>The agenda<a class="copiable-link" href="#The-agenda"> &#182;</a></span></h4>

<p>The only thing needed to complete the simulator is <code class="code">after-delay</code>.  The
idea here is that we maintain a data structure, called an <a class="index-entry-id" id="index-agenda"></a>
<em class="dfn">agenda</em>,
that contains a schedule of things to do.  The following operations are defined
for agendas:
</p>
<ul class="itemize mark-bullet">
<li><code class="code">Agenda::new</code> returns a new empty agenda.

</li><li><code class="code">(empty-agenda? ⟨<var class="var">agenda</var>⟩)</code> is true if the specified agenda is
empty.

</li><li><code class="code">(first-agenda-item ⟨<var class="var">agenda</var>⟩)</code> returns the first item on the
agenda.

</li><li><code class="code">(remove-first-agenda-item! ⟨<var class="var">agenda</var>⟩)</code> modifies the agenda by
removing the first item.

</li><li><code class="code">(add-to-agenda! ⟨<var class="var">time</var>⟩ ⟨<var class="var">action</var>⟩ ⟨<var class="var">agenda</var>⟩)</code> 
modifies the agenda by adding the given action procedure to be run at the 
specified time.

</li><li><code class="code">(current-time ⟨<var class="var">agenda</var>⟩)</code> returns the current simulation time.

</li></ul>

<p>The particular agenda that we use is denoted by <code class="code">the-agenda</code>.  The
procedure <code class="code">after-delay</code> adds new elements to <code class="code">the-agenda</code>:
</p>
<div class="example">
<pre class="example-preformatted">impl Circuit {
    fn after_delay&lt;F&gt;(&amp;mut self, delay: u64, action: F)
    where
        F: FnOnce(&amp;mut Circuit) + 'static,
    {
        let time = self.current_time() + delay;
        self.agenda.add(time, Box::new(action));
    }
}
</pre></div>

<p>The simulation is driven by the procedure <code class="code">propagate</code>, which operates on
<code class="code">the-agenda</code>, executing each procedure on the agenda in sequence.  In
general, as the simulation runs, new items will be added to the agenda, and
<code class="code">propagate</code> will continue the simulation as long as there are items on the
agenda:
</p>
<div class="example">
<pre class="example-preformatted">impl Circuit {
    fn propagate(&amp;mut self) {
        while let Some((time, action)) = self.agenda.pop_first() {
            self.time = time;
            action(self);
        }
    }
}
</pre></div>

<h4 class="subsubheading" id="A-sample-simulation"><span>A sample simulation<a class="copiable-link" href="#A-sample-simulation"> &#182;</a></span></h4>

<p>The following procedure, which places a &#8220;probe&#8221; on a wire, shows the
simulator in action.  The probe tells the wire that, whenever its signal
changes value, it should print the new signal value, together with the current
time and a name that identifies the wire:
</p>
<div class="example">
<pre class="example-preformatted">fn probe(name: &amp;'static str, wire: WireId, circuit: &amp;mut Circuit) {
    circuit.add_action(wire, move |c| {
        println!(
            &quot;{} {}  New-value = {:?}&quot;,
            name,
            c.current_time(),
            c.get_signal(wire)
        );
    });
}
</pre></div>

<p>We begin by initializing the agenda and specifying delays for the primitive
function boxes:
</p>
<div class="example">
<pre class="example-preformatted">let mut circuit = Circuit::new();
const INVERTER_DELAY: u64 = 2;
const AND_GATE_DELAY: u64 = 3;
const OR_GATE_DELAY: u64 = 5;
</pre></div>

<p>Now we define four wires, placing probes on two of them:
</p>
<div class="example">
<pre class="example-preformatted">let input_1 = circuit.make_wire();
let input_2 = circuit.make_wire();
let sum = circuit.make_wire();
let carry = circuit.make_wire();

probe(&quot;sum&quot;, sum, &amp;mut circuit);
// =&gt; sum 0  New-value = Low

probe(&quot;carry&quot;, carry, &amp;mut circuit);
// =&gt; carry 0  New-value = Low
</pre></div>

<p>Next we connect the wires in a half-adder circuit (as in <a class="ref" href="#Figure-3_002e25">Figure 3.25</a>),
set the signal on <code class="code">input-1</code> to 1, and run the simulation:
</p>
<div class="example">
<pre class="example-preformatted">half_adder(&amp;mut circuit, input_1, input_2, sum, carry);

circuit.set_signal(input_1, Signal::High);

circuit.propagate();
// =&gt; sum 8  New-value = High
</pre></div>

<p>The <code class="code">sum</code> signal changes to 1 at time 8.  We are now eight time units from
the beginning of the simulation.  At this point, we can set the signal on
<code class="code">input-2</code> to 1 and allow the values to propagate:
</p>
<div class="example">
<pre class="example-preformatted">circuit.set_signal(input_2, Signal::High);

circuit.propagate();
// =&gt; carry 11  New-value = High
// =&gt; sum 16  New-value = Low
</pre></div>

<p>The <code class="code">carry</code> changes to 1 at time 11 and the <code class="code">sum</code> changes to 0 at
time 16.
</p>
<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-3_002e31"></a>Exercise 3.31:</strong> The internal procedure
<code class="code">accept-action-procedure!</code> defined in <code class="code">Wire::new</code> specifies that when
a new action procedure is added to a wire, the procedure is immediately run.
Explain why this initialization is necessary.  In particular, trace through the
half-adder example in the paragraphs above and say how the system&#8217;s response
would differ if we had defined <code class="code">accept-action-procedure!</code> as
</p>
<div class="example">
<pre class="example-preformatted">fn accept_action_procedure(&amp;mut self, proc: Action) {
    self.action_procedures.push(proc);
    // Note: missing the immediate invocation!
}
</pre></div>
</blockquote>

<h4 class="subsubheading" id="Implementing-the-agenda"><span>Implementing the agenda<a class="copiable-link" href="#Implementing-the-agenda"> &#182;</a></span></h4>

<p>Finally, we give details of the agenda data structure, which holds the
procedures that are scheduled for future execution.
</p>
<p>The agenda is made up of <a class="index-entry-id" id="index-time-segments"></a>
<em class="dfn">time segments</em>.  Each time segment is a pair
consisting of a number (the time) and a queue (see <a class="ref" href="#Exercise-3_002e32">Exercise 3.32</a>) that
holds the procedures that are scheduled to be run during that time segment.
</p>
<div class="example">
<pre class="example-preformatted">struct TimeSegment {
    time: u64,
    queue: VecDeque&lt;Action&gt;,
}

impl TimeSegment {
    fn new(time: u64) -&gt; Self {
        TimeSegment { time, queue: VecDeque::new() }
    }
}
</pre></div>

<p>We will operate on the time-segment queues using the queue operations described
in <a class="ref" href="#g_t3_002e3_002e2">Representing Queues</a>.
</p>
<p>The agenda itself is a one-dimensional table of time segments.  It differs from
the tables described in <a class="ref" href="#g_t3_002e3_002e3">Representing Tables</a> in that the segments will be sorted
in order of increasing time.  In addition, we store the <a class="index-entry-id" id="index-current-time"></a>
<em class="dfn">current time</em>
(i.e., the time of the last action that was processed) at the head of the
agenda.  A newly constructed agenda has no time segments and has a current time
of 0:<a class="footnote" id="DOCF147" href="#FOOT147"><sup>147</sup></a>
</p>
<div class="example">
<pre class="example-preformatted">use std::collections::BTreeMap;

struct Agenda {
    current_time: u64,
    segments: BTreeMap&lt;u64, VecDeque&lt;Action&gt;&gt;,
}

impl Agenda {
    fn new() -&gt; Self {
        Agenda {
            current_time: 0,
            segments: BTreeMap::new(),
        }
    }

    fn current_time(&amp;self) -&gt; u64 {
        self.current_time
    }
}
</pre></div>

<p>An agenda is empty if it has no time segments:
</p>
<div class="example">
<pre class="example-preformatted">impl Agenda {
    fn is_empty(&amp;self) -&gt; bool {
        self.segments.is_empty()
    }
}
</pre></div>

<p>To add an action to an agenda, we first check if the agenda is empty.  If so,
we create a time segment for the action and install this in the agenda.
Otherwise, we scan the agenda, examining the time of each segment.  If we find
a segment for our appointed time, we add the action to the associated queue.
If we reach a time later than the one to which we are appointed, we insert a
new time segment into the agenda just before it.  If we reach the end of the
agenda, we must create a new time segment at the end.
</p>
<div class="example">
<pre class="example-preformatted">impl Agenda {
    fn add(&amp;mut self, time: u64, action: Action) {
        // BTreeMap keeps segments sorted by time automatically
        self.segments
            .entry(time)
            .or_insert_with(VecDeque::new)
            .push_back(action);
    }
}
</pre></div>

<p>The procedure that removes the first item from the agenda deletes the item at
the front of the queue in the first time segment.  If this deletion makes the
time segment empty, we remove it from the list of segments:<a class="footnote" id="DOCF148" href="#FOOT148"><sup>148</sup></a>
</p>
<div class="example">
<pre class="example-preformatted">impl Agenda {
    fn remove_first(&amp;mut self) -&gt; Option&lt;Action&gt; {
        let first_time = *self.segments.keys().next()?;
        let queue = self.segments.get_mut(&amp;first_time)?;
        let action = queue.pop_front();
        if queue.is_empty() {
            self.segments.remove(&amp;first_time);
        }
        action
    }
}
</pre></div>

<p>The first agenda item is found at the head of the queue in the first time
segment.  Whenever we extract an item, we also update the current
time:<a class="footnote" id="DOCF149" href="#FOOT149"><sup>149</sup></a>
</p>
<div class="example">
<pre class="example-preformatted">impl Agenda {
    fn first_item(&amp;mut self) -&gt; Option&lt;&amp;Action&gt; {
        let (&amp;first_time, queue) = self.segments.iter().next()?;
        self.current_time = first_time;
        queue.front()
    }

    fn pop_first(&amp;mut self) -&gt; Option&lt;(u64, Action)&gt; {
        let first_time = *self.segments.keys().next()?;
        let queue = self.segments.get_mut(&amp;first_time)?;
        let action = queue.pop_front()?;
        if queue.is_empty() {
            self.segments.remove(&amp;first_time);
        }
        self.current_time = first_time;
        Some((first_time, action))
    }
}
</pre></div>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-3_002e32"></a>Exercise 3.32:</strong> The procedures to be run during
each time segment of the agenda are kept in a queue.  Thus, the procedures for
each segment are called in the order in which they were added to the agenda
(first in, first out).  Explain why this order must be used.  In particular,
trace the behavior of an and-gate whose inputs change from 0, 1 to 1, 0 in the
same segment and say how the behavior would differ if we stored a segment&#8217;s
procedures in an ordinary list, adding and removing procedures only at the
front (last in, first out).
</p></blockquote>


<hr />
</div>
<div class="subsection-level-extent" id="g_t3_002e3_002e4a">
<h4 class="subsection" id="Arena-Allocation-for-Graphs"><span>3.3.5 Arena Allocation for Graphs<a class="copiable-link" href="#Arena-Allocation-for-Graphs"> &#182;</a></span></h4>
<a class="index-entry-id" id="index-arena-allocation"></a>
<a class="index-entry-id" id="index-graph-structures"></a>
<a class="index-entry-id" id="index-cyclic-references"></a>
<a class="index-entry-id" id="index-index_002dbased-references"></a>
<a class="index-entry-id" id="index-borrow-checker-escape-hatch"></a>

<p>The digital circuit simulator in the previous section introduces a common
challenge in systems programming: building graph-like data structures with
cyclic references. A circuit naturally forms a graph where wires connect to
multiple gates, and gates connect to multiple wires. In languages with garbage
collection, we might use shared references freely. But in Rust, the borrow
checker enforces that we cannot have multiple mutable references to the same
data&#8212;precisely what a cyclic graph seems to require.
</p>
<p>The <a class="index-entry-id" id="index-arena-pattern"></a>
<em class="dfn">arena pattern</em> provides an elegant solution: instead of using
references, we store all nodes in a contiguous <code class="code">Vec</code> and refer to them by
index. This trades Rust&#8217;s compile-time safety guarantees for runtime index
bounds checking, but in return we get graph structures that are straightforward
to build, efficient to traverse, and trivially thread-safe.
</p>
<h4 class="subsubheading" id="The-Problem_003a-Cycles-and-the-Borrow-Checker"><span>The Problem: Cycles and the Borrow Checker<a class="copiable-link" href="#The-Problem_003a-Cycles-and-the-Borrow-Checker"> &#182;</a></span></h4>

<p>Let&#8217;s consider a simple graph structure&#8212;a doubly-linked list where each node
points to both its predecessor and successor:
</p>
<div class="example">
<pre class="example-preformatted"><a class="index-entry-id" id="index-doubly_002dlinked-list"></a>// Naive attempt: won't compile
struct Node {
    value: i32,
    prev: Option&lt;&amp;mut Node&gt;,  // Error: missing lifetime parameter
    next: Option&lt;&amp;mut Node&gt;,  // Error: missing lifetime parameter
}
</pre></div>

<p>We immediately encounter problems. References need lifetime parameters, but what
lifetime do we use? The nodes reference each other cyclically, so there&#8217;s no
clear ownership hierarchy.
</p>
<p>We might try using <code class="code">Rc&lt;RefCell&lt;Node&gt;&gt;</code> to get shared ownership with
interior mutability:
</p>
<div class="example">
<pre class="example-preformatted"><a class="index-entry-id" id="index-Rc_003cRefCell_003cT_003e_003e-pattern"></a>use std::rc::Rc;
use std::cell::RefCell;

struct Node {
    value: i32,
    prev: Option&lt;Rc&lt;RefCell&lt;Node&gt;&gt;&gt;,
    next: Option&lt;Rc&lt;RefCell&lt;Node&gt;&gt;&gt;,
}

fn create_cycle() {
    let node1 = Rc::new(RefCell::new(Node {
        value: 1,
        prev: None,
        next: None,
    }));

    let node2 = Rc::new(RefCell::new(Node {
        value: 2,
        prev: Some(Rc::clone(&amp;node1)),
        next: None,
    }));

    // Create the cycle
    node1.borrow_mut().next = Some(Rc::clone(&amp;node2));
}
</pre></div>

<p>This compiles, but it has significant drawbacks:
</p>
<ol class="enumerate">
<li> <strong class="strong">Runtime overhead:</strong> Every access goes through <code class="code">RefCell</code>, which
performs runtime borrow checking. This adds overhead and can panic if the borrow
rules are violated at runtime.

</li><li> <strong class="strong">Reference counting overhead:</strong> <code class="code">Rc</code> maintains reference counts,
adding memory overhead and atomic operations (for <code class="code">Arc</code>, the thread-safe
variant).

</li><li> <strong class="strong">Memory leaks with cycles:</strong> If we create a cycle and drop all
<code class="code">Rc</code> handles, the reference count never reaches zero. The memory leaks
unless we manually break the cycle.

</li><li> <strong class="strong">Not thread-safe:</strong> <code class="code">Rc</code> is not <code class="code">Send</code>, so this pattern doesn&#8217;t
work in concurrent code. Even <code class="code">Arc&lt;RefCell&lt;T&gt;&gt;</code> isn&#8217;t safe because
<code class="code">RefCell</code> isn&#8217;t <code class="code">Sync</code>.

</li><li> <strong class="strong">Poor cache locality:</strong> Each node is separately allocated on the heap,
scattering them across memory and destroying cache performance.
</li></ol>

<p>For the circuit simulator&#8212;and for graphs in general&#8212;we need a better approach.
</p>
<h4 class="subsubheading" id="The-Arena-Pattern_003a-Contiguous-Storage-with-Index-References"><span>The Arena Pattern: Contiguous Storage with Index References<a class="copiable-link" href="#The-Arena-Pattern_003a-Contiguous-Storage-with-Index-References"> &#182;</a></span></h4>

<p>The arena pattern solves these problems with a simple insight: instead of using
pointers or reference-counted handles, store all nodes in a <code class="code">Vec</code> and refer
to them by index:
</p>
<div class="example">
<pre class="example-preformatted"><a class="index-entry-id" id="index-arena-pattern-1"></a>struct Node {
    value: i32,
    prev: Option&lt;usize&gt;,  // Index into the arena
    next: Option&lt;usize&gt;,  // Index into the arena
}

struct Arena {
    nodes: Vec&lt;Node&gt;,
}

impl Arena {
    fn new() -&gt; Self {
        Arena { nodes: Vec::new() }
    }

    fn alloc(&amp;mut self, value: i32) -&gt; usize {
        let id = self.nodes.len();
        self.nodes.push(Node {
            value,
            prev: None,
            next: None,
        });
        id
    }

    fn get(&amp;self, id: usize) -&gt; &amp;Node {
        &amp;self.nodes[id]
    }

    fn get_mut(&amp;mut self, id: usize) -&gt; &amp;mut Node {
        &amp;mut self.nodes[id]
    }
}
</pre></div>

<p>Now we can build cyclic structures easily:
</p>
<div class="example">
<pre class="example-preformatted">fn create_cycle() {
    let mut arena = Arena::new();

    let id1 = arena.alloc(1);
    let id2 = arena.alloc(2);

    // Create links without fighting the borrow checker
    arena.get_mut(id1).next = Some(id2);
    arena.get_mut(id2).prev = Some(id1);
    arena.get_mut(id2).next = Some(id1);  // Cycle
    arena.get_mut(id1).prev = Some(id2);
}
</pre></div>

<p>The benefits are substantial:
</p>
<ol class="enumerate">
<li> <strong class="strong">Contiguous memory:</strong> All nodes live in a <code class="code">Vec</code>, improving cache
locality dramatically. Traversing the graph means following indices into the
same contiguous array.

</li><li> <strong class="strong">No reference counting:</strong> Indices are just integers. Copying them is
free, and there&#8217;s no overhead tracking references.

</li><li> <strong class="strong">Trivially thread-safe:</strong> Indices are <code class="code">Copy</code>, <code class="code">Send</code>, and
<code class="code">Sync</code>. The arena can be shared across threads with standard synchronization.

</li><li> <strong class="strong">No memory leaks:</strong> When the arena is dropped, all nodes are freed
together, regardless of cycles.

</li><li> <strong class="strong">Deterministic deallocation:</strong> Unlike garbage collection, we control
exactly when the arena is freed.
</li></ol>

<h4 class="subsubheading" id="Type_002dSafe-Indices-with-ArenaId_003cT_003e"><span>Type-Safe Indices with <code class="code">ArenaId&lt;T&gt;</code><a class="copiable-link" href="#Type_002dSafe-Indices-with-ArenaId_003cT_003e"> &#182;</a></span></h4>

<p>The basic arena pattern has one weakness: indices are just <code class="code">usize</code>, so we
can accidentally use an index from the wrong arena or mix up indices for
different node types. We can solve this with a <a class="index-entry-id" id="index-type_002dsafe-index"></a>
<em class="dfn">type-safe index</em> using
Rust&#8217;s type system:
</p>
<div class="example">
<pre class="example-preformatted"><a class="index-entry-id" id="index-type_002dsafe-indices"></a><a class="index-entry-id" id="index-PhantomData"></a>use std::marker::PhantomData;

/// Type-safe index into an Arena&lt;T&gt;
struct ArenaId&lt;T&gt; {
    index: usize,
    _marker: PhantomData&lt;T&gt;,  // Marker: this is an index to T
}

// Implement Copy and Clone manually to avoid requiring T: Copy
impl&lt;T&gt; Copy for ArenaId&lt;T&gt; {}
impl&lt;T&gt; Clone for ArenaId&lt;T&gt; {
    fn clone(&amp;self) -&gt; Self { *self }
}

impl&lt;T&gt; PartialEq for ArenaId&lt;T&gt; {
    fn eq(&amp;self, other: &amp;Self) -&gt; bool {
        self.index == other.index
    }
}
impl&lt;T&gt; Eq for ArenaId&lt;T&gt; {}
</pre></div>

<p>The <code class="code">PhantomData&lt;T&gt;</code> marker serves a crucial role: it makes <code class="code">ArenaId</code>
generic over <code class="code">T</code>, preventing us from using an <code class="code">ArenaId&lt;Node&gt;</code> where an
<code class="code">ArenaId&lt;Wire&gt;</code> is expected. But because <code class="code">PhantomData</code> is a
zero-sized type, this type safety comes with zero runtime cost.
</p>
<p>Now our arena becomes:
</p>
<div class="example">
<pre class="example-preformatted">struct Arena&lt;T&gt; {
    items: Vec&lt;T&gt;,
}

impl&lt;T&gt; Arena&lt;T&gt; {
    fn new() -&gt; Self {
        Arena { items: Vec::new() }
    }

    fn alloc(&amp;mut self, value: T) -&gt; ArenaId&lt;T&gt; {
        let index = self.items.len();
        self.items.push(value);
        ArenaId {
            index,
            _marker: PhantomData,
        }
    }

    fn get(&amp;self, id: ArenaId&lt;T&gt;) -&gt; &amp;T {
        &amp;self.items[id.index]
    }

    fn get_mut(&amp;mut self, id: ArenaId&lt;T&gt;) -&gt; &amp;mut T {
        &amp;mut self.items[id.index]
    }
}
</pre></div>

<p>Type safety prevents mixing different arenas:
</p>
<div class="example">
<pre class="example-preformatted"><a class="index-entry-id" id="index-type-safety-1"></a>fn demonstrate_type_safety() {
    let mut nodes: Arena&lt;Node&gt; = Arena::new();
    let mut wires: Arena&lt;Wire&gt; = Arena::new();

    let node_id = nodes.alloc(Node { value: 1, prev: None, next: None });
    let wire_id = wires.alloc(Wire { signal: 0 });

    // This works:
    let node = nodes.get(node_id);

    // This won't compile:
    // let wrong = nodes.get(wire_id);  // Type error: expected ArenaId&lt;Node&gt;, found ArenaId&lt;Wire&gt;
}
</pre></div>

<h4 class="subsubheading" id="Implementing-the-Circuit-Simulator-with-Arenas"><span>Implementing the Circuit Simulator with Arenas<a class="copiable-link" href="#Implementing-the-Circuit-Simulator-with-Arenas"> &#182;</a></span></h4>

<p>Let&#8217;s apply the arena pattern to our circuit simulator. Each wire and gate lives
in an arena, referenced by typed indices:
</p>
<div class="example">
<pre class="example-preformatted"><a class="index-entry-id" id="index-circuit-simulator"></a><a class="index-entry-id" id="index-event_002ddriven-simulation-1"></a>use std::collections::VecDeque;

type WireId = ArenaId&lt;Wire&gt;;
type GateId = ArenaId&lt;Gate&gt;;

struct Wire {
    signal: u8,           // 0 or 1
    gates: Vec&lt;GateId&gt;,   // Gates to notify when signal changes
}

enum GateType {
    And(WireId, WireId, WireId),      // input1, input2, output
    Or(WireId, WireId, WireId),
    Inverter(WireId, WireId),         // input, output
}

struct Gate {
    gate_type: GateType,
    delay: usize,
}

struct Circuit {
    wires: Arena&lt;Wire&gt;,
    gates: Arena&lt;Gate&gt;,
    events: VecDeque&lt;Event&gt;,
    time: usize,
}

struct Event {
    time: usize,
    wire: WireId,
    new_signal: u8,
}
</pre></div>

<p>Creating a half-adder circuit becomes straightforward:
</p>
<div class="example">
<pre class="example-preformatted">impl Circuit {
    fn new() -&gt; Self {
        Circuit {
            wires: Arena::new(),
            gates: Arena::new(),
            events: VecDeque::new(),
            time: 0,
        }
    }

    fn new_wire(&amp;mut self) -&gt; WireId {
        self.wires.alloc(Wire {
            signal: 0,
            gates: Vec::new(),
        })
    }

    fn and_gate(&amp;mut self, in1: WireId, in2: WireId, out: WireId) {
        let gate_id = self.gates.alloc(Gate {
            gate_type: GateType::And(in1, in2, out),
            delay: 3,
        });

        // Register this gate with input wires
        self.wires.get_mut(in1).gates.push(gate_id);
        self.wires.get_mut(in2).gates.push(gate_id);
    }

    fn half_adder(&amp;mut self) -&gt; (WireId, WireId, WireId, WireId) {
        let a = self.new_wire();
        let b = self.new_wire();
        let s = self.new_wire();
        let c = self.new_wire();
        let d = self.new_wire();
        let e = self.new_wire();

        self.or_gate(a, b, d);
        self.and_gate(a, b, c);
        self.inverter(c, e);
        self.and_gate(d, e, s);

        (a, b, s, c)
    }

    fn set_signal(&amp;mut self, wire: WireId, signal: u8) {
        self.events.push_back(Event {
            time: self.time,
            wire,
            new_signal: signal,
        });
    }

    fn propagate(&amp;mut self) {
        while let Some(event) = self.events.pop_front() {
            if event.time &gt; self.time {
                self.time = event.time;
            }

            let wire = self.wires.get_mut(event.wire);
            if wire.signal != event.new_signal {
                wire.signal = event.new_signal;

                // Notify all connected gates
                for gate_id in wire.gates.clone() {
                    self.process_gate(gate_id);
                }
            }
        }
    }

    fn process_gate(&amp;mut self, gate_id: GateId) {
        let gate = self.gates.get(gate_id);
        let (output_wire, new_signal) = match &amp;gate.gate_type {
            GateType::And(in1, in2, out) =&gt; {
                let s1 = self.wires.get(*in1).signal;
                let s2 = self.wires.get(*in2).signal;
                (*out, s1 &amp; s2)
            }
            GateType::Or(in1, in2, out) =&gt; {
                let s1 = self.wires.get(*in1).signal;
                let s2 = self.wires.get(*in2).signal;
                (*out, s1 | s2)
            }
            GateType::Inverter(input, out) =&gt; {
                let s = self.wires.get(*input).signal;
                (*out, 1 - s)
            }
        };

        let delay = gate.delay;
        self.events.push_back(Event {
            time: self.time + delay,
            wire: output_wire,
            new_signal,
        });
    }
}
</pre></div>

<p>Notice how the arena pattern allows us to mutate the circuit freely without
fighting the borrow checker. We can look up wires and gates by ID, modify them,
and build complex interconnected structures without lifetime annotations.
</p>
<h4 class="subsubheading" id="When-Not-to-Use-Arenas"><span>When Not to Use Arenas<a class="copiable-link" href="#When-Not-to-Use-Arenas"> &#182;</a></span></h4>

<p>The arena pattern is not a universal solution. It trades compile-time safety for
runtime flexibility, which is appropriate in some contexts but not others:
</p>
<p><strong class="strong">Use arenas when:</strong>
</p><ul class="itemize mark-bullet">
<li>Building graph structures with cycles or complex sharing
</li><li>All nodes have the same lifetime (allocated and freed together)
</li><li>Cache locality matters (traversing many nodes)
</li><li>Thread safety with indices is simpler than with references
</li></ul>

<p><strong class="strong">Avoid arenas when:</strong>
</p><ul class="itemize mark-bullet">
<li>The borrow checker&#8217;s solution is straightforward (use references)
</li><li>Nodes need individual lifetimes (use <code class="code">Box</code> or <code class="code">Rc</code>)
</li><li>Type safety is critical and indices feel too loose
</li><li>The overhead of <code class="code">Rc&lt;RefCell&lt;T&gt;&gt;</code> is acceptable
</li></ul>

<p>The key insight is that arenas are an <em class="emph">escape hatch</em> from the borrow
checker, not a replacement for it. Use the borrow checker when possible; use
arenas when the alternative would be fighting the borrow checker for hours.
</p>
<h4 class="subsubheading" id="The-sicp_002dcommon_003a_003aarena-Module"><span>The <code class="code">sicp-common::arena</code> Module<a class="copiable-link" href="#The-sicp_002dcommon_003a_003aarena-Module"> &#182;</a></span></h4>

<p>The SICP Rust repository provides a production-ready arena implementation in the
<code class="code">sicp-common</code> crate. The full implementation includes additional features:
</p>
<div class="example">
<pre class="example-preformatted"><a class="index-entry-id" id="index-sicp_002dcommon-crate"></a>use sicp_common::arena::{Arena, ArenaId};

// Create an arena for your node type
let mut arena: Arena&lt;Node&gt; = Arena::new();

// Allocate nodes
let id1 = arena.alloc(Node { value: 1, next: None });
let id2 = arena.alloc(Node { value: 2, next: Some(id1) });

// Access nodes
let node = arena.get(id1);
arena.get_mut(id2).next = Some(id1);

// Iterate over all nodes
for node in arena.iter() {
    println!(&quot;Value: {}&quot;, node.value);
}

// Iterate with IDs
for (id, node) in arena.iter_with_ids() {
    println!(&quot;Node {}: {}&quot;, id.index(), node.value);
}
</pre></div>

<p>The implementation in <code class="code">rust-examples/sicp-common/src/arena.rs</code> demonstrates
how to build robust, zero-cost abstractions. Study it to see how type parameters,
trait implementations, and careful API design create a safe, ergonomic interface
to what is essentially a fancy <code class="code">Vec</code>.
</p>
<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-3_002e28a"></a>Exercise 3.28a:</strong> Implement a <code class="code">Graph</code>
structure using the arena pattern for representing directed graphs. Your
implementation should support:
</p>
<ol class="enumerate">
<li> Adding nodes with associated data
</li><li> Adding directed edges between nodes
</li><li> Traversing from a node to its neighbors
</li><li> Detecting cycles using depth-first search
</li></ol>

<div class="example">
<pre class="example-preformatted">struct Node&lt;T&gt; {
    data: T,
    edges: Vec&lt;ArenaId&lt;Node&lt;T&gt;&gt;&gt;,
}

struct Graph&lt;T&gt; {
    arena: Arena&lt;Node&lt;T&gt;&gt;,
}

impl&lt;T&gt; Graph&lt;T&gt; {
    fn new() -&gt; Self { /* ... */ }

    fn add_node(&amp;mut self, data: T) -&gt; ArenaId&lt;Node&lt;T&gt;&gt; { /* ... */ }

    fn add_edge(&amp;mut self, from: ArenaId&lt;Node&lt;T&gt;&gt;, to: ArenaId&lt;Node&lt;T&gt;&gt;) { /* ... */ }

    fn neighbors(&amp;self, node: ArenaId&lt;Node&lt;T&gt;&gt;) -&gt; &amp;[ArenaId&lt;Node&lt;T&gt;&gt;] { /* ... */ }

    fn has_cycle(&amp;self) -&gt; bool { /* ... */ }
}
</pre></div>

<p>Test your implementation by creating a graph with a cycle and verifying that
<code class="code">has_cycle</code> detects it. Then create an acyclic graph and verify it returns
false.
</p></blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-3_002e28b"></a>Exercise 3.28b:</strong> The circuit simulator uses
<code class="code">Vec&lt;GateId&gt;</code> in the <code class="code">Wire</code> structure to track which gates need
notification when a wire&#8217;s signal changes. This requires cloning the vector
before iterating (to avoid borrowing issues). Propose and implement an
alternative design that avoids this allocation.
</p>
<p>Consider these approaches:
</p>
<ol class="enumerate" type="a" start="1">
<li> Store gates in the arena and give each gate a list of output wires, rather
than wires tracking connected gates.

</li><li> Use a separate event queue that stores gate IDs to process, populated by
wire signal changes.

</li><li> Use indices into a separate <code class="code">Vec&lt;(WireId, GateId)&gt;</code> connection table.
</li></ol>

<p>Implement one approach and compare its performance characteristics (allocations,
cache locality, code complexity) to the original design. Which would you choose
for a production circuit simulator?
</p></blockquote>

<p>The arena pattern demonstrates a fundamental principle in systems programming:
sometimes the right abstraction requires trading one kind of safety for another.
The borrow checker&#8217;s safety is unparalleled for tree-like structures with clear
ownership hierarchies. But for graphs, where ownership is inherently shared and
cyclic, indices into an arena provide a different kind of safety: bounds-checked
array access, deterministic deallocation, and freedom from the lifetime puzzles
that plague graph structures in Rust.
</p>
<p>By understanding both approaches&#8212;and knowing when to use each&#8212;we gain the
flexibility to build complex systems that are both safe and efficient, letting
the type system help us where it can and stepping outside it judiciously when
necessary.
</p>
<hr />
</div>
<div class="subsection-level-extent" id="g_t3_002e3_002e5">
<h4 class="subsection" id="Propagation-of-Constraints"><span>3.3.6 Propagation of Constraints<a class="copiable-link" href="#Propagation-of-Constraints"> &#182;</a></span></h4>

<p>Computer programs are traditionally organized as one-directional computations,
which perform operations on prespecified arguments to produce desired outputs.
On the other hand, we often model systems in terms of relations among
quantities.  For example, a mathematical model of a mechanical structure might
include the information that the deflection <em class="math">d</em> of a metal rod is related to
the force <em class="math">F</em> on the rod, the length <em class="math">L</em> of the rod, the cross-sectional
area <em class="math">A</em>, and the elastic modulus <em class="math">E</em> via the equation
\[ % :61:
  {dAE} \,=\, {FL.}  \]
Such an equation is not one-directional.  Given any four of the quantities, we
can use it to compute the fifth.  Yet translating the equation into a
traditional computer language would force us to choose one of the quantities to
be computed in terms of the other four.  Thus, a procedure for computing the
area <em class="math">A</em> could not be used to compute the deflection <em class="math">d</em>, even though the
computations of <em class="math">A</em> and <em class="math">d</em> arise from the same
equation.<a class="footnote" id="DOCF150" href="#FOOT150"><sup>150</sup></a>
</p>
<p>In this section, we sketch the design of a language that enables us to work in
terms of relations themselves.  The primitive elements of the language are
<a class="index-entry-id" id="index-primitive-constraints"></a>
<em class="dfn">primitive constraints</em>, which state that certain relations hold
between quantities.  For example, <code class="code">(adder a b c)</code> specifies that the
quantities <em class="math">a</em>, <em class="math">b</em>, and <em class="math">c</em> must be related by the equation 
<em class="math">{a + b = c}</em>, <code class="code">(multiplier x y z)</code> expresses the constraint 
<em class="math">{xy = z}</em>, and <code class="code">(constant 3.14 x)</code> says that the value of <em class="math">x</em> must be 3.14.
</p>
<p>Our language provides a means of combining primitive constraints in order to
express more complex relations.  We combine constraints by constructing
<a class="index-entry-id" id="index-constraint-networks"></a>
<em class="dfn">constraint networks</em>, in which constraints are joined by
<a class="index-entry-id" id="index-connectors"></a>
<em class="dfn">connectors</em>.  A connector is an object that &#8220;holds&#8221; a value that may
participate in one or more constraints.  For example, we know that the
relationship between Fahrenheit and Celsius temperatures is
\[ % :62:
  {9C} \,=\, {5(F - 32).}  \]
Such a constraint can be thought of as a network consisting of primitive adder,
multiplier, and constant constraints (<a class="ref" href="#Figure-3_002e28">Figure 3.28</a>).  In the figure, we
see on the left a multiplier box with three terminals, labeled <em class="math">{m1}</em>, <em class="math">{m2}</em>,
and <em class="math">p</em>.  These connect the multiplier to the rest of the network as follows:
The <em class="math">{m1}</em> terminal is linked to a connector <em class="math">C</em>, which will hold the Celsius
temperature.  The <em class="math">{m2}</em> terminal is linked to a connector <em class="math">w</em>, which is also
linked to a constant box that holds 9.  The <em class="math">p</em> terminal, which the
multiplier box constrains to be the product of <em class="math">{m1}</em> and <em class="math">{m2}</em>, is linked to
the <em class="math">p</em> terminal of another multiplier box, whose <em class="math">{m2}</em> is connected to a
constant 5 and whose <em class="math">{m1}</em> is connected to one of the terms in a sum.
</p>
<div class="float">
<a class="anchor" id="Figure-3_002e28"></a><img class="image" src="fig/chap3/Fig3.28.std.svg" alt="fig/chap3/Fig3.28" />
<div class="caption"><p><strong class="strong">Figure 3.28:</strong> The relation <em class="math">{9C = 5(F - 32)}</em> expressed as a constraint network.</p></div></div>
<p>Computation by such a network proceeds as follows: When a connector is given a
value (by the user or by a constraint box to which it is linked), it awakens
all of its associated constraints (except for the constraint that just awakened
it) to inform them that it has a value.  Each awakened constraint box then
polls its connectors to see if there is enough information to determine a value
for a connector.  If so, the box sets that connector, which then awakens all of
its associated constraints, and so on.  For instance, in conversion between
Celsius and Fahrenheit, <em class="math">w</em>, <em class="math">x</em>, and <em class="math">y</em> are immediately set by the
constant boxes to 9, 5, and 32, respectively.  The connectors awaken the
multipliers and the adder, which determine that there is not enough information
to proceed.  If the user (or some other part of the network) sets <em class="math">C</em> to a
value (say 25), the leftmost multiplier will be awakened, and it will set <em class="math">u</em>
to <em class="math">{25 \cdot 9 = 225}</em>.  Then <em class="math">u</em> awakens the second multiplier, which sets <em class="math">v</em> to
45, and <em class="math">v</em> awakens the adder, which sets <em class="math">f</em> to 77.
</p>
<h4 class="subsubheading" id="Using-the-constraint-system"><span>Using the constraint system<a class="copiable-link" href="#Using-the-constraint-system"> &#182;</a></span></h4>

<p>To use the constraint system to carry out the temperature computation outlined
above, we first create two connectors, <code class="code">C</code> and <code class="code">F</code>, by calling the
constructor <code class="code">make_connector</code>, and link <code class="code">C</code> and <code class="code">F</code> in an
appropriate network:
</p>
<div class="example">
<pre class="example-preformatted">let mut network = ConstraintNetwork::new();
let c = network.make_connector();
let f = network.make_connector();
celsius_fahrenheit_converter(&amp;mut network, c, f);
</pre></div>

<p>The procedure that creates the network is defined as follows:
</p>
<div class="example">
<pre class="example-preformatted">fn celsius_fahrenheit_converter(
    network: &amp;mut ConstraintNetwork,
    c: ConnectorId,
    f: ConnectorId
) {
    let u = network.make_connector();
    let v = network.make_connector();
    let w = network.make_connector();
    let x = network.make_connector();
    let y = network.make_connector();

    network.multiplier(c, w, u);  // c * w = u
    network.multiplier(v, x, u);  // v * x = u
    network.adder(v, y, f);       // v + y = f
    network.constant(9.0, w);
    network.constant(5.0, x);
    network.constant(32.0, y);
}
</pre></div>

<p>This procedure creates the internal connectors <code class="code">u</code>, <code class="code">v</code>, <code class="code">w</code>,
<code class="code">x</code>, and <code class="code">y</code>, and links them as shown in <a class="ref" href="#Figure-3_002e28">Figure 3.28</a> using the
primitive constraint constructors <code class="code">adder</code>, <code class="code">multiplier</code>, and
<code class="code">constant</code>.  Just as with the digital-circuit simulator of 
<a class="ref" href="#g_t3_002e3_002e4">A Simulator for Digital Circuits</a>, expressing these combinations of primitive elements in terms of
procedures automatically provides our language with a means of abstraction for
compound objects.
</p>
<p>To watch the network in action, we can place probes on the connectors <code class="code">C</code>
and <code class="code">F</code>, using a <code class="code">probe</code> procedure similar to the one we used to
monitor wires in <a class="ref" href="#g_t3_002e3_002e4">A Simulator for Digital Circuits</a>.  Placing a probe on a connector will
cause a message to be printed whenever the connector is given a value:
</p>
<div class="example">
<pre class="example-preformatted">network.probe(&quot;Celsius temp&quot;, c);
network.probe(&quot;Fahrenheit temp&quot;, f);
</pre></div>

<p>Next we set the value of <code class="code">C</code> to 25.  (The third argument to
<code class="code">set-value!</code> tells <code class="code">C</code> that this directive comes from the
<code class="code">user</code>.)
</p>
<div class="example">
<pre class="example-preformatted">network.set_value(c, 25.0, Informant::User)?;
// =&gt; Probe: Celsius temp = 25
// =&gt; Probe: Fahrenheit temp = 77
</pre></div>

<p>The probe on <code class="code">C</code> awakens and reports the value.  <code class="code">C</code> also propagates
its value through the network as described above.  This sets <code class="code">F</code> to 77,
which is reported by the probe on <code class="code">F</code>.
</p>
<p>Now we can try to set <code class="code">F</code> to a new value, say 212:
</p>
<div class="example">
<pre class="example-preformatted">network.set_value(f, 212.0, Informant::User);
// =&gt; Err(Contradiction { current: 77.0, new: 212.0 })
</pre></div>

<p>The connector complains that it has sensed a contradiction: Its value is 77,
and someone is trying to set it to 212.  If we really want to reuse the network
with new values, we can tell <code class="code">C</code> to forget its old value:
</p>
<div class="example">
<pre class="example-preformatted">network.forget_value(c, Informant::User);
// =&gt; Probe: Celsius temp = ?
// =&gt; Probe: Fahrenheit temp = ?
</pre></div>

<p><code class="code">C</code> finds that the <code class="code">user</code>, who set its value originally, is now
retracting that value, so <code class="code">C</code> agrees to lose its value, as shown by the
probe, and informs the rest of the network of this fact.  This information
eventually propagates to <code class="code">F</code>, which now finds that it has no reason for
continuing to believe that its own value is 77.  Thus, <code class="code">F</code> also gives up
its value, as shown by the probe.
</p>
<p>Now that <code class="code">F</code> has no value, we are free to set it to 212:
</p>
<div class="example">
<pre class="example-preformatted">network.set_value(f, 212.0, Informant::User)?;
// =&gt; Probe: Fahrenheit temp = 212
// =&gt; Probe: Celsius temp = 100
</pre></div>

<p>This new value, when propagated through the network, forces <code class="code">C</code> to have a
value of 100, and this is registered by the probe on <code class="code">C</code>.  Notice that the
very same network is being used to compute <code class="code">C</code> given <code class="code">F</code> and to
compute <code class="code">F</code> given <code class="code">C</code>.  This nondirectionality of computation is the
distinguishing feature of constraint-based systems.
</p>
<h4 class="subsubheading" id="Implementing-the-constraint-system"><span>Implementing the constraint system<a class="copiable-link" href="#Implementing-the-constraint-system"> &#182;</a></span></h4>

<p>The constraint system is implemented via procedural objects with local state,
in a manner very similar to the digital-circuit simulator of 
<a class="ref" href="#g_t3_002e3_002e4">A Simulator for Digital Circuits</a>.  Although the primitive objects of the constraint system are
somewhat more complex, the overall system is simpler, since there is no concern
about agendas and logic delays.
</p>
<p>The basic operations on connectors are the following:
</p>
<ul class="itemize mark-bullet">
<li><code class="code">(has-value? ⟨<var class="var">connector</var>⟩)</code> tells whether the connector has a value.

</li><li><code class="code">(get-value ⟨<var class="var">connector</var>⟩)</code> returns the connector&#8217;s current value.

</li><li><code class="code">(set-value! ⟨<var class="var">connector</var>⟩ ⟨<var class="var">new-value</var>⟩ ⟨<var class="var">informant</var>⟩)</code>
indicates that the informant is requesting the connector to set its value to
the new value.

</li><li><code class="code">(forget-value! ⟨<var class="var">connector</var>⟩ ⟨<var class="var">retractor</var>⟩)</code> tells the connector
that the retractor is requesting it to forget its value.

</li><li><code class="code">(connect ⟨<var class="var">connector</var>⟩ ⟨<var class="var">new-constraint</var>⟩)</code> tells the connector
to participate in the new constraint.

</li></ul>

<p>The connectors communicate with the constraints by means of the procedures
<code class="code">inform-about-value</code>, which tells the given constraint that the connector
has a value, and <code class="code">inform-about-no-value</code>, which tells the constraint that
the connector has lost its value.
</p>
<p><code class="code">Adder</code> constructs an adder constraint among summand connectors <code class="code">a1</code>
and <code class="code">a2</code> and a <code class="code">sum</code> connector.  An adder is implemented as a
procedure with local state (the procedure <code class="code">me</code> below):
</p>
<div class="example">
<pre class="example-preformatted">struct Adder {
    a1: ConnectorId,
    a2: ConnectorId,
    sum: ConnectorId,
}

impl Constraint for Adder {
    fn process_new_value(&amp;self, network: &amp;mut ConstraintNetwork) {
        let a1_val = network.get_value(self.a1);
        let a2_val = network.get_value(self.a2);
        let sum_val = network.get_value(self.sum);

        match (a1_val, a2_val, sum_val) {
            (Some(a1), Some(a2), None) =&gt; {
                network.set_value(self.sum, a1 + a2, self.id());
            }
            (Some(a1), None, Some(sum)) =&gt; {
                network.set_value(self.a2, sum - a1, self.id());
            }
            (None, Some(a2), Some(sum)) =&gt; {
                network.set_value(self.a1, sum - a2, self.id());
            }
            _ =&gt; {} // Not enough information
        }
    }

    fn process_forget_value(&amp;self, network: &amp;mut ConstraintNetwork) {
        network.forget_value(self.sum, self.id());
        network.forget_value(self.a1, self.id());
        network.forget_value(self.a2, self.id());
        self.process_new_value(network);
    }
}
</pre></div>

<p><code class="code">Adder</code> connects the new adder to the designated connectors and returns it
as its value.  The procedure <code class="code">me</code>, which represents the adder, acts as a
dispatch to the local procedures.  The following &#8220;syntax interfaces&#8221; (see
<a class="ref" href="#Footnote-155">Footnote 155</a> in <a class="ref" href="#g_t3_002e3_002e4">A Simulator for Digital Circuits</a>) are used in conjunction with
the dispatch:
</p>
<div class="example">
<pre class="example-preformatted">// In Rust, constraints implement a trait with these methods:
trait Constraint {
    fn process_new_value(&amp;self, network: &amp;mut ConstraintNetwork);
    fn process_forget_value(&amp;self, network: &amp;mut ConstraintNetwork);
}
// The network calls constraint.process_new_value() or
// constraint.process_forget_value() directly.
</pre></div>

<p>The adder&#8217;s local procedure <code class="code">process-new-value</code> is called when the adder
is informed that one of its connectors has a value. The adder first checks to
see if both <code class="code">a1</code> and <code class="code">a2</code> have values. If so, it tells <code class="code">sum</code> to
set its value to the sum of the two addends.  The <code class="code">informant</code> argument to
<code class="code">set-value!</code> is <code class="code">me</code>, which is the adder object itself.  If <code class="code">a1</code>
and <code class="code">a2</code> do not both have values, then the adder checks to see if perhaps
<code class="code">a1</code> and <code class="code">sum</code> have values.  If so, it sets <code class="code">a2</code> to the
difference of these two.  Finally, if <code class="code">a2</code> and <code class="code">sum</code> have values,
this gives the adder enough information to set <code class="code">a1</code>.  If the adder is told
that one of its connectors has lost a value, it requests that all of its
connectors now lose their values.  (Only those values that were set by this
adder are actually lost.)  Then it runs <code class="code">process-new-value</code>.  The reason
for this last step is that one or more connectors may still have a value (that
is, a connector may have had a value that was not originally set by the adder),
and these values may need to be propagated back through the adder.
</p>
<p>A multiplier is very similar to an adder. It will set its <code class="code">product</code> to 0
if either of the factors is 0, even if the other factor is not known.
</p>
<div class="example">
<pre class="example-preformatted">struct Multiplier {
    m1: ConnectorId,
    m2: ConnectorId,
    product: ConnectorId,
}

impl Constraint for Multiplier {
    fn process_new_value(&amp;self, network: &amp;mut ConstraintNetwork) {
        let m1_val = network.get_value(self.m1);
        let m2_val = network.get_value(self.m2);
        let prod_val = network.get_value(self.product);

        // If either factor is 0, product is 0
        if m1_val == Some(0.0) || m2_val == Some(0.0) {
            network.set_value(self.product, 0.0, self.id());
            return;
        }

        match (m1_val, m2_val, prod_val) {
            (Some(m1), Some(m2), None) =&gt; {
                network.set_value(self.product, m1 * m2, self.id());
            }
            (Some(m1), None, Some(p)) =&gt; {
                network.set_value(self.m2, p / m1, self.id());
            }
            (None, Some(m2), Some(p)) =&gt; {
                network.set_value(self.m1, p / m2, self.id());
            }
            _ =&gt; {}
        }
    }

    fn process_forget_value(&amp;self, network: &amp;mut ConstraintNetwork) {
        network.forget_value(self.product, self.id());
        network.forget_value(self.m1, self.id());
        network.forget_value(self.m2, self.id());
        self.process_new_value(network);
    }
}
</pre></div>

<p>A <code class="code">constant</code> constructor simply sets the value of the designated
connector.  Any <code class="code">I-have-a-value</code> or <code class="code">I-lost-my-value</code> message sent to
the constant box will produce an error.
</p>
<div class="example">
<pre class="example-preformatted">impl ConstraintNetwork {
    fn constant(&amp;mut self, value: f64, connector: ConnectorId) {
        // Constants set the connector's value immediately
        // and cannot be changed - no constraint object needed
        self.set_value(connector, value, Informant::Constant);
    }
}
</pre></div>

<p>Finally, a probe prints a message about the setting or unsetting of
the designated connector:
</p>
<div class="example">
<pre class="example-preformatted">struct Probe {
    name: String,
    connector: ConnectorId,
}

impl Constraint for Probe {
    fn process_new_value(&amp;self, network: &amp;mut ConstraintNetwork) {
        if let Some(value) = network.get_value(self.connector) {
            println!(&quot;Probe: {} = {}&quot;, self.name, value);
        }
    }

    fn process_forget_value(&amp;self, _network: &amp;mut ConstraintNetwork) {
        println!(&quot;Probe: {} = ?&quot;, self.name);
    }
}
</pre></div>

<h4 class="subsubheading" id="Representing-connectors"><span>Representing connectors<a class="copiable-link" href="#Representing-connectors"> &#182;</a></span></h4>

<p>A connector is represented as a procedural object with local state variables
<code class="code">value</code>, the current value of the connector; <code class="code">informant</code>, the object
that set the connector&#8217;s value; and <code class="code">constraints</code>, a list of the
constraints in which the connector participates.
</p>
<div class="example">
<pre class="example-preformatted">struct Connector {
    value: Option&lt;f64&gt;,
    informant: Option&lt;Informant&gt;,
    constraints: Vec&lt;ConstraintId&gt;,
}

impl Connector {
    fn new() -&gt; Self {
        Connector {
            value: None,
            informant: None,
            constraints: Vec::new(),
        }
    }

    fn has_value(&amp;self) -&gt; bool {
        self.value.is_some()
    }

    fn get_value(&amp;self) -&gt; Option&lt;f64&gt; {
        self.value
    }

    fn set_value(
        &amp;mut self,
        new_val: f64,
        setter: Informant
    ) -&gt; Result&lt;(), Contradiction&gt; {
        match self.value {
            None =&gt; {
                self.value = Some(new_val);
                self.informant = Some(setter);
                Ok(())
            }
            Some(current) if (current - new_val).abs() &lt; 1e-10 =&gt; {
                Ok(()) // Same value, ignore
            }
            Some(current) =&gt; {
                Err(Contradiction { current, new: new_val })
            }
        }
    }

    fn forget_value(&amp;mut self, retractor: Informant) {
        if self.informant == Some(retractor) {
            self.value = None;
            self.informant = None;
        }
    }
}
</pre></div>

<p>The connector&#8217;s local procedure <code class="code">set-my-value</code> is called when there is a
request to set the connector&#8217;s value.  If the connector does not currently have
a value, it will set its value and remember as <code class="code">informant</code> the constraint
that requested the value to be set.<a class="footnote" id="DOCF151" href="#FOOT151"><sup>151</sup></a>  Then the connector will notify all of its participating
constraints except the constraint that requested the value to be set.  This is
accomplished using the following iterator, which applies a designated procedure
to all items in a list except a given one:
</p>
<div class="example">
<pre class="example-preformatted">fn for_each_except&lt;T, F&gt;(exception: T, procedure: F, items: &amp;[T])
where
    T: PartialEq,
    F: Fn(&amp;T),
{
    for item in items {
        if item != &amp;exception {
            procedure(item);
        }
    }
}
</pre></div>

<p>If a connector is asked to forget its value, it runs the local procedure
<code class="code">forget-my-value</code>, which first checks to make sure that the request is
coming from the same object that set the value originally.  If so, the
connector informs its associated constraints about the loss of the value.
</p>
<p>The local procedure <code class="code">connect</code> adds the designated new constraint to the
list of constraints if it is not already in that list.  Then, if the connector
has a value, it informs the new constraint of this fact.
</p>
<p>The connector&#8217;s procedure <code class="code">me</code> serves as a dispatch to the other internal
procedures and also represents the connector as an object.  The following
procedures provide a syntax interface for the dispatch:
</p>
<div class="example">
<pre class="example-preformatted">// In Rust, these are method calls on the network:
impl ConstraintNetwork {
    fn has_value(&amp;self, conn: ConnectorId) -&gt; bool {
        self.connectors[conn].has_value()
    }

    fn get_value(&amp;self, conn: ConnectorId) -&gt; Option&lt;f64&gt; {
        self.connectors[conn].get_value()
    }

    fn set_value(&amp;mut self, conn: ConnectorId, val: f64, inf: Informant)
        -&gt; Result&lt;(), Contradiction&gt;
    {
        self.connectors[conn].set_value(val, inf)
    }

    fn forget_value(&amp;mut self, conn: ConnectorId, ret: Informant) {
        self.connectors[conn].forget_value(ret);
    }
}
</pre></div>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-3_002e33"></a>Exercise 3.33:</strong> Using primitive multiplier,
adder, and constant constraints, define a procedure <code class="code">averager</code> that takes
three connectors <code class="code">a</code>, <code class="code">b</code>, and <code class="code">c</code> as inputs and establishes the
constraint that the value of <code class="code">c</code> is the average of the values of <code class="code">a</code>
and <code class="code">b</code>.
</p></blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-3_002e34"></a>Exercise 3.34:</strong> Louis Reasoner wants to build a
squarer, a constraint device with two terminals such that the value of
connector <code class="code">b</code> on the second terminal will always be the square of the
value <code class="code">a</code> on the first terminal.  He proposes the following simple device
made from a multiplier:
</p>
<div class="example">
<pre class="example-preformatted">fn squarer(network: &amp;mut ConstraintNetwork, a: ConnectorId, b: ConnectorId) {
    network.multiplier(a, a, b);
}
</pre></div>

<p>There is a serious flaw in this idea.  Explain.
</p></blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-3_002e35"></a>Exercise 3.35:</strong> Ben Bitdiddle tells Louis that
one way to avoid the trouble in <a class="ref" href="#Exercise-3_002e34">Exercise 3.34</a> is to define a squarer as a
new primitive constraint.  Fill in the missing portions in Ben&#8217;s outline for a
procedure to implement such a constraint:
</p>
<div class="example">
<pre class="example-preformatted">struct Squarer {
    a: ConnectorId,
    b: ConnectorId,
}

impl Constraint for Squarer {
    fn process_new_value(&amp;self, network: &amp;mut ConstraintNetwork) {
        if let Some(b_val) = network.get_value(self.b) {
            if b_val &lt; 0.0 {
                panic!(&quot;square less than 0: SQUARER {}&quot;, b_val);
            }
            <span class="r">&lt;alternative1&gt;</span>  // set a to sqrt(b)
        } else {
            <span class="r">&lt;alternative2&gt;</span>  // if a has value, set b
        }
    }

    fn process_forget_value(&amp;self, network: &amp;mut ConstraintNetwork) {
        <span class="r">&lt;body1&gt;</span>
    }
}
<span class="r">&lt;rest of definition&gt;</span>
</pre></div>
</blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-3_002e36"></a>Exercise 3.36:</strong> Suppose we evaluate the following
sequence of expressions in the global environment:
</p>
<div class="example">
<pre class="example-preformatted">let mut network = ConstraintNetwork::new();
let a = network.make_connector();
let b = network.make_connector();
network.set_value(a, 10.0, Informant::User)?;
</pre></div>

<p>At some time during evaluation of the <code class="code">set-value!</code>, the following
expression from the connector&#8217;s local procedure is evaluated:
</p>
<div class="example">
<pre class="example-preformatted">for_each_except(setter, inform_about_value, &amp;constraints);
</pre></div>

<p>Draw an environment diagram showing the environment in which the above
expression is evaluated.
</p></blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-3_002e37"></a>Exercise 3.37:</strong> The
<code class="code">celsius-fahrenheit-converter</code> procedure is cumbersome when compared with
a more expression-oriented style of definition, such as
</p>
<div class="example">
<pre class="example-preformatted">fn celsius_fahrenheit_converter(
    network: &amp;mut ConstraintNetwork,
    x: ConnectorId
) -&gt; ConnectorId {
    c_add(network,
        c_mul(network,
            c_div(network, cv(network, 9.0), cv(network, 5.0)),
            x),
        cv(network, 32.0))
}

let mut network = ConstraintNetwork::new();
let c = network.make_connector();
let f = celsius_fahrenheit_converter(&amp;mut network, c);
</pre></div>

<p>Here <code class="code">c+</code>, <code class="code">c*</code>, etc. are the &#8220;constraint&#8221; versions of the
arithmetic operations.  For example, <code class="code">c+</code> takes two connectors as
arguments and returns a connector that is related to these by an adder
constraint:
</p>
<div class="example">
<pre class="example-preformatted">fn c_add(
    network: &amp;mut ConstraintNetwork,
    x: ConnectorId,
    y: ConnectorId
) -&gt; ConnectorId {
    let z = network.make_connector();
    network.adder(x, y, z);
    z
}
</pre></div>

<p>Define analogous procedures <code class="code">c-</code>, <code class="code">c*</code>, <code class="code">c/</code>, and <code class="code">cv</code>
(constant value) that enable us to define compound constraints as in the
converter example above.<a class="footnote" id="DOCF152" href="#FOOT152"><sup>152</sup></a>
</p></blockquote>

</div>
</div>
<div class="footnotes-segment">
<hr />
<h4 class="footnotes-heading">Footnotes</h4>

<h5 class="footnote-body-heading"><a id="FOOT137" href="#DOCF137">(137)</a></h5>
<p><code class="code">set_car</code> and
<code class="code">set_cdr</code> return the unit type <code class="code">()</code>. Like assignment, they
should be used only for their effect.</p>
<h5 class="footnote-body-heading"><a id="FOOT138" href="#DOCF138">(138)</a></h5>
<p>We see from
this that mutation operations on lists can create &#8220;garbage&#8221; that is not part
of any accessible structure.  We will see in <a class="ref" href="5_002e3.xhtml#g_t5_002e3_002e2">Maintaining the Illusion of Infinite Memory</a> that dynamic
memory-management systems include a <a class="index-entry-id" id="index-garbage-collector"></a>
<em class="dfn">garbage collector</em>, which
identifies and recycles the memory space used by unneeded pairs.</p>
<h5 class="footnote-body-heading"><a id="FOOT139" href="#DOCF139">(139)</a></h5>
<p><code class="code">Get-new-pair</code> is one of the operations that
must be implemented as part of the memory management required by a Lisp
implementation.  We will discuss this in <a class="ref" href="5_002e3.xhtml#g_t5_002e3_002e1">Memory as Vectors</a>.</p>
<h5 class="footnote-body-heading"><a id="FOOT140" href="#DOCF140">(140)</a></h5>
<p>The two pairs are distinct
because each call to <code class="code">cons</code> returns a new pair.  The symbols are shared;
in Scheme there is a unique symbol with any given name.  Since Scheme provides
no way to mutate a symbol, this sharing is undetectable.  Note also that the
sharing is what enables us to compare symbols using <code class="code">eq?</code>, which simply
checks equality of pointers.</p>
<h5 class="footnote-body-heading"><a id="FOOT141" href="#DOCF141">(141)</a></h5>
<p>The subtleties of
dealing with sharing of mutable data objects reflect the underlying issues of
&#8220;sameness&#8221; and &#8220;change&#8221; that were raised in <a class="ref" href="3_002e1.xhtml#g_t3_002e1_002e3">The Costs of Introducing Assignment</a>.  We
mentioned there that admitting change to our language requires that a compound
object must have an &#8220;identity&#8221; that is something different from the pieces
from which it is composed.  In Lisp, we consider this &#8220;identity&#8221; to be the
quality that is tested by <code class="code">eq?</code>, i.e., by equality of pointers.  Since in
most Lisp implementations a pointer is essentially a memory address, we are
&#8220;solving the problem&#8221; of defining the identity of objects by stipulating that
a data object &#8220;itself&#8221; is the information stored in some particular set of
memory locations in the computer.  This suffices for simple Lisp programs, but
is hardly a general way to resolve the issue of &#8220;sameness&#8221; in computational
models.</p>
<h5 class="footnote-body-heading"><a id="FOOT142" href="#DOCF142">(142)</a></h5>
<p>On
the other hand, from the viewpoint of implementation, assignment requires us to
modify the environment, which is itself a mutable data structure.  Thus,
assignment and mutation are equipotent: Each can be implemented in terms of the
other.</p>
<h5 class="footnote-body-heading"><a id="FOOT143" href="#DOCF143">(143)</a></h5>
<p>If the first item is the final item in the queue, the front
pointer will be the empty list after the deletion, which will mark the queue as
empty; we needn&#8217;t worry about updating the rear pointer, which will still point
to the deleted item, because <code class="code">empty-queue?</code> looks only at the front
pointer.</p>
<h5 class="footnote-body-heading"><a id="FOOT144" href="#DOCF144">(144)</a></h5>
<p>Be careful not to make the
interpreter try to print a structure that contains cycles.  (See <a class="ref" href="#Exercise-3_002e13">Exercise 3.13</a>.)</p>
<h5 class="footnote-body-heading"><a id="FOOT145" href="#DOCF145">(145)</a></h5>
<p>A full-adder is a basic circuit element used in adding
two binary numbers.  Here A and B are the bits at corresponding positions in
the two numbers to be added, and <em class="math">\rm C_{in}</em> is the carry bit from the
addition one place to the right.  The circuit generates SUM, which is the sum
bit in the corresponding position, and <em class="math">\rm C_{out}</em>, which is the carry
bit to be propagated to the left.</p>
<h5 class="footnote-body-heading"><a id="FOOT146" href="#DOCF146">(146)</a></h5>
<a class="anchor" id="Footnote-155"></a><p>These procedures are simply
syntactic sugar that allow us to use ordinary procedural syntax to access the
local procedures of objects.  It is striking that we can interchange the role
of &#8220;procedures&#8221; and &#8220;data&#8221; in such a simple way.  For example, if we write
<code class="code">(wire 'get-signal)</code> we think of <code class="code">wire</code> as a procedure that is called
with the message <code class="code">get_signal</code> as input.  Alternatively, writing
<code class="code">(get-signal wire)</code> encourages us to think of <code class="code">wire</code> as a data object
that is the input to a procedure <code class="code">get_signal</code>.  The truth of the matter is
that, in a language in which we can deal with procedures as objects, there is
no fundamental difference between &#8220;procedures&#8221; and &#8220;data,&#8221; and we can
choose our syntactic sugar to allow us to program in whatever style we choose.</p>
<h5 class="footnote-body-heading"><a id="FOOT147" href="#DOCF147">(147)</a></h5>
<p>The agenda is a headed list, like the tables in 
<a class="ref" href="#g_t3_002e3_002e3">Representing Tables</a>, but since the list is headed by the time, we do not need an
additional dummy header (such as the <code class="code">*table*</code> symbol used with tables).</p>
<h5 class="footnote-body-heading"><a id="FOOT148" href="#DOCF148">(148)</a></h5>
<p>Observe
that the <code class="code">if</code> expression in this procedure has no <code class="code">⟨</code><var class="var">alternative</var><code class="code">⟩</code>
expression.  Such a &#8220;one-armed <code class="code">if</code> statement&#8221; is used to decide whether
to do something, rather than to select between two expressions.  An <code class="code">if</code>
expression returns an unspecified value if the predicate is false and there is
no <code class="code">⟨</code><var class="var">alternative</var><code class="code">⟩</code>.</p>
<h5 class="footnote-body-heading"><a id="FOOT149" href="#DOCF149">(149)</a></h5>
<p>In this way, the current time will always be the time of the
action most recently processed.  Storing this time at the head of the agenda
ensures that it will still be available even if the associated time segment has
been deleted.</p>
<h5 class="footnote-body-heading"><a id="FOOT150" href="#DOCF150">(150)</a></h5>
<p>Constraint propagation first appeared in the incredibly
forward-looking <abbr class="abbr">SKETCHPAD</abbr> system of Ivan <a class="ref" href="References.xhtml#Sutherland-_00281963_0029">Sutherland (1963)</a>.  A
beautiful constraint-propagation system based on the Smalltalk language was
developed by Alan <a class="ref" href="References.xhtml#Borning-_00281977_0029">Borning (1977)</a> at Xerox Palo Alto Research Center.  Sussman,
Stallman, and Steele applied constraint propagation to electrical circuit
analysis (<a class="ref" href="References.xhtml#Sussman-and-Stallman-1975">Sussman and Stallman 1975</a>; <a class="ref" href="References.xhtml#Sussman-and-Steele-1980">Sussman and Steele 1980</a>). TK!Solver
(<a class="ref" href="References.xhtml#Konopasek-and-Jayaraman-1984">Konopasek and Jayaraman 1984</a>) is an extensive modeling environment based on
constraints.</p>
<h5 class="footnote-body-heading"><a id="FOOT151" href="#DOCF151">(151)</a></h5>
<p>The <code class="code">setter</code> might not be a
constraint.  In our temperature example, we used <code class="code">user</code> as the
<code class="code">setter</code>.</p>
<h5 class="footnote-body-heading"><a id="FOOT152" href="#DOCF152">(152)</a></h5>
<p>The expression-oriented format is convenient
because it avoids the need to name the intermediate expressions in a
computation.  Our original formulation of the constraint language is cumbersome
in the same way that many languages are cumbersome when dealing with operations
on compound data.  For example, if we wanted to compute the product 
<em class="math">{(a + b) \cdot (c + d)}</em>, where the variables represent vectors, we could work
in &#8220;imperative style,&#8221; using procedures that set the values of designated
vector arguments but do not themselves return vectors as values:
</p>
<div class="example">
<pre class="example-preformatted">let temp1 = v_sum(&amp;a, &amp;b);
let temp2 = v_sum(&amp;c, &amp;d);
let answer = v_prod(&amp;temp1, &amp;temp2);
</pre></div>

<p>Alternatively, we could deal with expressions, using procedures that return
vectors as values, and thus avoid explicitly mentioning <code class="code">temp1</code> and
<code class="code">temp2</code>:
</p>
<div class="example">
<pre class="example-preformatted">let answer = v_prod(v_sum(&amp;a, &amp;b), v_sum(&amp;c, &amp;d));
</pre></div>

<p>Since Lisp allows us to return compound objects as values of procedures, we can
transform our imperative-style constraint language into an expression-oriented
style as shown in this exercise.  In languages that are impoverished in
handling compound objects, such as Algol, Basic, and Pascal (unless one
explicitly uses Pascal pointer variables), one is usually stuck with the
imperative style when manipulating compound objects.  Given the advantage of
the expression-oriented format, one might ask if there is any reason to have
implemented the system in imperative style, as we did in this section.  One
reason is that the non-expression-oriented constraint language provides a
handle on constraint objects (e.g., the value of the <code class="code">adder</code> procedure) as
well as on connector objects.  This is useful if we wish to extend the system
with new operations that communicate with constraints directly rather than only
indirectly via operations on connectors.  Although it is easy to implement the
expression-oriented style in terms of the imperative implementation, it is very
difficult to do the converse.</p>
</div>
<hr />
<div class="nav-panel">
<p>
Next: <a href="3_002e4.xhtml#g_t3_002e4" accesskey="n" rel="next">Concurrency: Time Is of the Essence</a>, Previous: <a href="3_002e2.xhtml#g_t3_002e2" accesskey="p" rel="prev">The Environment Model of Evaluation</a>, Up: <a href="Chapter-3.xhtml" accesskey="u" rel="up">Modularity, Objects, and State</a> &#160; [<a href="index.xhtml#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Term-Index.xhtml" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
