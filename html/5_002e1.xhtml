<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<!-- Created by GNU Texinfo 7.1, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>5.1 (Structure and Interpretation of Computer Programs, 2e)</title>

<meta name="description" content="5.1 (Structure and Interpretation of Computer Programs, 2e)" />
<meta name="keywords" content="5.1 (Structure and Interpretation of Computer Programs, 2e)" />
<meta name="resource-type" content="document" />
<meta name="distribution" content="global" />
<meta name="Generator" content="texi2any" />
<meta name="viewport" content="width=device-width,initial-scale=1" />

<link href="index.xhtml" rel="start" title="Top" />
<link href="Term-Index.xhtml" rel="index" title="Term Index" />
<link href="index.xhtml#SEC_Contents" rel="contents" title="Table of Contents" />
<link href="Chapter-5.xhtml" rel="up" title="Chapter 5" />
<link href="5_002e2.xhtml#g_t5_002e2" rel="next" title="5.2" />
<link href="Chapter-5.xhtml" rel="prev" title="Chapter 5" />
<style type="text/css">
<!--
a.copiable-link {visibility: hidden; text-decoration: none; line-height: 0em}
div.example {margin-left: 3.2em}
span:hover a.copiable-link {visibility: visible}
ul.mark-bullet {list-style-type: disc}
-->
</style>
<link href="css/style.css" rel="stylesheet" type="text/css" />
<link href="css/prettify.css" rel="stylesheet" type="text/css" />
<script src="js/highlight/prettify.js" type="text/javascript"></script>
<script src="js/highlight/lang-lisp.js" type="text/javascript"></script>
<script src="js/highlight/lang-rust.js" type="text/javascript"></script>
</head>

<body lang="en">
<div class="section-level-extent" id="g_t5_002e1">
<div class="nav-panel">
<p>
Next: <a href="5_002e2.xhtml#g_t5_002e2" accesskey="n" rel="next">A Register-Machine Simulator</a>, Previous: <a href="Chapter-5.xhtml" accesskey="p" rel="prev">Computing with Register Machines</a>, Up: <a href="Chapter-5.xhtml" accesskey="u" rel="up">Computing with Register Machines</a> &#160; [<a href="index.xhtml#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Term-Index.xhtml" title="Index" rel="index">Index</a>]</p>
</div>
<h3 class="section" id="Designing-Register-Machines"><span>5.1 Designing Register Machines<a class="copiable-link" href="#Designing-Register-Machines"> &#182;</a></span></h3>

<p>To design a register machine, we must design its <a class="index-entry-id" id="index-data-paths"></a>
<em class="dfn">data paths</em>
(registers and operations) and the <a class="index-entry-id" id="index-controller"></a>
<em class="dfn">controller</em> that sequences these
operations.  To illustrate the design of a simple register machine, let us
examine Euclid&#8217;s Algorithm, which is used to compute the greatest common
divisor (<abbr class="abbr">GCD</abbr>) of two integers.  As we saw in <a class="ref" href="1_002e2.xhtml#g_t1_002e2_002e5">Greatest Common Divisors</a>,
Euclid&#8217;s Algorithm can be carried out by an iterative process, as specified by
the following procedure:
</p>
<div class="example">
<pre class="example-preformatted">fn gcd(a: u64, b: u64) -&gt; u64 {
    if b == 0 {
        a
    } else {
        gcd(b, a % b)
    }
}
</pre></div>

<p>A machine to carry out this algorithm must keep track of two numbers, <em class="math">a</em> and
<em class="math">b</em>, so let us assume that these numbers are stored in two registers with
those names.  The basic operations required are testing whether the contents of
register <code class="code">b</code> is zero and computing the remainder of the contents of
register <code class="code">a</code> divided by the contents of register <code class="code">b</code>.  The remainder
operation is a complex process, but assume for the moment that we have a
primitive device that computes remainders.  On each cycle of the <abbr class="abbr">GCD</abbr>
algorithm, the contents of register <code class="code">a</code> must be replaced by the contents
of register <code class="code">b</code>, and the contents of <code class="code">b</code> must be replaced by the
remainder of the old contents of <code class="code">a</code> divided by the old contents of
<code class="code">b</code>.  It would be convenient if these replacements could be done
simultaneously, but in our model of register machines we will assume that only
one register can be assigned a new value at each step.  To accomplish the
replacements, our machine will use a third &#8220;temporary&#8221; register, which we
call <code class="code">t</code>.  (First the remainder will be placed in <code class="code">t</code>, then the
contents of <code class="code">b</code> will be placed in <code class="code">a</code>, and finally the remainder
stored in <code class="code">t</code> will be placed in <code class="code">b</code>.)
</p>
<p>We can illustrate the registers and operations required for this machine by
using the data-path diagram shown in <a class="ref" href="#Figure-5_002e1">Figure 5.1</a>.  In this diagram, the
registers (<code class="code">a</code>, <code class="code">b</code>, and <code class="code">t</code>) are represented by rectangles.
Each way to assign a value to a register is indicated by an arrow with an
<code class="code">X</code> behind the head, pointing from the source of data to the register.  We
can think of the <code class="code">X</code> as a button that, when pushed, allows the value at
the source to &#8220;flow&#8221; into the designated register.  The label next to each
button is the name we will use to refer to the button.  The names are
arbitrary, and can be chosen to have mnemonic value (for example, <code class="code">a&lt;-b</code>
denotes pushing the button that assigns the contents of register <code class="code">b</code> to
register <code class="code">a</code>).  The source of data for a register can be another register
(as in the <code class="code">a&lt;-b</code> assignment), an operation result (as in the <code class="code">t&lt;-r</code>
assignment), or a constant (a built-in value that cannot be changed,
represented in a data-path diagram by a triangle containing the constant).
</p>
<div class="float">
<a class="anchor" id="Figure-5_002e1"></a><img class="image" src="fig/chap5/Fig5.1a.std.svg" alt="fig/chap5/Fig5.1a" />
<div class="caption"><p><strong class="strong">Figure 5.1:</strong> Data paths for a <abbr class="abbr">GCD</abbr> machine.</p></div></div>
<p>An operation that computes a value from constants and the contents of registers
is represented in a data-path diagram by a trapezoid containing a name for the
operation.  For example, the box marked <code class="code">rem</code> in <a class="ref" href="#Figure-5_002e1">Figure 5.1</a>
represents an operation that computes the remainder of the contents of the
registers <code class="code">a</code> and <code class="code">b</code> to which it is attached.  Arrows (without
buttons) point from the input registers and constants to the box, and arrows
connect the operation&#8217;s output value to registers.  A test is represented by a
circle containing a name for the test.  For example, our <abbr class="abbr">GCD</abbr> machine
has an operation that tests whether the contents of register <code class="code">b</code> is zero.
A test also has arrows from its input registers and constants, but it has no
output arrows; its value is used by the controller rather than by the data
paths.  Overall, the data-path diagram shows the registers and operations that
are required for the machine and how they must be connected.  If we view the
arrows as wires and the <code class="code">X</code> buttons as switches, the data-path diagram is
very like the wiring diagram for a machine that could be constructed from
electrical components.
</p>
<p>In order for the data paths to actually compute <abbr class="abbr">GCD</abbr>s, the buttons
must be pushed in the correct sequence.  We will describe this sequence in
terms of a controller diagram, as illustrated in <a class="ref" href="#Figure-5_002e2">Figure 5.2</a>.  The
elements of the controller diagram indicate how the data-path components should
be operated.  The rectangular boxes in the controller diagram identify
data-path buttons to be pushed, and the arrows describe the sequencing from one
step to the next.  The diamond in the diagram represents a decision.  One of
the two sequencing arrows will be followed, depending on the value of the
data-path test identified in the diamond.  We can interpret the controller in
terms of a physical analogy: Think of the diagram as a maze in which a marble
is rolling.  When the marble rolls into a box, it pushes the data-path button
that is named by the box.  When the marble rolls into a decision node (such as
the test for <code class="code">b</code> = 0), it leaves the node on the path determined by the
result of the indicated test.  Taken together, the data paths and the
controller completely describe a machine for computing <abbr class="abbr">GCD</abbr>s.  We
start the controller (the rolling marble) at the place marked <code class="code">start</code>,
after placing numbers in registers <code class="code">a</code> and <code class="code">b</code>.  When the controller
reaches <code class="code">done</code>, we will find the value of the <abbr class="abbr">GCD</abbr> in register
<code class="code">a</code>.
</p>
<div class="float">
<a class="anchor" id="Figure-5_002e2"></a><img class="image" src="fig/chap5/Fig5.2.std.svg" alt="fig/chap5/Fig5.2" />
<div class="caption"><p><strong class="strong">Figure 5.2:</strong> Controller for a <abbr class="abbr">GCD</abbr> machine.</p></div></div>
<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-5_002e1"></a>Exercise 5.1:</strong> Design a register machine to
compute factorials using the iterative algorithm specified by the following
procedure.  Draw data-path and controller diagrams for this machine.
</p>
<div class="example">
<pre class="example-preformatted">fn factorial(n: u64) -&gt; u64 {
    fn iter(product: u64, counter: u64) -&gt; u64 {
        if counter &gt; n {
            product
        } else {
            iter(counter * product, counter + 1)
        }
    }
    iter(1, 1)
}
</pre></div>
</blockquote>


<hr />
<div class="subsection-level-extent" id="g_t5_002e1_002e1">
<h4 class="subsection" id="A-Language-for-Describing-Register-Machines"><span>5.1.1 A Language for Describing Register Machines<a class="copiable-link" href="#A-Language-for-Describing-Register-Machines"> &#182;</a></span></h4>

<p>Data-path and controller diagrams are adequate for representing simple machines
such as <abbr class="abbr">GCD</abbr>, but they are unwieldy for describing large machines such
as a Lisp interpreter.  To make it possible to deal with complex machines, we
will create a language that presents, in textual form, all the information
given by the data-path and controller diagrams.  We will start with a notation
that directly mirrors the diagrams.
</p>
<p>We define the data paths of a machine by describing the registers and the
operations.  To describe a register, we give it a name and specify the buttons
that control assignment to it.  We give each of these buttons a name and
specify the source of the data that enters the register under the button&#8217;s
control.  (The source is a register, a constant, or an operation.)  To describe
an operation, we give it a name and specify its inputs (registers or
constants).
</p>
<p>We define the controller of a machine as a sequence of <a class="index-entry-id" id="index-instructions-1"></a>
<em class="dfn">instructions</em>
together with <a class="index-entry-id" id="index-labels"></a>
<em class="dfn">labels</em> that identify <a class="index-entry-id" id="index-entry-points"></a>
<em class="dfn">entry points</em> in the
sequence. An instruction is one of the following:
</p>
<ul class="itemize mark-bullet">
<li>The name of a data-path button to push to assign a value to a register.  (This
corresponds to a box in the controller diagram.)

</li><li>A <code class="code">test</code> instruction, that performs a specified test.

</li><li>A conditional branch (<code class="code">branch</code> instruction) to a location indicated by a
controller label, based on the result of the previous test.  (The test and
branch together correspond to a diamond in the controller diagram.)  If the
test is false, the controller should continue with the next instruction in the
sequence.  Otherwise, the controller should continue with the instruction after
the label.

</li><li>An unconditional branch (<code class="code">goto</code> instruction) naming a controller label at
which to continue execution.

</li></ul>

<p>The machine starts at the beginning of the controller instruction sequence and
stops when execution reaches the end of the sequence.  Except when a branch
changes the flow of control, instructions are executed in the order in which
they are listed.
</p>
<p><a class="ref" href="#Figure-5_002e3">Figure 5.3</a> shows the <abbr class="abbr">GCD</abbr> machine described in this way.  This
example only hints at the generality of these descriptions, since the
<abbr class="abbr">GCD</abbr> machine is a very simple case: Each register has only one button,
and each button and test is used only once in the controller.
</p>
<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Figure-5_002e3"></a>Figure 5.3:</strong> <em class="math">\downarrow</em> A specification of the <abbr class="abbr">GCD</abbr>
machine.
</p>
<div class="example">
<pre class="example-preformatted">(data-paths
 (registers
  ((name a)
   (buttons ((name a&lt;-b)
             (source (register b)))))
  ((name b)
   (buttons ((name b&lt;-t)
             (source (register t)))))
  ((name t)
   (buttons ((name t&lt;-r)
             (source (operation rem))))))
 (operations
  ((name rem)
   (inputs (register a) (register b)))
  ((name =)
   (inputs (register b) (constant 0)))))
</pre></div>

<p>In Rust, we represent these controller instructions as:
</p>
<div class="example">
<pre class="example-preformatted">vec![
    Label(&quot;test-b&quot;.into()),
    Test(Op(&quot;=&quot;.into(), vec![Reg(&quot;b&quot;.into()), Const(0)])),
    Branch(&quot;gcd-done&quot;.into()),
    Assign(&quot;t&quot;.into(), Op(&quot;rem&quot;.into(), vec![Reg(&quot;a&quot;.into()), Reg(&quot;b&quot;.into())])),
    Assign(&quot;a&quot;.into(), Reg(&quot;b&quot;.into())),
    Assign(&quot;b&quot;.into(), Reg(&quot;t&quot;.into())),
    Goto(Label(&quot;test-b&quot;.into())),
    Label(&quot;gcd-done&quot;.into()),
]
</pre></div>

</blockquote>

<p>Unfortunately, it is difficult to read such a description.  In order to
understand the controller instructions we must constantly refer back to the
definitions of the button names and the operation names, and to understand what
the buttons do we may have to refer to the definitions of the operation names.
We will thus transform our notation to combine the information from the
data-path and controller descriptions so that we see it all together.
</p>
<p>To obtain this form of description, we will replace the arbitrary button and
operation names by the definitions of their behavior.  That is, instead of
saying (in the controller) &#8220;Push button <code class="code">t&lt;-r</code>&#8221; and separately saying
(in the data paths) &#8220;Button <code class="code">t&lt;-r</code> assigns the value of the <code class="code">rem</code>
operation to register <code class="code">t</code>&#8221; and &#8220;The <code class="code">rem</code> operation&#8217;s inputs are
the contents of registers <code class="code">a</code> and <code class="code">b</code>,&#8221; we will say (in the
controller) &#8220;Push the button that assigns to register <code class="code">t</code> the value of
the <code class="code">rem</code> operation on the contents of registers <code class="code">a</code> and <code class="code">b</code>.&#8221;
Similarly, instead of saying (in the controller) &#8220;Perform the <code class="code">=</code> test&#8221;
and separately saying (in the data paths) &#8220;The <code class="code">=</code> test operates on the
contents of register <code class="code">b</code> and the constant 0,&#8221; we will say &#8220;Perform the
<code class="code">=</code> test on the contents of register <code class="code">b</code> and the constant 0.&#8221;  We
will omit the data-path description, leaving only the controller sequence.
Thus, the <abbr class="abbr">GCD</abbr> machine is described as follows:
</p>
<div class="example">
<pre class="example-preformatted">vec![
    Label(&quot;test-b&quot;.into()),
    Test(Op(&quot;=&quot;.into(), vec![Reg(&quot;b&quot;.into()), Const(0)])),
    Branch(&quot;gcd-done&quot;.into()),
    Assign(&quot;t&quot;.into(), Op(&quot;rem&quot;.into(), vec![Reg(&quot;a&quot;.into()), Reg(&quot;b&quot;.into())])),
    Assign(&quot;a&quot;.into(), Reg(&quot;b&quot;.into())),
    Assign(&quot;b&quot;.into(), Reg(&quot;t&quot;.into())),
    Goto(Label(&quot;test-b&quot;.into())),
    Label(&quot;gcd-done&quot;.into()),
]
</pre></div>

<p><b class="b">Rust:</b>
</p><div class="example">
<pre class="example-preformatted">use Instruction::*;
use Source::*;
use Target::*;

vec![
    // test-b
    Test(Op(&quot;=&quot;.into(), vec![Reg(&quot;b&quot;.into()), Const(0)])),
    Branch(&quot;gcd-done&quot;.into()),
    Assign(&quot;t&quot;.into(), Op(&quot;rem&quot;.into(),
        vec![Reg(&quot;a&quot;.into()), Reg(&quot;b&quot;.into())])),
    Assign(&quot;a&quot;.into(), Reg(&quot;b&quot;.into())),
    Assign(&quot;b&quot;.into(), Reg(&quot;t&quot;.into())),
    Goto(Label(&quot;test-b&quot;.into())),
    // gcd-done
]
</pre></div>

<p>This form of description is easier to read than the kind illustrated in
<a class="ref" href="#Figure-5_002e3">Figure 5.3</a>, but it also has disadvantages:
</p>
<ul class="itemize mark-bullet">
<li>It is more verbose for large machines, because complete descriptions of the
data-path elements are repeated whenever the elements are mentioned in the
controller instruction sequence.  (This is not a problem in the <abbr class="abbr">GCD</abbr>
example, because each operation and button is used only once.)  Moreover,
repeating the data-path descriptions obscures the actual data-path structure of
the machine; it is not obvious for a large machine how many registers,
operations, and buttons there are and how they are interconnected.

</li><li>Because the controller instructions in a machine definition look like Lisp
expressions, it is easy to forget that they are not arbitrary Lisp expressions.
They can notate only legal machine operations.  For example, operations can
operate directly only on constants and the contents of registers, not on the
results of other operations.

</li></ul>

<p>In spite of these disadvantages, we will use this register-machine language
throughout this chapter, because we will be more concerned with understanding
controllers than with understanding the elements and connections in data paths.
We should keep in mind, however, that data-path design is crucial in designing
real machines.
</p>
<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-5_002e2"></a>Exercise 5.2:</strong> Use the register-machine language
to describe the iterative factorial machine of <a class="ref" href="#Exercise-5_002e1">Exercise 5.1</a>.
</p></blockquote>

<h4 class="subsubheading" id="Actions"><span>Actions<a class="copiable-link" href="#Actions"> &#182;</a></span></h4>

<p>Let us modify the <abbr class="abbr">GCD</abbr> machine so that we can type in the numbers
whose <abbr class="abbr">GCD</abbr> we want and get the answer printed at our terminal.  We
will not discuss how to make a machine that can read and print, but will assume
(as we do when we use <code class="code">read</code> and <code class="code">display</code> in Scheme) that they are
available as primitive operations.<a class="footnote" id="DOCF266" href="#FOOT266"><sup>266</sup></a>
</p>
<p><code class="code">Read</code> is like the operations we have been using in that it produces a
value that can be stored in a register.  But <code class="code">read</code> does not take inputs
from any registers; its value depends on something that happens outside the
parts of the machine we are designing.  We will allow our machine&#8217;s operations
to have such behavior, and thus will draw and notate the use of <code class="code">read</code>
just as we do any other operation that computes a value.
</p>
<p><code class="code">Print</code>, on the other hand, differs from the operations we have been using
in a fundamental way: It does not produce an output value to be stored in a
register.  Though it has an effect, this effect is not on a part of the machine
we are designing.  We will refer to this kind of operation as an
<a class="index-entry-id" id="index-action"></a>
<em class="dfn">action</em>.  We will represent an action in a data-path diagram just as
we represent an operation that computes a value&#8212;as a trapezoid that contains
the name of the action.  Arrows point to the action box from any inputs
(registers or constants).  We also associate a button with the action.  Pushing
the button makes the action happen.  To make a controller push an action button
we use a new kind of instruction called <code class="code">perform</code>.  Thus, the action of
printing the contents of register <code class="code">a</code> is represented in a controller
sequence by the instruction
</p>
<div class="example">
<pre class="example-preformatted">(perform (op print) (reg a))
</pre></div>

<p><b class="b">Rust:</b>
</p><div class="example">
<pre class="example-preformatted">Instruction::Perform(Source::Op(
    &quot;print&quot;.into(),
    vec![Source::Reg(&quot;a&quot;.into())]
))
</pre></div>

<p><a class="ref" href="#Figure-5_002e4">Figure 5.4</a> shows the data paths and controller for the new <abbr class="abbr">GCD</abbr>
machine.  Instead of having the machine stop after printing the answer, we have
made it start over, so that it repeatedly reads a pair of numbers, computes
their <abbr class="abbr">GCD</abbr>, and prints the result.  This structure is like the driver
loops we used in the interpreters of <a class="ref" href="Chapter-4.xhtml">Metalinguistic Abstraction</a>.
</p>
<div class="float">
<a class="anchor" id="Figure-5_002e4"></a><img class="image" src="fig/chap5/Fig5.4c.std.svg" alt="fig/chap5/Fig5.4c" />
<div class="caption"><p><strong class="strong">Figure 5.4:</strong> A <abbr class="abbr">GCD</abbr> machine that reads inputs and prints results.</p></div></div>
<hr />
</div>
<div class="subsection-level-extent" id="g_t5_002e1_002e2">
<h4 class="subsection" id="Abstraction-in-Machine-Design"><span>5.1.2 Abstraction in Machine Design<a class="copiable-link" href="#Abstraction-in-Machine-Design"> &#182;</a></span></h4>

<p>We will often define a machine to include &#8220;primitive&#8221; operations that are
actually very complex.  For example, in <a class="ref" href="5_002e4.xhtml#g_t5_002e4">The Explicit-Control Evaluator</a> and <a class="ref" href="5_002e5.xhtml#g_t5_002e5">Compilation</a> we
will treat Scheme&#8217;s environment manipulations as primitive.  Such abstraction
is valuable because it allows us to ignore the details of parts of a machine so
that we can concentrate on other aspects of the design.  The fact that we have
swept a lot of complexity under the rug, however, does not mean that a machine
design is unrealistic.  We can always replace the complex &#8220;primitives&#8221; by
simpler primitive operations.
</p>
<p>Consider the <abbr class="abbr">GCD</abbr> machine. The machine has an instruction that
computes the remainder of the contents of registers <code class="code">a</code> and <code class="code">b</code> and
assigns the result to register <code class="code">t</code>.  If we want to construct the
<abbr class="abbr">GCD</abbr> machine without using a primitive remainder operation, we must
specify how to compute remainders in terms of simpler operations, such as
subtraction.  Indeed, we can write a Scheme procedure that finds remainders in
this way:
</p>
<div class="example">
<pre class="example-preformatted">fn remainder(n: i64, d: i64) -&gt; i64 {
    if n &lt; d { n } else { remainder(n - d, d) }
}
</pre></div>

<p>We can thus replace the remainder operation in the <abbr class="abbr">GCD</abbr> machine&#8217;s data
paths with a subtraction operation and a comparison test.  <a class="ref" href="#Figure-5_002e5">Figure 5.5</a>
shows the data paths and controller for the elaborated machine.  The
instruction
</p>
<div class="example">
<pre class="example-preformatted">Assign(&quot;t&quot;.into(), Op(&quot;rem&quot;.into(), vec![Reg(&quot;a&quot;.into()), Reg(&quot;b&quot;.into())]))
</pre></div>

<p>in the <abbr class="abbr">GCD</abbr> controller definition is replaced by a sequence of
instructions that contains a loop, as shown in <a class="ref" href="#Figure-5_002e6">Figure 5.6</a>.
</p>
<div class="float">
<a class="anchor" id="Figure-5_002e5"></a><img class="image" src="fig/chap5/Fig5.5b.std.svg" alt="fig/chap5/Fig5.5b" />
<div class="caption"><p><strong class="strong">Figure 5.5:</strong> Data paths and controller for the elaborated <abbr class="abbr">GCD</abbr> machine.</p></div></div>
<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Figure-5_002e6"></a>Figure 5.6:</strong> <em class="math">\downarrow</em> Controller instruction sequence for the
<abbr class="abbr">GCD</abbr> machine in <a class="ref" href="#Figure-5_002e5">Figure 5.5</a>.
</p>
<div class="example">
<pre class="example-preformatted">vec![
    Label(&quot;test-b&quot;.into()),
    Test(Op(&quot;=&quot;.into(), vec![Reg(&quot;b&quot;.into()), Const(0)])),
    Branch(&quot;gcd-done&quot;.into()),
    Assign(&quot;t&quot;.into(), Reg(&quot;a&quot;.into())),
    Label(&quot;rem-loop&quot;.into()),
    Test(Op(&quot;&lt;&quot;.into(), vec![Reg(&quot;t&quot;.into()), Reg(&quot;b&quot;.into())])),
    Branch(&quot;rem-done&quot;.into()),
    Assign(&quot;t&quot;.into(), Op(&quot;-&quot;.into(), vec![Reg(&quot;t&quot;.into()), Reg(&quot;b&quot;.into())])),
    Goto(Label(&quot;rem-loop&quot;.into())),
    Label(&quot;rem-done&quot;.into()),
    Assign(&quot;a&quot;.into(), Reg(&quot;b&quot;.into())),
    Assign(&quot;b&quot;.into(), Reg(&quot;t&quot;.into())),
    Goto(Label(&quot;test-b&quot;.into())),
    Label(&quot;gcd-done&quot;.into()),
]
</pre></div>

<p><b class="b">Rust:</b>
</p><div class="example">
<pre class="example-preformatted">vec![
    // test-b
    Test(Op(&quot;=&quot;.into(), vec![Reg(&quot;b&quot;.into()), Const(0)])),
    Branch(&quot;gcd-done&quot;.into()),
    Assign(&quot;t&quot;.into(), Reg(&quot;a&quot;.into())),
    // rem-loop
    Test(Op(&quot;&lt;&quot;.into(), vec![Reg(&quot;t&quot;.into()), Reg(&quot;b&quot;.into())])),
    Branch(&quot;rem-done&quot;.into()),
    Assign(&quot;t&quot;.into(), Op(&quot;-&quot;.into(),
        vec![Reg(&quot;t&quot;.into()), Reg(&quot;b&quot;.into())])),
    Goto(Label(&quot;rem-loop&quot;.into())),
    // rem-done
    Assign(&quot;a&quot;.into(), Reg(&quot;b&quot;.into())),
    Assign(&quot;b&quot;.into(), Reg(&quot;t&quot;.into())),
    Goto(Label(&quot;test-b&quot;.into())),
    // gcd-done
]
</pre></div>

</blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-5_002e3"></a>Exercise 5.3:</strong> Design a machine to compute square
roots using Newton&#8217;s method, as described in <a class="ref" href="1_002e1.xhtml#Sec_002e1_002e1_002e7">1.1.7</a>:
</p>
<div class="example">
<pre class="example-preformatted">fn sqrt(x: f64) -&gt; f64 {
    fn good_enough(guess: f64, x: f64) -&gt; bool {
        (guess * guess - x).abs() &lt; 0.001
    }
    fn improve(guess: f64, x: f64) -&gt; f64 {
        (guess + x / guess) / 2.0
    }
    fn sqrt_iter(guess: f64, x: f64) -&gt; f64 {
        if good_enough(guess, x) {
            guess
        } else {
            sqrt_iter(improve(guess, x), x)
        }
    }
    sqrt_iter(1.0, x)
}
</pre></div>

<p>Begin by assuming that <code class="code">good_enough</code> and <code class="code">improve</code> operations are
available as primitives.  Then show how to expand these in terms of arithmetic
operations.  Describe each version of the <code class="code">sqrt</code> machine design by drawing
a data-path diagram and writing a controller definition in the register-machine
language.
</p></blockquote>

<hr />
</div>
<div class="subsection-level-extent" id="g_t5_002e1_002e3">
<h4 class="subsection" id="Subroutines"><span>5.1.3 Subroutines<a class="copiable-link" href="#Subroutines"> &#182;</a></span></h4>

<p>When designing a machine to perform a computation, we would often prefer to
arrange for components to be shared by different parts of the computation
rather than duplicate the components.  Consider a machine that includes two
<abbr class="abbr">GCD</abbr> computations&#8212;one that finds the <abbr class="abbr">GCD</abbr> of the contents
of registers <code class="code">a</code> and <code class="code">b</code> and one that finds the <abbr class="abbr">GCD</abbr> of the
contents of registers <code class="code">c</code> and <code class="code">d</code>.  We might start by assuming we
have a primitive <code class="code">gcd</code> operation, then expand the two instances of
<code class="code">gcd</code> in terms of more primitive operations.  <a class="ref" href="#Figure-5_002e7">Figure 5.7</a> shows just
the <abbr class="abbr">GCD</abbr> portions of the resulting machine&#8217;s data paths, without
showing how they connect to the rest of the machine.  The figure also shows the
corresponding portions of the machine&#8217;s controller sequence.
</p>
<div class="float">
<a class="anchor" id="Figure-5_002e7"></a><img class="image" src="fig/chap5/Fig5.7b.std.svg" alt="fig/chap5/Fig5.7b" />
<div class="caption"><p><strong class="strong">Figure 5.7:</strong> Portions of the data paths and controller sequence<!-- /@w --> for a machine with two <abbr class="abbr">GCD</abbr> computations.</p></div></div>
<p>This machine has two remainder operation boxes and two boxes for testing
equality.  If the duplicated components are complicated, as is the remainder
box, this will not be an economical way to build the machine.  We can avoid
duplicating the data-path components by using the same components for both
<abbr class="abbr">GCD</abbr> computations, provided that doing so will not affect the rest of
the larger machine&#8217;s computation.  If the values in registers <code class="code">a</code> and
<code class="code">b</code> are not needed by the time the controller gets to <code class="code">gcd-2</code> (or if
these values can be moved to other registers for safekeeping), we can change
the machine so that it uses registers <code class="code">a</code> and <code class="code">b</code>, rather than
registers <code class="code">c</code> and <code class="code">d</code>, in computing the second <abbr class="abbr">GCD</abbr> as well
as the first.  If we do this, we obtain the controller sequence shown in
<a class="ref" href="#Figure-5_002e8">Figure 5.8</a>.
</p>
<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Figure-5_002e8"></a>Figure 5.8:</strong> <em class="math">\downarrow</em> Portions of the controller sequence for
a machine that uses the same data-path components for two different
<abbr class="abbr">GCD</abbr> computations.
</p>
<div class="example">
<pre class="example-preformatted">// gcd-1
Label(&quot;gcd-1&quot;.into()),
Test(Op(&quot;=&quot;.into(), vec![Reg(&quot;b&quot;.into()), Const(0)])),
Branch(&quot;after-gcd-1&quot;.into()),
Assign(&quot;t&quot;.into(), Op(&quot;rem&quot;.into(), vec![Reg(&quot;a&quot;.into()), Reg(&quot;b&quot;.into())])),
Assign(&quot;a&quot;.into(), Reg(&quot;b&quot;.into())),
Assign(&quot;b&quot;.into(), Reg(&quot;t&quot;.into())),
Goto(Label(&quot;gcd-1&quot;.into())),
Label(&quot;after-gcd-1&quot;.into()),
// ...
// gcd-2
Label(&quot;gcd-2&quot;.into()),
Test(Op(&quot;=&quot;.into(), vec![Reg(&quot;b&quot;.into()), Const(0)])),
Branch(&quot;after-gcd-2&quot;.into()),
Assign(&quot;t&quot;.into(), Op(&quot;rem&quot;.into(), vec![Reg(&quot;a&quot;.into()), Reg(&quot;b&quot;.into())])),
Assign(&quot;a&quot;.into(), Reg(&quot;b&quot;.into())),
Assign(&quot;b&quot;.into(), Reg(&quot;t&quot;.into())),
Goto(Label(&quot;gcd-2&quot;.into())),
Label(&quot;after-gcd-2&quot;.into()),
</pre></div>

</blockquote>

<p>We have removed the duplicate data-path components (so that the data paths are
again as in <a class="ref" href="#Figure-5_002e1">Figure 5.1</a>), but the controller now has two <abbr class="abbr">GCD</abbr>
sequences that differ only in their entry-point labels.  It would be better to
replace these two sequences by branches to a single sequence&#8212;a <code class="code">gcd</code>
<a class="index-entry-id" id="index-subroutine"></a>
<em class="dfn">subroutine</em>&#8212;at the end of which we branch back to the correct place
in the main instruction sequence.  We can accomplish this as follows: Before
branching to <code class="code">gcd</code>, we place a distinguishing value (such as 0 or 1) into
a special register, <code class="code">continue</code>.  At the end of the <code class="code">gcd</code> subroutine
we return either to <code class="code">after-gcd-1</code> or to <code class="code">after-gcd-2</code>, depending on
the value of the <code class="code">continue</code> register.  <a class="ref" href="#Figure-5_002e9">Figure 5.9</a> shows the relevant
portion of the resulting controller sequence, which includes only a single copy
of the <code class="code">gcd</code> instructions.
</p>
<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Figure-5_002e9"></a>Figure 5.9:</strong> <em class="math">\downarrow</em> Using a <code class="code">continue</code> register to
avoid the duplicate controller sequence in <a class="ref" href="#Figure-5_002e8">Figure 5.8</a>.
</p>
<div class="example">
<pre class="example-preformatted">// gcd
Label(&quot;gcd&quot;.into()),
Test(Op(&quot;=&quot;.into(), vec![Reg(&quot;b&quot;.into()), Const(0)])),
Branch(&quot;gcd-done&quot;.into()),
Assign(&quot;t&quot;.into(), Op(&quot;rem&quot;.into(), vec![Reg(&quot;a&quot;.into()), Reg(&quot;b&quot;.into())])),
Assign(&quot;a&quot;.into(), Reg(&quot;b&quot;.into())),
Assign(&quot;b&quot;.into(), Reg(&quot;t&quot;.into())),
Goto(Label(&quot;gcd&quot;.into())),
Label(&quot;gcd-done&quot;.into()),
Test(Op(&quot;=&quot;.into(), vec![Reg(&quot;continue&quot;.into()), Const(0)])),
Branch(&quot;after-gcd-1&quot;.into()),
Goto(Label(&quot;after-gcd-2&quot;.into())),
// ...
// Before branching to gcd from first place
Assign(&quot;continue&quot;.into(), Const(0)),
Goto(Label(&quot;gcd&quot;.into())),
Label(&quot;after-gcd-1&quot;.into()),
// ...
// Before second use of gcd
Assign(&quot;continue&quot;.into(), Const(1)),
</pre></div>

</blockquote>

<p>This is a reasonable approach for handling small problems, but it would be
awkward if there were many instances of <abbr class="abbr">GCD</abbr> computations in the
controller sequence.  To decide where to continue executing after the
<code class="code">gcd</code> subroutine, we would need tests in the data paths and branch
instructions in the controller for all the places that use <code class="code">gcd</code>.  A more
powerful method for implementing subroutines is to have the <code class="code">continue</code>
register hold the label of the entry point in the controller sequence at which
execution should continue when the subroutine is finished.  Implementing this
strategy requires a new kind of connection between the data paths and the
controller of a register machine: There must be a way to assign to a register a
label in the controller sequence in such a way that this value can be fetched
from the register and used to continue execution at the designated entry point.
</p>
<p>To reflect this ability, we will extend the <code class="code">assign</code> instruction of the
register-machine language to allow a register to be assigned as value a label
from the controller sequence (as a special kind of constant).  We will also
extend the <code class="code">goto</code> instruction to allow execution to continue at the entry
point described by the contents of a register rather than only at an entry
point described by a constant label.  Using these new constructs we can
terminate the <code class="code">gcd</code> subroutine with a branch to the location stored in the
<code class="code">continue</code> register.  This leads to the controller sequence shown in
<a class="ref" href="#Figure-5_002e10">Figure 5.10</a>.
</p>
<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Figure-5_002e10"></a>Figure 5.10:</strong> <em class="math">\downarrow</em> Assigning labels to the
<code class="code">continue</code> register simplifies and generalizes the strategy shown in
<a class="ref" href="#Figure-5_002e9">Figure 5.9</a>.
</p>
<div class="example">
<pre class="example-preformatted">gcd
 (test (op =) (reg b) (const 0))
 (branch (label gcd-done))
 (assign t (op rem) (reg a) (reg b))
 (assign a (reg b))
 (assign b (reg t))
 (goto (label gcd))
gcd-done
 (goto (reg continue))
  ...
;; Before calling gcd,
;; we assign to continue the label
;; to which gcd should return.
 (assign continue (label after-gcd-1))
 (goto (label gcd))
after-gcd-1
  ...
;; Here is the second call to gcd,
;; with a different continuation.
 (assign continue (label after-gcd-2))
 (goto (label gcd))
after-gcd-2
</pre></div>

</blockquote>

<p>A machine with more than one subroutine could use multiple continuation
registers (e.g., <code class="code">gcd-continue</code>, <code class="code">factorial-continue</code>) or we could
have all subroutines share a single <code class="code">continue</code> register.  Sharing is more
economical, but we must be careful if we have a subroutine (<code class="code">sub1</code>) that
calls another subroutine (<code class="code">sub2</code>).  Unless <code class="code">sub1</code> saves the contents
of <code class="code">continue</code> in some other register before setting up <code class="code">continue</code> for
the call to <code class="code">sub2</code>, <code class="code">sub1</code> will not know where to go when it is
finished.  The mechanism developed in the next section to handle recursion also
provides a better solution to this problem of nested subroutine calls.
</p>
<hr />
</div>
<div class="subsection-level-extent" id="g_t5_002e1_002e4">
<h4 class="subsection" id="Using-a-Stack-to-Implement-Recursion"><span>5.1.4 Using a Stack to Implement Recursion<a class="copiable-link" href="#Using-a-Stack-to-Implement-Recursion"> &#182;</a></span></h4>

<p>With the ideas illustrated so far, we can implement any iterative process by
specifying a register machine that has a register corresponding to each state
variable of the process.  The machine repeatedly executes a controller loop,
changing the contents of the registers, until some termination condition is
satisfied.  At each point in the controller sequence, the state of the machine
(representing the state of the iterative process) is completely determined by
the contents of the registers (the values of the state variables).
</p>
<p>Implementing recursive processes, however, requires an additional mechanism.
Consider the following recursive method for computing factorials, which we
first examined in <a class="ref" href="1_002e2.xhtml#g_t1_002e2_002e1">Linear Recursion and Iteration</a>:
</p>
<div class="example">
<pre class="example-preformatted">fn factorial(n: i64) -&gt; i64 {
    if n == 1 {
        1
    } else {
        factorial(n - 1) * n
    }
}
</pre></div>

<p>As we see from the procedure, computing <em class="math">{n!}</em> requires computing <em class="math">{(n - 1)!}</em>.
Our <abbr class="abbr">GCD</abbr> machine, modeled on the procedure
</p>
<div class="example">
<pre class="example-preformatted">fn gcd(a: u64, b: u64) -&gt; u64 {
    if b == 0 {
        a
    } else {
        gcd(b, a % b)
    }
}
</pre></div>

<p>similarly had to compute another <abbr class="abbr">GCD</abbr>.  But there is an important
difference between the <code class="code">gcd</code> procedure, which reduces the original
computation to a new <abbr class="abbr">GCD</abbr> computation, and <code class="code">factorial</code>, which
requires computing another factorial as a subproblem.  In <abbr class="abbr">GCD</abbr>, the
answer to the new <abbr class="abbr">GCD</abbr> computation is the answer to the original
problem.  To compute the next <abbr class="abbr">GCD</abbr>, we simply place the new arguments
in the input registers of the <abbr class="abbr">GCD</abbr> machine and reuse the machine&#8217;s
data paths by executing the same controller sequence.  When the machine is
finished solving the final <abbr class="abbr">GCD</abbr> problem, it has completed the entire
computation.
</p>
<p>In the case of factorial (or any recursive process) the answer to the new
factorial subproblem is not the answer to the original problem.  The value
obtained for <em class="math">{(n - 1)!}</em> must be multiplied by <em class="math">n</em> to get the final answer.
If we try to imitate the <abbr class="abbr">GCD</abbr> design, and solve the factorial
subproblem by decrementing the <code class="code">n</code> register and rerunning the factorial
machine, we will no longer have available the old value of <code class="code">n</code> by which to
multiply the result.  We thus need a second factorial machine to work on the
subproblem.  This second factorial computation itself has a factorial
subproblem, which requires a third factorial machine, and so on.  Since each
factorial machine contains another factorial machine within it, the total
machine contains an infinite nest of similar machines and hence cannot be
constructed from a fixed, finite number of parts.
</p>
<p>Nevertheless, we can implement the factorial process as a register machine if
we can arrange to use the same components for each nested instance of the
machine.  Specifically, the machine that computes <em class="math">{n!}</em>  should use the same
components to work on the subproblem of computing <em class="math">{(n - 1)!}</em>, on the
subproblem for <em class="math">{(n - 2)!}</em>, and so on.  This is plausible because, although
the factorial process dictates that an unbounded number of copies of the same
machine are needed to perform a computation, only one of these copies needs to
be active at any given time.  When the machine encounters a recursive
subproblem, it can suspend work on the main problem, reuse the same physical
parts to work on the subproblem, then continue the suspended computation.
</p>
<p>In the subproblem, the contents of the registers will be different than they
were in the main problem. (In this case the <code class="code">n</code> register is decremented.)
In order to be able to continue the suspended computation, the machine must
save the contents of any registers that will be needed after the subproblem is
solved so that these can be restored to continue the suspended computation.  In
the case of factorial, we will save the old value of <code class="code">n</code>, to be restored
when we are finished computing the factorial of the decremented <code class="code">n</code>
register.<a class="footnote" id="DOCF267" href="#FOOT267"><sup>267</sup></a>
</p>
<p>Since there is no <em class="emph">a priori</em> limit on the depth of nested recursive calls,
we may need to save an arbitrary number of register values.  These values must
be restored in the reverse of the order in which they were saved, since in a
nest of recursions the last subproblem to be entered is the first to be
finished.  This dictates the use of a <a class="index-entry-id" id="index-stack-1"></a>
<em class="dfn">stack</em>, or &#8220;last in, first
out&#8221; data structure, to save register values.  We can extend the
register-machine language to include a stack by adding two kinds of
instructions: Values are placed on the stack using a <code class="code">save</code> instruction
and restored from the stack using a <code class="code">restore</code> instruction.  After a
sequence of values has been <code class="code">save</code>d on the stack, a sequence of
<code class="code">restore</code>s will retrieve these values in reverse order.<a class="footnote" id="DOCF268" href="#FOOT268"><sup>268</sup></a>
</p>
<p>With the aid of the stack, we can reuse a single copy of the factorial
machine&#8217;s data paths for each factorial subproblem.  There is a similar design
issue in reusing the controller sequence that operates the data paths.  To
reexecute the factorial computation, the controller cannot simply loop back to
the beginning, as with an iterative process, because after solving the
<em class="math">{(n - 1)!}</em> subproblem the machine must still multiply the result by <em class="math">n</em>.  The
controller must suspend its computation of <em class="math">{n!}</em>, solve the <em class="math">{(n - 1)!}</em>
subproblem, then continue its computation of <em class="math">{n!}</em>.  This view of the
factorial computation suggests the use of the subroutine mechanism described in
<a class="ref" href="#g_t5_002e1_002e3">Subroutines</a>, which has the controller use a <code class="code">continue</code> register to
transfer to the part of the sequence that solves a subproblem and then continue
where it left off on the main problem.  We can thus make a factorial subroutine
that returns to the entry point stored in the <code class="code">continue</code> register.  Around
each subroutine call, we save and restore <code class="code">continue</code> just as we do the
<code class="code">n</code> register, since each &#8220;level&#8221; of the factorial computation will use
the same <code class="code">continue</code> register.  That is, the factorial subroutine must put
a new value in <code class="code">continue</code> when it calls itself for a subproblem, but it
will need the old value in order to return to the place that called it to solve
a subproblem.
</p>
<p><a class="ref" href="#Figure-5_002e11">Figure 5.11</a> shows the data paths and controller for a machine that
implements the recursive <code class="code">factorial</code> procedure.  The machine has a stack
and three registers, called <code class="code">n</code>, <code class="code">val</code>, and <code class="code">continue</code>.  To
simplify the data-path diagram, we have not named the register-assignment
buttons, only the stack-operation buttons (<code class="code">sc</code> and <code class="code">sn</code> to save
registers, <code class="code">rc</code> and <code class="code">rn</code> to restore registers).  To operate the
machine, we put in register <code class="code">n</code> the number whose factorial we wish to
compute and start the machine.  When the machine reaches <code class="code">fact-done</code>, the
computation is finished and the answer will be found in the <code class="code">val</code>
register.  In the controller sequence, <code class="code">n</code> and <code class="code">continue</code> are saved
before each recursive call and restored upon return from the call.  Returning
from a call is accomplished by branching to the location stored in
<code class="code">continue</code>.  <code class="code">Continue</code> is initialized when the machine starts so
that the last return will go to <code class="code">fact-done</code>.  The <code class="code">val</code> register,
which holds the result of the factorial computation, is not saved before the
recursive call, because the old contents of <code class="code">val</code> is not useful after the
subroutine returns.  Only the new value, which is the value produced by the
subcomputation, is needed.
</p>
<div class="float">
<a class="anchor" id="Figure-5_002e11"></a><img class="image" src="fig/chap5/Fig5.11b.std.svg" alt="fig/chap5/Fig5.11b" />
<div class="caption"><p><strong class="strong">Figure 5.11:</strong> A recursive factorial machine.</p></div></div>
<p>Although in principle the factorial computation requires an infinite machine,
the machine in <a class="ref" href="#Figure-5_002e11">Figure 5.11</a> is actually finite except for the stack, which
is potentially unbounded.  Any particular physical implementation of a stack,
however, will be of finite size, and this will limit the depth of recursive
calls that can be handled by the machine.  This implementation of factorial
illustrates the general strategy for realizing recursive algorithms as ordinary
register machines augmented by stacks.  When a recursive subproblem is
encountered, we save on the stack the registers whose current values will be
required after the subproblem is solved, solve the recursive subproblem, then
restore the saved registers and continue execution on the main problem.  The
<code class="code">continue</code> register must always be saved.  Whether there are other
registers that need to be saved depends on the particular machine, since not
all recursive computations need the original values of registers that are
modified during solution of the subproblem (see <a class="ref" href="#Exercise-5_002e4">Exercise 5.4</a>).
</p>
<h4 class="subsubheading" id="A-double-recursion"><span>A double recursion<a class="copiable-link" href="#A-double-recursion"> &#182;</a></span></h4>

<p>Let us examine a more complex recursive process, the tree-recursive computation
of the Fibonacci numbers, which we introduced in <a class="ref" href="1_002e2.xhtml#g_t1_002e2_002e2">Tree Recursion</a>:
</p>
<div class="example">
<pre class="example-preformatted">fn fib(n: u64) -&gt; u64 {
    if n &lt; 2 {
        n
    } else {
        fib(n - 1) + fib(n - 2)
    }
}
</pre></div>

<p>Just as with factorial, we can implement the recursive Fibonacci computation as
a register machine with registers <code class="code">n</code>, <code class="code">val</code>, and <code class="code">continue</code>.
The machine is more complex than the one for factorial, because there are two
places in the controller sequence where we need to perform recursive
calls&#8212;once to compute <em class="math">{\text{Fib}(n - 1)}</em> and once to compute <em class="math">{\text{Fib}(n - 2)}</em>.  To
set up for each of these calls, we save the registers whose values will be
needed later, set the <code class="code">n</code> register to the number whose Fib we need to
compute recursively (<em class="math">{n - 1}</em> or <em class="math">{n - 2}</em>), and assign to <code class="code">continue</code> the
entry point in the main sequence to which to return (<code class="code">afterfib-n-1</code> or
<code class="code">afterfib-n-2</code>, respectively).  We then go to <code class="code">fib-loop</code>.  When we
return from the recursive call, the answer is in <code class="code">val</code>.  <a class="ref" href="#Figure-5_002e12">Figure 5.12</a>
shows the controller sequence for this machine.
</p>
<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Figure-5_002e12"></a>Figure 5.12:</strong> <em class="math">\downarrow</em> Controller for a machine to compute
Fibonacci numbers.
</p>
<div class="example">
<pre class="example-preformatted">vec![
    Assign(&quot;continue&quot;.into(), Label(&quot;fib-done&quot;.into())),
    Label(&quot;fib-loop&quot;.into()),
    Test(Op(&quot;&lt;&quot;.into(), vec![Reg(&quot;n&quot;.into()), Const(2)])),
    Branch(&quot;immediate-answer&quot;.into()),
    Save(&quot;continue&quot;.into()),
    Assign(&quot;continue&quot;.into(), Label(&quot;afterfib-n-1&quot;.into())),
    Save(&quot;n&quot;.into()),
    Assign(&quot;n&quot;.into(), Op(&quot;-&quot;.into(), vec![Reg(&quot;n&quot;.into()), Const(1)])),
    Goto(Label(&quot;fib-loop&quot;.into())),
    Label(&quot;afterfib-n-1&quot;.into()),
    Restore(&quot;n&quot;.into()),
    Restore(&quot;continue&quot;.into()),
    Assign(&quot;n&quot;.into(), Op(&quot;-&quot;.into(), vec![Reg(&quot;n&quot;.into()), Const(2)])),
    Save(&quot;continue&quot;.into()),
    Assign(&quot;continue&quot;.into(), Label(&quot;afterfib-n-2&quot;.into())),
    Save(&quot;val&quot;.into()),
    Goto(Label(&quot;fib-loop&quot;.into())),
    Label(&quot;afterfib-n-2&quot;.into()),
    Assign(&quot;n&quot;.into(), Reg(&quot;val&quot;.into())),
    Restore(&quot;val&quot;.into()),
    Restore(&quot;continue&quot;.into()),
    Assign(&quot;val&quot;.into(), Op(&quot;+&quot;.into(), vec![Reg(&quot;val&quot;.into()), Reg(&quot;n&quot;.into())])),
    Goto(Reg(&quot;continue&quot;.into())),
    Label(&quot;immediate-answer&quot;.into()),
    Assign(&quot;val&quot;.into(), Reg(&quot;n&quot;.into())),
    Goto(Reg(&quot;continue&quot;.into())),
    Label(&quot;fib-done&quot;.into()),
]
</pre></div>

</blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-5_002e4"></a>Exercise 5.4:</strong> Specify register machines that
implement each of the following procedures.  For each machine, write a
controller instruction sequence and draw a diagram showing the data paths.
</p>
<ol class="enumerate" type="a" start="1">
<li> Recursive exponentiation:

<div class="example">
<pre class="example-preformatted">fn expt(b: i64, n: i64) -&gt; i64 {
    if n == 0 {
        1
    } else {
        b * expt(b, n - 1)
    }
}
</pre></div>

</li><li> Iterative exponentiation:

<div class="example">
<pre class="example-preformatted">fn expt(b: i64, n: i64) -&gt; i64 {
    fn iter(counter: i64, product: i64) -&gt; i64 {
        if counter == 0 {
            product
        } else {
            iter(counter - 1, b * product)
        }
    }
    iter(n, 1)
}
</pre></div>

</li></ol>
</blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-5_002e5"></a>Exercise 5.5:</strong> Hand-simulate the factorial and
Fibonacci machines, using some nontrivial input (requiring execution of at
least one recursive call).  Show the contents of the stack at each significant
point in the execution.
</p></blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-5_002e6"></a>Exercise 5.6:</strong> Ben Bitdiddle observes that the
Fibonacci machine&#8217;s controller sequence has an extra <code class="code">save</code> and an extra
<code class="code">restore</code>, which can be removed to make a faster machine.  Where are these
instructions?
</p></blockquote>

<hr />
</div>
<div class="subsection-level-extent" id="g_t5_002e1_002e5">

<h4 class="subsection" id="Instruction-Summary"><span>5.1.5 Instruction Summary<a class="copiable-link" href="#Instruction-Summary"> &#182;</a></span></h4>



<p>A controller instruction in our register-machine language is represented by the
</p>
<p><code class="code">Inst</code> enum.  Values are represented by the <code class="code">VExp</code> (value expression)
</p>
<p>enum, which can be a register (<code class="code">VExp::Reg</code>) or a constant
</p>
<p>(<code class="code">VExp::Const</code>).
</p>


<div class="example">
<pre class="example-preformatted">

// Assign a value to a register

Inst::Assign(target_reg, source_value)



// Perform an operation (side effect only)

Inst::Perform(OpExp { op: name, args: vec![...] })



// Test a condition and set the flag

Inst::Test(OpExp { op: predicate, args: vec![...] })



// Branch to a label if flag is true

Inst::Branch(label_name)



// Unconditional goto

Inst::Goto(GotoDest::Label(label_name))

</pre></div>




<p>The use of registers to hold labels was introduced in <a class="ref" href="#g_t5_002e1_002e3">Subroutines</a>:
</p>


<div class="example">
<pre class="example-preformatted">

Inst::Assign(reg_name, VExp::Label(label_name))

Inst::Goto(GotoDest::Reg(reg_name))

</pre></div>




<p>Instructions to use the stack were introduced in <a class="ref" href="#g_t5_002e1_002e4">Using a Stack to Implement Recursion</a>:
</p>


<div class="example">
<pre class="example-preformatted">

Inst::Save(reg_name)

Inst::Restore(reg_name)

</pre></div>




<p>The constant values we use are wrapped in the <code class="code">Value</code> enum, which can
</p>
<p>represent numbers, booleans, strings, symbols, and lists.
</p>
<p>For example,<br />
</p>
<p><code class="code">Value::String(&quot;abc&quot;.to_string())</code> is the string <code class="code">&quot;abc&quot;</code>,<br />
</p>
<p><code class="code">Value::Symbol(&quot;abc&quot;.to_string())</code> is the symbol <code class="code">abc</code>,<br />
</p>
<p><code class="code">Value::Pair(...)</code> is a list,<br />
</p>
<p>and <code class="code">Value::Nil</code> is the empty list.
</p>
</div>
</div>
<div class="footnotes-segment">
<hr />
<h4 class="footnotes-heading">Footnotes</h4>

<h5 class="footnote-body-heading"><a id="FOOT266" href="#DOCF266">(266)</a></h5>
<p>This assumption glosses over a
great deal of complexity.  Usually a large portion of the implementation of a
Lisp system is dedicated to making reading and printing work.</p>
<h5 class="footnote-body-heading"><a id="FOOT267" href="#DOCF267">(267)</a></h5>
<p>One might argue that we don&#8217;t need to save the old <code class="code">n</code>;
after we decrement it and solve the subproblem, we could simply increment it to
recover the old value.  Although this strategy works for factorial, it cannot
work in general, since the old value of a register cannot always be computed
from the new one.</p>
<h5 class="footnote-body-heading"><a id="FOOT268" href="#DOCF268">(268)</a></h5>
<p>In
<a class="ref" href="5_002e3.xhtml#g_t5_002e3">Storage Allocation and Garbage Collection</a> we will see how to implement a stack in terms of more
primitive operations.</p>
</div>
<hr />
<div class="nav-panel">
<p>
Next: <a href="5_002e2.xhtml#g_t5_002e2" accesskey="n" rel="next">A Register-Machine Simulator</a>, Previous: <a href="Chapter-5.xhtml" accesskey="p" rel="prev">Computing with Register Machines</a>, Up: <a href="Chapter-5.xhtml" accesskey="u" rel="up">Computing with Register Machines</a> &#160; [<a href="index.xhtml#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Term-Index.xhtml" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
