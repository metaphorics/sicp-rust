<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<!-- Created by GNU Texinfo 7.1, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>2.3 (Structure and Interpretation of Computer Programs, 2e)</title>

<meta name="description" content="2.3 (Structure and Interpretation of Computer Programs, 2e)" />
<meta name="keywords" content="2.3 (Structure and Interpretation of Computer Programs, 2e)" />
<meta name="resource-type" content="document" />
<meta name="distribution" content="global" />
<meta name="Generator" content="texi2any" />
<meta name="viewport" content="width=device-width,initial-scale=1" />

<link href="index.xhtml" rel="start" title="Top" />
<link href="Term-Index.xhtml" rel="index" title="Term Index" />
<link href="index.xhtml#SEC_Contents" rel="contents" title="Table of Contents" />
<link href="Chapter-2.xhtml" rel="up" title="Chapter 2" />
<link href="2_002e4.xhtml#g_t2_002e4" rel="next" title="2.4" />
<link href="2_002e2.xhtml#g_t2_002e2_002e5" rel="prev" title="2.2.5" />
<style type="text/css">
<!--
a.copiable-link {visibility: hidden; text-decoration: none; line-height: 0em}
div.example {margin-left: 3.2em}
span.r {font-family: initial; font-weight: normal; font-style: normal}
span:hover a.copiable-link {visibility: visible}
ul.mark-bullet {list-style-type: disc}
-->
</style>
<link href="css/style.css" rel="stylesheet" type="text/css" />
<link href="css/prettify.css" rel="stylesheet" type="text/css" />
<script src="js/highlight/prettify.js" type="text/javascript"></script>
<script src="js/highlight/lang-lisp.js" type="text/javascript"></script>
<script src="js/highlight/lang-rust.js" type="text/javascript"></script>
</head>

<body lang="en">
<div class="section-level-extent" id="g_t2_002e3">
<div class="nav-panel">
<p>
Next: <a href="2_002e4.xhtml#g_t2_002e4" accesskey="n" rel="next">Multiple Representations for Abstract Data</a>, Previous: <a href="2_002e2.xhtml#g_t2_002e2_002e5" accesskey="p" rel="prev">Algebraic Data Types</a>, Up: <a href="Chapter-2.xhtml" accesskey="u" rel="up">Building Abstractions with Data</a> &#160; [<a href="index.xhtml#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Term-Index.xhtml" title="Index" rel="index">Index</a>]</p>
</div>
<h3 class="section" id="Symbolic-Data"><span>2.3 Symbolic Data<a class="copiable-link" href="#Symbolic-Data"> &#182;</a></span></h3>

<p>All the compound data objects we have used so far were constructed ultimately
from numbers.  In this section we extend the representational capability of our
language by introducing the ability to work with arbitrary symbols as data.
</p>

<hr />
<div class="subsection-level-extent" id="g_t2_002e3_002e1">
<h4 class="subsection" id="Quotation"><span>2.3.1 Quotation<a class="copiable-link" href="#Quotation"> &#182;</a></span></h4>

<p>If we can form compound data using symbols, we can have lists such as
</p>
<div class="example">
<pre class="example-preformatted">// In Rust, we use arrays/vectors and enums for symbolic data:
vec![&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]
vec![23, 45, 17]
vec![(&quot;Norah&quot;, 12), (&quot;Molly&quot;, 9), (&quot;Anna&quot;, 7), (&quot;Lauren&quot;, 6), (&quot;Charlotte&quot;, 4)]
</pre></div>

<p>Lists containing symbols can look just like the expressions of our
language:
</p>
<div class="example">
<pre class="example-preformatted">// Expressions as data - in Rust, we define an AST enum:
// Mul(Add(23, 45), Add(Var(&quot;x&quot;), 9))
fn fact(n: u64) -&gt; u64 {
    if n == 1 { 1 } else { n * fact(n - 1) }
}
</pre></div>

<p>In order to manipulate symbols we need a new element in our language: the
ability to <a class="index-entry-id" id="index-quote"></a>
<em class="dfn">quote</em> a data object.  Suppose we want to construct the
list <code class="code">(a b)</code>.  We can&#8217;t accomplish this with <code class="code">(list a b)</code>, because
this expression constructs a list of the <a class="index-entry-id" id="index-values"></a>
<em class="dfn">values</em> of <code class="code">a</code> and
<code class="code">b</code> rather than the symbols themselves.  This issue is well known in the
context of natural languages, where words and sentences may be regarded either
as semantic entities or as character strings (syntactic entities).  The common
practice in natural languages is to use quotation marks to indicate that a word
or a sentence is to be treated literally as a string of characters.  For
instance, the first letter of &#8220;John&#8221; is clearly &#8220;J.&#8221;  If we tell somebody
&#8220;say your name aloud,&#8221; we expect to hear that person&#8217;s name.  However, if we
tell somebody &#8220;say &#8216;your name&#8217; aloud,&#8221; we expect to hear the words &#8220;your
name.&#8221;  Note that we are forced to nest quotation marks to describe what
somebody else might say.<a class="footnote" id="DOCF91" href="#FOOT91"><sup>91</sup></a>
</p>
<p>We can follow this same practice to identify lists and symbols that are to be
treated as data objects rather than as expressions to be evaluated.  However,
our format for quoting differs from that of natural languages in that we place
a quotation mark (traditionally, the single quote symbol&#160;<code class="code">'</code>)<!-- /@w --> only at the
beginning of the object to be quoted.  We can get away with this in Scheme
syntax because we rely on blanks and parentheses to delimit objects.  Thus, the
meaning of the single quote character is to quote the next object.<a class="footnote" id="DOCF92" href="#FOOT92"><sup>92</sup></a>
</p>
<p>Now we can distinguish between symbols and their values:
</p>
<div class="example">
<pre class="example-preformatted">let a = 1;
let b = 2;

vec![a, b]
// =&gt; [1, 2]

// For symbolic data, we use string literals or an enum:
vec![&quot;a&quot;, &quot;b&quot;]
// =&gt; [&quot;a&quot;, &quot;b&quot;]

// Mixing symbols and values requires an enum:
enum Item { Sym(&amp;'static str), Num(i32) }
vec![Item::Sym(&quot;a&quot;), Item::Num(b)]
// =&gt; [Sym(&quot;a&quot;), Num(2)]
</pre></div>

<p>Quotation also allows us to type in compound objects, using the conventional
printed representation for lists:<a class="footnote" id="DOCF93" href="#FOOT93"><sup>93</sup></a>
</p>
<div class="example">
<pre class="example-preformatted">let list = vec![&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];
list[0]
// =&gt; &quot;a&quot;

&amp;list[1..]
// =&gt; [&quot;b&quot;, &quot;c&quot;]
</pre></div>

<p>In keeping with this, we can obtain the empty list by evaluating <code class="code">'()</code>,
and thus dispense with the variable <code class="code">nil</code>.
</p>
<p>One additional primitive used in manipulating symbols is <code class="code">eq?</code>, which
takes two symbols as arguments and tests whether they are the same.<a class="footnote" id="DOCF94" href="#FOOT94"><sup>94</sup></a>
Using <code class="code">eq?</code>, we can implement a useful procedure called <code class="code">memq</code>.  This
takes two arguments, a symbol and a list.  If the symbol is not contained in
the list (i.e., is not <code class="code">eq?</code> to any item in the list), then <code class="code">memq</code>
returns false.  Otherwise, it returns the sublist of the list beginning with
the first occurrence of the symbol:
</p>
<div class="example">
<pre class="example-preformatted">fn memq&lt;'a, T: PartialEq&gt;(item: &amp;T, x: &amp;'a [T]) -&gt; Option&lt;&amp;'a [T]&gt; {
    match x {
        [] =&gt; None,
        [first, rest &#160;..] if first == item =&gt; Some(x),
        [_, rest &#160;..] =&gt; memq(item, rest),
    }
}
</pre></div>

<p>For example, the value of
</p>
<div class="example">
<pre class="example-preformatted">memq(&amp;&quot;apple&quot;, &amp;[&quot;pear&quot;, &quot;banana&quot;, &quot;prune&quot;])
// =&gt; None
</pre></div>

<p>is false, whereas the value of
</p>
<div class="example">
<pre class="example-preformatted">// Note: nested lists require enum; flat example:
memq(&amp;&quot;apple&quot;, &amp;[&quot;x&quot;, &quot;y&quot;, &quot;apple&quot;, &quot;pear&quot;])
// =&gt; Some([&quot;apple&quot;, &quot;pear&quot;])
</pre></div>

<p>is <code class="code">(apple pear)</code>.
</p>
<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-2_002e53"></a>Exercise 2.53:</strong> What would the interpreter print
in response to evaluating each of the following expressions?
</p>
<div class="example">
<pre class="example-preformatted">vec![&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]                          // =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
vec![vec![&quot;george&quot;]]                         // =&gt; [[&quot;george&quot;]]
&amp;[[&quot;x1&quot;, &quot;x2&quot;], [&quot;y1&quot;, &quot;y2&quot;]][1..]           // =&gt; [[&quot;y1&quot;, &quot;y2&quot;]]
[[&quot;x1&quot;, &quot;x2&quot;], [&quot;y1&quot;, &quot;y2&quot;]][1]              // =&gt; [&quot;y1&quot;, &quot;y2&quot;]
[&quot;a&quot;, &quot;short&quot;, &quot;list&quot;][0].is_empty() == false // &quot;a&quot; is a string, not list
memq(&amp;&quot;red&quot;, &amp;[&quot;red&quot;, &quot;shoes&quot;, &quot;blue&quot;])      // =&gt; Some([&quot;red&quot;, ...])
</pre></div>
</blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-2_002e54"></a>Exercise 2.54:</strong> Two lists are said to be
<code class="code">equal?</code> if they contain equal elements arranged in the same order.  For
example,
</p>
<div class="example">
<pre class="example-preformatted">vec![&quot;this&quot;, &quot;is&quot;, &quot;a&quot;, &quot;list&quot;] == vec![&quot;this&quot;, &quot;is&quot;, &quot;a&quot;, &quot;list&quot;]
// =&gt; true (Rust's == derives PartialEq)
</pre></div>

<p>is true, but
</p>
<div class="example">
<pre class="example-preformatted">// Different structure requires an enum for nested data
// vec![&quot;this&quot;, &quot;is&quot;, &quot;a&quot;, &quot;list&quot;] != vec![&quot;this&quot;, nested, &quot;list&quot;]
// =&gt; false
</pre></div>

<p>is false.  To be more precise, we can define <code class="code">equal?</code>  recursively in
terms of the basic <code class="code">eq?</code> equality of symbols by saying that <code class="code">a</code> and
<code class="code">b</code> are <code class="code">equal?</code> if they are both symbols and the symbols are
<code class="code">eq?</code>, or if they are both lists such that <code class="code">(car a)</code> is <code class="code">equal?</code>
to <code class="code">(car b)</code> and <code class="code">(cdr a)</code> is <code class="code">equal?</code> to <code class="code">(cdr b)</code>.  Using
this idea, implement <code class="code">equal?</code> as a procedure.<a class="footnote" id="DOCF95" href="#FOOT95"><sup>95</sup></a>
</p></blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-2_002e55"></a>Exercise 2.55:</strong> Eva Lu Ator types to the
interpreter the expression
</p>
<div class="example">
<pre class="example-preformatted">// In Scheme, ''x expands to (quote (quote x))
// (car ''abracadabra) =&gt; 'quote
// In Rust, we would model this with an AST enum:
// Quote(Quote(Symbol(&quot;abracadabra&quot;)))
// first element is: Quote
</pre></div>

<p>To her surprise, the interpreter prints back <code class="code">quote</code>.  Explain.
</p></blockquote>

<hr />
</div>
<div class="subsection-level-extent" id="g_t2_002e3_002e2">
<h4 class="subsection" id="Example_003a-Symbolic-Differentiation"><span>2.3.2 Example: Symbolic Differentiation<a class="copiable-link" href="#Example_003a-Symbolic-Differentiation"> &#182;</a></span></h4>

<p>As an illustration of symbol manipulation and a further illustration of data
abstraction, consider the design of a procedure that performs symbolic
differentiation of algebraic expressions.  We would like the procedure to take
as arguments an algebraic expression and a variable and to return the
derivative of the expression with respect to the variable.  For example, if the
arguments to the procedure are <em class="math">{ax^2 + bx + c}</em> and <em class="math">x</em>, the
procedure should return <em class="math">{2ax + b}</em>.  Symbolic differentiation is of
special historical significance in Lisp.  It was one of the motivating examples
behind the development of a computer language for symbol manipulation.
Furthermore, it marked the beginning of the line of research that led to the
development of powerful systems for symbolic mathematical work, which are
currently being used by a growing number of applied mathematicians and
physicists.
</p>
<p>In developing the symbolic-differentiation program, we will follow the same
strategy of data abstraction that we followed in developing the rational-number
system of <a class="ref" href="2_002e1.xhtml#g_t2_002e1_002e1">Example: Arithmetic Operations for Rational Numbers</a>.  That is, we will first define a differentiation
algorithm that operates on abstract objects such as &#8220;sums,&#8221; &#8220;products,&#8221; and
&#8220;variables&#8221; without worrying about how these are to be represented.  Only
afterward will we address the representation problem.
</p>
<h4 class="subsubheading" id="The-differentiation-program-with-abstract-data"><span>The differentiation program with abstract data<a class="copiable-link" href="#The-differentiation-program-with-abstract-data"> &#182;</a></span></h4>

<p>In order to keep things simple, we will consider a very simple
symbolic-differentiation program that handles expressions that are built up
using only the operations of addition and multiplication with two arguments.
Differentiation of any such expression can be carried out by applying the
following reduction rules:
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
  <mrow data-mjx-texclass="ORD">
    <mrow data-mjx-texclass="ORD">
      <mfrac>
        <mrow>
          <mi>d</mi>
          <mi>c</mi>
        </mrow>
        <mrow>
          <mi>d</mi>
          <mi>x</mi>
        </mrow>
      </mfrac>
    </mrow>
    <mstyle scriptlevel="0">
      <mspace width="0.167em"></mspace>
    </mstyle>
    <mo>=</mo>
    <mstyle scriptlevel="0">
      <mspace width="0.167em"></mspace>
    </mstyle>
    <mn>0</mn>
    <mo>,</mo>
  </mrow>
  <mstyle scriptlevel="0">
    <mspace width="1em"></mspace>
  </mstyle>
  <mrow data-mjx-texclass="ORD">
    <mtext>for&#xA0;</mtext>
    <mi>c</mi>
    <mtext>&#xA0;a constant&#xA0;</mtext>
  </mrow>
  <mrow data-mjx-texclass="ORD">
    <mtext>or a variable&#xA0;</mtext>
  </mrow>
  <mrow data-mjx-texclass="ORD">
    <mtext>different from&#xA0;</mtext>
    <mi>x</mi>
    <mo>,</mo>
  </mrow>
</math>
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
  <mtable displaystyle="true" columnalign="right center left" columnspacing="0em 0.278em" rowspacing="3pt">
    <mtr>
      <mtd>
        <mrow data-mjx-texclass="ORD">
          <mfrac>
            <mrow>
              <mi>d</mi>
              <mi>x</mi>
            </mrow>
            <mrow>
              <mi>d</mi>
              <mi>x</mi>
            </mrow>
          </mfrac>
        </mrow>
      </mtd>
      <mtd>
        <mi>a</mi>
        <mi>m</mi>
        <mi>p</mi>
        <mo>;</mo>
        <mo>=</mo>
      </mtd>
      <mtd>
        <mi>a</mi>
        <mi>m</mi>
        <mi>p</mi>
        <mo>;</mo>
        <mn>1</mn>
        <mo>,</mo>
      </mtd>
    </mtr>
    <mtr>
      <mtd>
        <mrow data-mjx-texclass="ORD">
          <mfrac>
            <mrow>
              <mi>d</mi>
              <mo stretchy="false">(</mo>
              <mi>u</mi>
              <mo>+</mo>
              <mi>v</mi>
              <mo stretchy="false">)</mo>
            </mrow>
            <mrow>
              <mi>d</mi>
              <mi>x</mi>
            </mrow>
          </mfrac>
        </mrow>
      </mtd>
      <mtd>
        <mi>a</mi>
        <mi>m</mi>
        <mi>p</mi>
        <mo>;</mo>
        <mo>=</mo>
      </mtd>
      <mtd>
        <mi>a</mi>
        <mi>m</mi>
        <mi>p</mi>
        <mo>;</mo>
        <mrow data-mjx-texclass="ORD">
          <mfrac>
            <mrow>
              <mi>d</mi>
              <mi>u</mi>
            </mrow>
            <mrow>
              <mi>d</mi>
              <mi>x</mi>
            </mrow>
          </mfrac>
        </mrow>
        <mo>+</mo>
        <mrow data-mjx-texclass="ORD">
          <mfrac>
            <mrow>
              <mi>d</mi>
              <mi>v</mi>
            </mrow>
            <mrow>
              <mi>d</mi>
              <mi>x</mi>
            </mrow>
          </mfrac>
        </mrow>
        <mo>,</mo>
      </mtd>
    </mtr>
    <mtr>
      <mtd>
        <mrow data-mjx-texclass="ORD">
          <mfrac>
            <mrow>
              <mi>d</mi>
              <mo stretchy="false">(</mo>
              <mi>u</mi>
              <mi>v</mi>
              <mo stretchy="false">)</mo>
            </mrow>
            <mrow>
              <mi>d</mi>
              <mi>x</mi>
            </mrow>
          </mfrac>
        </mrow>
      </mtd>
      <mtd>
        <mi>a</mi>
        <mi>m</mi>
        <mi>p</mi>
        <mo>;</mo>
        <mo>=</mo>
      </mtd>
      <mtd>
        <mi>a</mi>
        <mi>m</mi>
        <mi>p</mi>
        <mo>;</mo>
        <mi>u</mi>
        <mspace width="0.1em"></mspace>
        <mrow data-mjx-texclass="ORD">
          <mfrac>
            <mrow>
              <mi>d</mi>
              <mi>v</mi>
            </mrow>
            <mrow>
              <mi>d</mi>
              <mi>x</mi>
            </mrow>
          </mfrac>
        </mrow>
        <mo>+</mo>
        <mi>v</mi>
        <mspace width="0.1em"></mspace>
        <mrow data-mjx-texclass="ORD">
          <mfrac>
            <mrow>
              <mi>d</mi>
              <mi>u</mi>
            </mrow>
            <mrow>
              <mi>d</mi>
              <mi>x</mi>
            </mrow>
          </mfrac>
        </mrow>
        <mo>.</mo>
      </mtd>
    </mtr>
  </mtable>
</math>
Observe that the latter two rules are recursive in nature.  That is, to obtain
the derivative of a sum we first find the derivatives of the terms and add
them.  Each of the terms may in turn be an expression that needs to be
decomposed.  Decomposing into smaller and smaller pieces will eventually
produce pieces that are either constants or variables, whose derivatives will
be either 0 or 1.
</p>
<p>To embody these rules in a procedure we indulge in a little wishful thinking,
as we did in designing the rational-number implementation.  If we had a means
for representing algebraic expressions, we should be able to tell whether an
expression is a sum, a product, a constant, or a variable.  We should be able
to extract the parts of an expression.  For a sum, for example we want to be
able to extract the addend (first term) and the augend (second term).  We
should also be able to construct expressions from parts.  Let us assume that we
already have procedures to implement the following selectors, constructors, and
predicates:
</p>
<div class="example">
<pre class="example-preformatted">is_variable(e)         <span class="r">Is <code class="code">e</code> a is_variable</span>
same_variable(v1, v2)  <span class="r">Are <code class="code">v1</code> and <code class="code">v2</code> the same is_variable</span>
is_sum(e)              <span class="r">Is <code class="code">e</code> a sum?</span>
addend(e)              <span class="r">Addend of the sum <code class="code">e</code>.</span>
augend(e)              <span class="r">Augend of the sum <code class="code">e</code>.</span>
make_sum(a1, a2)       <span class="r">Construct the sum of <code class="code">a1</code> and <code class="code">a2</code>.</span>
is_product(e)          <span class="r">Is <code class="code">e</code> a product?</span>
multiplier(e)          <span class="r">Multiplier of the product <code class="code">e</code>.</span>
multiplicand(e)        <span class="r">Multiplicand of the product <code class="code">e</code>.</span>
make_product(m1, m2)   <span class="r">Construct the product of <code class="code">m1</code> and <code class="code">m2</code>.</span>
</pre></div>

<p>Using these, and the primitive predicate <code class="code">number?</code>, which identifies
numbers, we can express the differentiation rules as the following procedure:
</p>
<div class="example">
<pre class="example-preformatted">enum Expr {
    Const(f64),
    Var(&amp;'static str),
    Sum(Box&lt;Expr&gt;, Box&lt;Expr&gt;),
    Product(Box&lt;Expr&gt;, Box&lt;Expr&gt;),
}

use Expr::*;

fn deriv(exp: &amp;Expr, var: &amp;str) -&gt; Expr {
    match exp {
        Const(_) =&gt; Const(0.0),
        Var(v) =&gt; if *v == var { Const(1.0) } else { Const(0.0) },
        Sum(a, b) =&gt; Sum(
            Box::new(deriv(a, var)),
            Box::new(deriv(b, var))
        ),
        Product(m1, m2) =&gt; Sum(
            Box::new(Product(
                m1.clone(),
                Box::new(deriv(m2, var))
            )),
            Box::new(Product(
                Box::new(deriv(m1, var)),
                m2.clone()
            ))
        ),
    }
}
</pre></div>

<p>This <code class="code">deriv</code> procedure incorporates the complete differentiation
algorithm.  Since it is expressed in terms of abstract data, it will work no
matter how we choose to represent algebraic expressions, as long as we design a
proper set of selectors and constructors.  This is the issue we must address
next.
</p>
<h4 class="subsubheading" id="Representing-algebraic-expressions"><span>Representing algebraic expressions<a class="copiable-link" href="#Representing-algebraic-expressions"> &#182;</a></span></h4>

<p>We can imagine many ways to use list structure to represent algebraic
expressions.  For example, we could use lists of symbols that mirror the usual
algebraic notation, representing <em class="math">{ax + b}</em> as the list <code class="code">(a * x + b)</code>.
However, one especially straightforward choice is to use the same
parenthesized prefix notation that Lisp uses for combinations; that is, to
represent <em class="math">{ax + b}</em> as <code class="code">(+ (* a x) b)</code>.  Then our data
representation for the differentiation problem is as follows:
</p>
<ul class="itemize mark-bullet">
<li>Variables are represented by the <code class="code">Var</code> variant of our <code class="code">Expr</code> enum:

<div class="example">
<pre class="example-preformatted">fn is_variable(x: &amp;Expr) -&gt; bool {
    matches!(x, Expr::Var(_))
}
</pre></div>

</li><li>Two variables are the same if the symbols representing them are equal:

<div class="example">
<pre class="example-preformatted">fn same_variable(v1: &amp;Expr, v2: &amp;Expr) -&gt; bool {
    match (v1, v2) {
        (Expr::Var(a), Expr::Var(b)) =&gt; a == b,
        _ =&gt; false,
    }
}
</pre></div>

</li><li>Sums and products are constructed as enum variants with boxed sub-expressions:

<div class="example">
<pre class="example-preformatted">fn make_sum(a1: Expr, a2: Expr) -&gt; Expr {
    Expr::Sum(Box::new(a1), Box::new(a2))
}

fn make_product(m1: Expr, m2: Expr) -&gt; Expr {
    Expr::Product(Box::new(m1), Box::new(m2))
}
</pre></div>

</li><li>In Rust, predicates like <code class="code">is_sum</code> and selectors like <code class="code">addend</code> are
replaced by pattern matching.  A sum is identified by the <code class="code">Sum</code> variant,
and its components are extracted directly in the match arm:

<div class="example">
<pre class="example-preformatted">// Instead of separate predicates and selectors, we pattern match:
match expr {
    Expr::Sum(addend, augend) =&gt; {
        // addend and augend are directly available
    }
    Expr::Product(multiplier, multiplicand) =&gt; {
        // multiplier and multiplicand are directly available
    }
    // ...
}
</pre></div>

</li></ul>

<p>Thus, we need only combine these with the algorithm as embodied by <code class="code">deriv</code>
in order to have a working symbolic-differentiation program.  Let us look at
some examples of its behavior:
</p>
<div class="example">
<pre class="example-preformatted">deriv(&amp;make_sum(var(&quot;x&quot;), num(3.0)), &quot;x&quot;)
// =&gt; Sum(Const(1.0), Const(0.0))

deriv(&amp;make_product(var(&quot;x&quot;), var(&quot;y&quot;)), &quot;x&quot;)
// =&gt; Sum(Product(Var(&quot;x&quot;), Const(0.0)),
//        Product(Const(1.0), Var(&quot;y&quot;)))

deriv(&amp;make_product(
    make_product(var(&quot;x&quot;), var(&quot;y&quot;)),
    make_sum(var(&quot;x&quot;), num(3.0))
), &quot;x&quot;)
// =&gt; Sum(Product(Product(x, y), Sum(1, 0)),
//        Product(Sum(Product(x, 0), Product(1, y)),
//                Sum(x, 3)))
</pre></div>

<p>The program produces answers that are correct; however, they are unsimplified.
It is true that
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
  <mrow data-mjx-texclass="ORD">
    <mfrac>
      <mrow>
        <mi>d</mi>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mi>y</mi>
        <mo stretchy="false">)</mo>
      </mrow>
      <mrow>
        <mi>d</mi>
        <mi>x</mi>
      </mrow>
    </mfrac>
  </mrow>
  <mstyle scriptlevel="0">
    <mspace width="0.167em"></mspace>
  </mstyle>
  <mo>=</mo>
  <mstyle scriptlevel="0">
    <mspace width="0.167em"></mspace>
  </mstyle>
  <mrow data-mjx-texclass="ORD">
    <mi>x</mi>
    <mo>&#x22C5;</mo>
    <mn>0</mn>
  </mrow>
  <mo>+</mo>
  <mrow data-mjx-texclass="ORD">
    <mn>1</mn>
    <mo>&#x22C5;</mo>
    <mi>y</mi>
    <mo>,</mo>
  </mrow>
</math>
but we would like the program to know that <em class="math">{x · 0 = 0}</em>, <em class="math">{1 · y = y}</em>,
and <em class="math">{0 + y = y}</em>.  The answer for the second example should have been
simply <code class="code">y</code>.  As the third example shows, this becomes a serious issue when
the expressions are complex.
</p>
<p>Our difficulty is much like the one we encountered with the rational-number
implementation: we haven&#8217;t reduced answers to simplest form.  To accomplish the
rational-number reduction, we needed to change only the constructors and the
selectors of the implementation.  We can adopt a similar strategy here.  We
won&#8217;t change <code class="code">deriv</code> at all.  Instead, we will change <code class="code">make-sum</code> so
that if both summands are numbers, <code class="code">make-sum</code> will add them and return
their sum.  Also, if one of the summands is 0, then <code class="code">make-sum</code> will return
the other summand:
</p>
<div class="example">
<pre class="example-preformatted">fn make_sum(a1: Expr, a2: Expr) -&gt; Expr {
    match (&amp;a1, &amp;a2) {
        (Expr::Const(0.0), _) =&gt; a2,
        (_, Expr::Const(0.0)) =&gt; a1,
        (Expr::Const(n1), Expr::Const(n2)) =&gt; Expr::Const(n1 + n2),
        _ =&gt; Expr::Sum(Box::new(a1), Box::new(a2)),
    }
}
</pre></div>

<p>In Rust, pattern matching directly checks whether an expression is a constant
with a particular value, eliminating the need for a separate <code class="code">=number?</code>
predicate.
</p>
<p>Similarly, we will change <code class="code">make-product</code> to build in the rules that 0
times anything is 0 and 1 times anything is the thing itself:
</p>
<div class="example">
<pre class="example-preformatted">fn make_product(m1: Expr, m2: Expr) -&gt; Expr {
    match (&amp;m1, &amp;m2) {
        (Expr::Const(0.0), _) | (_, Expr::Const(0.0)) =&gt; Expr::Const(0.0),
        (Expr::Const(1.0), _) =&gt; m2,
        (_, Expr::Const(1.0)) =&gt; m1,
        (Expr::Const(n1), Expr::Const(n2)) =&gt; Expr::Const(n1 * n2),
        _ =&gt; Expr::Product(Box::new(m1), Box::new(m2)),
    }
}
</pre></div>

<p>Here is how this version works on our three examples:
</p>
<div class="example">
<pre class="example-preformatted">deriv(&amp;make_sum(var(&quot;x&quot;), num(3.0)), &quot;x&quot;)
// =&gt; Const(1.0)

deriv(&amp;make_product(var(&quot;x&quot;), var(&quot;y&quot;)), &quot;x&quot;)
// =&gt; Var(&quot;y&quot;)

deriv(&amp;make_product(
    make_product(var(&quot;x&quot;), var(&quot;y&quot;)),
    make_sum(var(&quot;x&quot;), num(3.0))
), &quot;x&quot;)
// =&gt; Sum(Product(Var(&quot;x&quot;), Var(&quot;y&quot;)),
//        Product(Var(&quot;y&quot;), Sum(Var(&quot;x&quot;), Const(3.0))))
</pre></div>

<p>Although this is quite an improvement, the third example shows that there is
still a long way to go before we get a program that puts expressions into a
form that we might agree is &#8220;simplest.&#8221;  The problem of algebraic
simplification is complex because, among other reasons, a form that may be
simplest for one purpose may not be for another.
</p>
<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-2_002e56"></a>Exercise 2.56:</strong> Show how to extend the basic
differentiator to handle more kinds of expressions.  For instance, implement
the differentiation rule
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
  <mrow data-mjx-texclass="ORD">
    <mfrac>
      <mrow>
        <mi>d</mi>
        <mo stretchy="false">(</mo>
        <msup>
          <mi>u</mi>
          <mrow data-mjx-texclass="ORD">
            <mspace width="0.1ex"></mspace>
            <mi>n</mi>
          </mrow>
        </msup>
        <mo stretchy="false">)</mo>
      </mrow>
      <mrow>
        <mi>d</mi>
        <mi>x</mi>
      </mrow>
    </mfrac>
  </mrow>
  <mstyle scriptlevel="0">
    <mspace width="0.167em"></mspace>
  </mstyle>
  <mo>=</mo>
  <mstyle scriptlevel="0">
    <mspace width="0.167em"></mspace>
  </mstyle>
  <mrow data-mjx-texclass="ORD">
    <mi>n</mi>
    <msup>
      <mi>u</mi>
      <mrow data-mjx-texclass="ORD">
        <mspace width="0.1ex"></mspace>
        <mi>n</mi>
        <mo>&#x2212;</mo>
        <mn>1</mn>
      </mrow>
    </msup>
    <mstyle scriptlevel="0">
      <mspace width="0.167em"></mspace>
    </mstyle>
    <mrow data-mjx-texclass="ORD">
      <mfrac>
        <mrow>
          <mi>d</mi>
          <mi>u</mi>
        </mrow>
        <mrow>
          <mi>d</mi>
          <mi>x</mi>
        </mrow>
      </mfrac>
    </mrow>
  </mrow>
</math>
by adding a new clause to the <code class="code">deriv</code> program and defining appropriate
procedures <code class="code">exponentiation?</code>, <code class="code">base</code>, <code class="code">exponent</code>, and
<code class="code">make-exponentiation</code>.  (You may use the symbol <code class="code">**</code> to denote
exponentiation.)  Build in the rules that anything raised to the power 0 is 1
and anything raised to the power 1 is the thing itself.
</p></blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-2_002e57"></a>Exercise 2.57:</strong> Extend the differentiation
program to handle sums and products of arbitrary numbers of (two or more)
terms.  Then the last example above could be expressed as
</p>
<div class="example">
<pre class="example-preformatted">// With variadic sums/products, this could be expressed as:
deriv(&amp;product(vec![var(&quot;x&quot;), var(&quot;y&quot;), sum(vec![var(&quot;x&quot;), num(3.0)])]), &quot;x&quot;)
</pre></div>

<p>Try to do this by changing only the representation for sums and products,
without changing the <code class="code">deriv</code> procedure at all.  For example, the
<code class="code">addend</code> of a sum would be the first term, and the <code class="code">augend</code> would be
the sum of the rest of the terms.
</p></blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-2_002e58"></a>Exercise 2.58:</strong> Suppose we want to modify the
differentiation program so that it works with ordinary mathematical notation,
in which <code class="code">+</code> and <code class="code">*</code> are infix rather than prefix operators.  Since
the differentiation program is defined in terms of abstract data, we can modify
it to work with different representations of expressions solely by changing the
predicates, selectors, and constructors that define the representation of the
algebraic expressions on which the differentiator is to operate.
</p>
<ol class="enumerate" type="a" start="1">
<li> Show how to do this in order to differentiate algebraic expressions presented
in infix form, such as <code class="code">(x + (3 * (x + (y + 2))))</code>.  To simplify the task,
assume that <code class="code">+</code> and <code class="code">*</code> always take two arguments and that
expressions are fully parenthesized.

</li><li> The problem becomes substantially harder if we allow standard algebraic
notation, such as <code class="code">(x + 3 * (x + y + 2))</code>, which drops unnecessary
parentheses and assumes that multiplication is done before addition.  Can you
design appropriate predicates, selectors, and constructors for this notation
such that our derivative program still works?

</li></ol>
</blockquote>

<hr />
</div>
<div class="subsection-level-extent" id="g_t2_002e3_002e3">
<h4 class="subsection" id="Example_003a-Representing-Sets"><span>2.3.3 Example: Representing Sets<a class="copiable-link" href="#Example_003a-Representing-Sets"> &#182;</a></span></h4>

<p>In the previous examples we built representations for two kinds of compound
data objects: rational numbers and algebraic expressions.  In one of these
examples we had the choice of simplifying (reducing) the expressions at either
construction time or selection time, but other than that the choice of a
representation for these structures in terms of lists was straightforward. When
we turn to the representation of sets, the choice of a representation is not so
obvious.  Indeed, there are a number of possible representations, and they
differ significantly from one another in several ways.
</p>
<p>Informally, a set is simply a collection of distinct objects.  To give a more
precise definition we can employ the method of data abstraction.  That is, we
define &#8220;set&#8221; by specifying the operations that are to be used on sets.  These
are <code class="code">union_set</code>, <code class="code">intersection_set</code>, <code class="code">element_of_set</code>, and
<code class="code">adjoin_set</code>.  <code class="code">Element-of-set?</code> is a predicate that determines
whether a given element is a member of a set.  <code class="code">Adjoin-set</code> takes an
object and a set as arguments and returns a set that contains the elements of
the original set and also the adjoined element.  <code class="code">Union-set</code> computes the
union of two sets, which is the set containing each element that appears in
either argument.  <code class="code">Intersection-set</code> computes the intersection of two
sets, which is the set containing only elements that appear in both arguments.
From the viewpoint of data abstraction, we are free to design any
representation that implements these operations in a way consistent with the
interpretations given above.<a class="footnote" id="DOCF96" href="#FOOT96"><sup>96</sup></a>
</p>
<h4 class="subsubheading" id="Sets-as-unordered-lists"><span>Sets as unordered lists<a class="copiable-link" href="#Sets-as-unordered-lists"> &#182;</a></span></h4>

<p>One way to represent a set is as a list of its elements in which no element
appears more than once.  The empty set is represented by the empty list.  In
this representation, <code class="code">element_of_set</code> is similar to the procedure
<code class="code">memq</code> of <a class="ref" href="#g_t2_002e3_002e1">Quotation</a>.  It uses <code class="code">equal?</code>  instead of
<code class="code">eq?</code> so that the set elements need not be symbols:
</p>
<div class="example">
<pre class="example-preformatted">fn element_of_set&lt;T: PartialEq&gt;(x: &amp;T, set: &amp;[T]) -&gt; bool {
    set.iter().any(|elem| elem == x)
}
</pre></div>

<p>Using this, we can write <code class="code">adjoin_set</code>.  If the object to be adjoined is
already in the set, we just return the set.  Otherwise, we use <code class="code">cons</code> to
add the object to the list that represents the set:
</p>
<div class="example">
<pre class="example-preformatted">fn adjoin_set&lt;T: PartialEq + Clone&gt;(x: T, set: &amp;[T]) -&gt; Vec&lt;T&gt; {
    if element_of_set(&amp;x, set) {
        set.to_vec()
    } else {
        let mut result = vec![x];
        result.extend(set.iter().cloned());
        result
    }
}
</pre></div>

<p>For <code class="code">intersection_set</code> we can use a recursive strategy.  If we know how to
form the intersection of <code class="code">set2</code> and the <code class="code">cdr</code> of <code class="code">set1</code>, we only
need to decide whether to include the <code class="code">car</code> of <code class="code">set1</code> in this.  But
this depends on whether <code class="code">(car set1)</code> is also in <code class="code">set2</code>.  Here is the
resulting procedure:
</p>
<div class="example">
<pre class="example-preformatted">fn intersection_set&lt;T: PartialEq + Clone&gt;(set1: &amp;[T], set2: &amp;[T]) -&gt; Vec&lt;T&gt; {
    set1.iter()
        .filter(|&amp;x| element_of_set(x, set2))
        .cloned()
        .collect()
}
</pre></div>

<p>In designing a representation, one of the issues we should be concerned with is
efficiency.  Consider the number of steps required by our set operations.
Since they all use <code class="code">element_of_set</code>, the speed of this operation has a
major impact on the efficiency of the set implementation as a whole.  Now, in
order to check whether an object is a member of a set, <code class="code">element_of_set</code>
may have to scan the entire set. (In the worst case, the object turns out not
to be in the set.)  Hence, if the set has <em class="math">n</em> elements,
<code class="code">element_of_set</code>  might take up to <em class="math">n</em> steps.  Thus, the number of
steps required grows as <em class="math">{Θ(n)}</em>.  The number of steps required by
<code class="code">adjoin_set</code>, which uses this operation, also grows as <em class="math">{Θ(n)}</em>.
For <code class="code">intersection_set</code>, which does an <code class="code">element_of_set</code> check for
each element of <code class="code">set1</code>, the number of steps required grows as the product
of the sizes of the sets involved, or <em class="math">{Θ(n^2)}</em> for two sets of size
<em class="math">n</em>.  The same will be true of <code class="code">union_set</code>.
</p>
<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-2_002e59"></a>Exercise 2.59:</strong> Implement the <code class="code">union_set</code>
operation for the unordered-list representation of sets.
</p></blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-2_002e60"></a>Exercise 2.60:</strong> We specified that a set would be
represented as a list with no duplicates.  Now suppose we allow duplicates.
For instance, the set <em class="math">{\{1, 2, 3\}}</em> could be represented as the list <code class="code">(2 3 2 1
3 2 2)</code>.  Design procedures <code class="code">element_of_set</code>, <code class="code">adjoin_set</code>,
<code class="code">union_set</code>, and <code class="code">intersection_set</code> that operate on this
representation.  How does the efficiency of each compare with the corresponding
procedure for the non-duplicate representation?  Are there applications for
which you would use this representation in preference to the non-duplicate one?
</p></blockquote>

<h4 class="subsubheading" id="Sets-as-ordered-lists"><span>Sets as ordered lists<a class="copiable-link" href="#Sets-as-ordered-lists"> &#182;</a></span></h4>

<p>One way to speed up our set operations is to change the representation so that
the set elements are listed in increasing order.  To do this, we need some way
to compare two objects so that we can say which is bigger.  For example, we
could compare symbols lexicographically, or we could agree on some method for
assigning a unique number to an object and then compare the elements by
comparing the corresponding numbers.  To keep our discussion simple, we will
consider only the case where the set elements are numbers, so that we can
compare elements using <code class="code">&gt;</code> and <code class="code">&lt;</code>.  We will represent a set of
numbers by listing its elements in increasing order.  Whereas our first
representation above allowed us to represent the set <em class="math">{\{1, 3, 6, 10\}}</em> by listing
the elements in any order, our new representation allows only the list <code class="code">(1
3 6 10)</code>.
</p>
<p>One advantage of ordering shows up in <code class="code">element_of_set</code>: In checking for
the presence of an item, we no longer have to scan the entire set.  If we reach
a set element that is larger than the item we are looking for, then we know
that the item is not in the set:
</p>
<div class="example">
<pre class="example-preformatted">fn element_of_ordered_set&lt;T: Ord&gt;(x: &amp;T, set: &amp;[T]) -&gt; bool {
    for elem in set {
        match x.cmp(elem) {
            std::cmp::Ordering::Equal =&gt; return true,
            std::cmp::Ordering::Less =&gt; return false,
            std::cmp::Ordering::Greater =&gt; continue,
        }
    }
    false
}
</pre></div>

<p>How many steps does this save?  In the worst case, the item we are looking for
may be the largest one in the set, so the number of steps is the same as for
the unordered representation.  On the other hand, if we search for items of
many different sizes we can expect that sometimes we will be able to stop
searching at a point near the beginning of the list and that other times we
will still need to examine most of the list.  On the average we should expect
to have to examine about half of the items in the set.  Thus, the average
number of steps required will be about <em class="math">{n / 2}</em>.  This is still
<em class="math">{Θ(n)}</em> growth, but it does save us, on the average, a factor of 2
in number of steps over the previous implementation.
</p>
<p>We obtain a more impressive speedup with <code class="code">intersection_set</code>.  In the
unordered representation this operation required <em class="math">{Θ(n^2)}</em> steps,
because we performed a complete scan of <code class="code">set2</code> for each element of
<code class="code">set1</code>.  But with the ordered representation, we can use a more clever
method.  Begin by comparing the initial elements, <code class="code">x1</code> and <code class="code">x2</code>, of
the two sets.  If <code class="code">x1</code> equals <code class="code">x2</code>, then that gives an element of the
intersection, and the rest of the intersection is the intersection of the
<code class="code">cdr</code>-s of the two sets.  Suppose, however, that <code class="code">x1</code> is less than
<code class="code">x2</code>.  Since <code class="code">x2</code> is the smallest element in <code class="code">set2</code>, we can
immediately conclude that <code class="code">x1</code> cannot appear anywhere in <code class="code">set2</code> and
hence is not in the intersection.  Hence, the intersection is equal to the
intersection of <code class="code">set2</code> with the <code class="code">cdr</code> of <code class="code">set1</code>.  Similarly, if
<code class="code">x2</code> is less than <code class="code">x1</code>, then the intersection is given by the
intersection of <code class="code">set1</code> with the <code class="code">cdr</code> of <code class="code">set2</code>.  Here is the
procedure:
</p>
<div class="example">
<pre class="example-preformatted">fn intersection_ordered_set&lt;T: Ord + Clone&gt;(set1: &amp;[T], set2: &amp;[T]) -&gt; Vec&lt;T&gt; {
    let mut result = Vec::new();
    let (mut i, mut j) = (0, 0);
    while i &lt; set1.len() &amp;&amp; j &lt; set2.len() {
        match set1[i].cmp(&amp;set2[j]) {
            std::cmp::Ordering::Equal =&gt; {
                result.push(set1[i].clone());
                i += 1;
                j += 1;
            }
            std::cmp::Ordering::Less =&gt; i += 1,
            std::cmp::Ordering::Greater =&gt; j += 1,
        }
    }
    result
}
</pre></div>

<p>To estimate the number of steps required by this process, observe that at each
step we reduce the intersection problem to computing intersections of smaller
sets&#8212;removing the first element from <code class="code">set1</code> or <code class="code">set2</code> or both.
Thus, the number of steps required is at most the sum of the sizes of
<code class="code">set1</code> and <code class="code">set2</code>, rather than the product of the sizes as with the
unordered representation.  This is <em class="math">{Θ(n)}</em> growth rather than
<em class="math">{Θ(n^2)}</em>&#8212;a considerable speedup, even for sets of moderate size.
</p>
<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-2_002e61"></a>Exercise 2.61:</strong> Give an implementation of
<code class="code">adjoin_set</code> using the ordered representation.  By analogy with
<code class="code">element_of_set</code> show how to take advantage of the ordering to produce a
procedure that requires on the average about half as many steps as with the
unordered representation.
</p></blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-2_002e62"></a>Exercise 2.62:</strong> Give a <em class="math">{Θ(n)}</em>
implementation of <code class="code">union_set</code> for sets represented as ordered lists.
</p></blockquote>

<h4 class="subsubheading" id="Sets-as-binary-trees"><span>Sets as binary trees<a class="copiable-link" href="#Sets-as-binary-trees"> &#182;</a></span></h4>

<p>We can do better than the ordered-list representation by arranging the set
elements in the form of a tree.  Each node of the tree holds one element of the
set, called the &#8220;entry&#8221; at that node, and a link to each of two other
(possibly empty) nodes.  The &#8220;left&#8221; link points to elements smaller than the
one at the node, and the &#8220;right&#8221; link to elements greater than the one at the
node.  <a class="ref" href="#Figure-2_002e16">Figure 2.16</a> shows some trees that represent the set
<em class="math">{\{1, 3, 5, 7, 9, 11\}}</em>.  The same set may be represented by a tree in a number of
different ways.  The only thing we require for a valid representation is that
all elements in the left subtree be smaller than the node entry and that all
elements in the right subtree be larger.
</p>
<div class="float">
<a class="anchor" id="Figure-2_002e16"></a><img class="image" src="fig/chap2/Fig2.16c.std.svg" alt="fig/chap2/Fig2.16c" />
<div class="caption"><p><strong class="strong">Figure 2.16:</strong> Various binary trees that represent the set <em class="math">{\{1, 3, 5, 7, 9, 11\}}</em>.</p></div></div>
<p>The advantage of the tree representation is this: Suppose we want to check
whether a number <em class="math">x</em> is contained in a set.  We begin by comparing <em class="math">x</em> with
the entry in the top node.  If <em class="math">x</em> is less than this, we know that we need
only search the left subtree; if <em class="math">x</em> is greater, we need only search the
right subtree.  Now, if the tree is &#8220;balanced,&#8221; each of these subtrees will
be about half the size of the original.  Thus, in one step we have reduced the
problem of searching a tree of size <em class="math">n</em> to searching a tree of size <em class="math">{n / 2}</em>.
Since the size of the tree is halved at each step, we should expect that the
number of steps needed to search a tree of size <em class="math">n</em> grows as
<em class="math">{Θ(log n)}</em>.<a class="footnote" id="DOCF97" href="#FOOT97"><sup>97</sup></a> For large sets, this will be a
significant speedup over the previous representations.
</p>
<p>We can represent trees by using lists.  Each node will be a list of three
items: the entry at the node, the left subtree, and the right subtree.  A left
or a right subtree of the empty list will indicate that there is no subtree
connected there.  We can describe this representation by the following
procedures:<a class="footnote" id="DOCF98" href="#FOOT98"><sup>98</sup></a>
</p>
<div class="example">
<pre class="example-preformatted">#[derive(Debug, Clone)]
enum Tree&lt;T&gt; {
    Empty,
    Node {
        entry: T,
        left: Box&lt;Tree&lt;T&gt;&gt;,
        right: Box&lt;Tree&lt;T&gt;&gt;,
    },
}

fn make_tree&lt;T&gt;(entry: T, left: Tree&lt;T&gt;, right: Tree&lt;T&gt;) -&gt; Tree&lt;T&gt; {
    Tree::Node {
        entry,
        left: Box::new(left),
        right: Box::new(right),
    }
}
</pre></div>

<p>Now we can write the <code class="code">element_of_set</code> procedure using the strategy
described above:
</p>
<div class="example">
<pre class="example-preformatted">fn element_of_tree&lt;T: Ord&gt;(x: &amp;T, tree: &amp;Tree&lt;T&gt;) -&gt; bool {
    match tree {
        Tree::Empty =&gt; false,
        Tree::Node { entry, left, right } =&gt; match x.cmp(entry) {
            std::cmp::Ordering::Equal =&gt; true,
            std::cmp::Ordering::Less =&gt; element_of_tree(x, left),
            std::cmp::Ordering::Greater =&gt; element_of_tree(x, right),
        },
    }
}
</pre></div>

<p>Adjoining an item to a set is implemented similarly and also requires
<em class="math">{Θ(log n)}</em> steps.  To adjoin an item <code class="code">x</code>, we compare
<code class="code">x</code> with the node entry to determine whether <code class="code">x</code> should be added to
the right or to the left branch, and having adjoined <code class="code">x</code> to the
appropriate branch we piece this newly constructed branch together with the
original entry and the other branch.  If <code class="code">x</code> is equal to the entry, we
just return the node.  If we are asked to adjoin <code class="code">x</code> to an empty tree, we
generate a tree that has <code class="code">x</code> as the entry and empty right and left
branches.  Here is the procedure:
</p>
<div class="example">
<pre class="example-preformatted">fn adjoin_tree&lt;T: Ord + Clone&gt;(x: T, tree: Tree&lt;T&gt;) -&gt; Tree&lt;T&gt; {
    match tree {
        Tree::Empty =&gt; make_tree(x, Tree::Empty, Tree::Empty),
        Tree::Node { entry, left, right } =&gt; match x.cmp(&amp;entry) {
            std::cmp::Ordering::Equal =&gt; Tree::Node { entry, left, right },
            std::cmp::Ordering::Less =&gt; make_tree(
                entry,
                adjoin_tree(x, *left),
                *right,
            ),
            std::cmp::Ordering::Greater =&gt; make_tree(
                entry,
                *left,
                adjoin_tree(x, *right),
            ),
        },
    }
}
</pre></div>

<p>The above claim that searching the tree can be performed in a logarithmic
number of steps rests on the assumption that the tree is &#8220;balanced,&#8221; i.e.,
that the left and the right subtree of every tree have approximately the same
number of elements, so that each subtree contains about half the elements of
its parent.  But how can we be certain that the trees we construct will be
balanced?  Even if we start with a balanced tree, adding elements with
<code class="code">adjoin_set</code> may produce an unbalanced result.  Since the position of a
newly adjoined element depends on how the element compares with the items
already in the set, we can expect that if we add elements &#8220;randomly&#8221; the tree
will tend to be balanced on the average.  But this is not a guarantee.  For
example, if we start with an empty set and adjoin the numbers 1 through 7 in
sequence we end up with the highly unbalanced tree shown in <a class="ref" href="#Figure-2_002e17">Figure 2.17</a>.
In this tree all the left subtrees are empty, so it has no advantage over a
simple ordered list.  One way to solve this problem is to define an operation
that transforms an arbitrary tree into a balanced tree with the same elements.
Then we can perform this transformation after every few <code class="code">adjoin_set</code>
operations to keep our set in balance.  There are also other ways to solve this
problem, most of which involve designing new data structures for which
searching and insertion both can be done in <em class="math">{Θ(log n)}</em>
steps.<a class="footnote" id="DOCF99" href="#FOOT99"><sup>99</sup></a>
</p>
<div class="float">
<a class="anchor" id="Figure-2_002e17"></a><img class="image" src="fig/chap2/Fig2.17a.std.svg" alt="fig/chap2/Fig2.17a" />
<div class="caption"><p><strong class="strong">Figure 2.17:</strong> Unbalanced tree produced by adjoining 1 through 7 in sequence.</p></div></div>
<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-2_002e63"></a>Exercise 2.63:</strong> Each of the following two
procedures converts a binary tree to a list.
</p>
<div class="example">
<pre class="example-preformatted">// Version 1: Using Vec::extend (like append)
fn tree_to_list_1&lt;T: Clone&gt;(tree: &amp;Tree&lt;T&gt;) -&gt; Vec&lt;T&gt; {
    match tree {
        Tree::Empty =&gt; vec![],
        Tree::Node { entry, left, right } =&gt; {
            let mut result = tree_to_list_1(left);
            result.push(entry.clone());
            result.extend(tree_to_list_1(right));
            result
        }
    }
}

// Version 2: Using accumulator (more efficient)
fn tree_to_list_2&lt;T: Clone&gt;(tree: &amp;Tree&lt;T&gt;) -&gt; Vec&lt;T&gt; {
    fn copy_to_list&lt;T: Clone&gt;(tree: &amp;Tree&lt;T&gt;, acc: &amp;mut Vec&lt;T&gt;) {
        if let Tree::Node { entry, left, right } = tree {
            copy_to_list(left, acc);
            acc.push(entry.clone());
            copy_to_list(right, acc);
        }
    }
    let mut result = Vec::new();
    copy_to_list(tree, &amp;mut result);
    result
}
</pre></div>

<ol class="enumerate" type="a" start="1">
<li> Do the two procedures produce the same result for every tree?  If not, how do
the results differ?  What lists do the two procedures produce for the trees in
<a class="ref" href="#Figure-2_002e16">Figure 2.16</a>?

</li><li> Do the two procedures have the same order of growth in the number of steps
required to convert a balanced tree with <em class="math">n</em> elements to a list?  If not,
which one grows more slowly?

</li></ol>
</blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-2_002e64"></a>Exercise 2.64:</strong> The following procedure
<code class="code">list-&gt;tree</code> converts an ordered list to a balanced binary tree.  The
helper procedure <code class="code">partial-tree</code> takes as arguments an integer <em class="math">n</em> and
list of at least <em class="math">n</em> elements and constructs a balanced tree containing the
first <em class="math">n</em> elements of the list.  The result returned by <code class="code">partial-tree</code>
is a pair (formed with <code class="code">cons</code>) whose <code class="code">car</code> is the constructed tree
and whose <code class="code">cdr</code> is the list of elements not included in the tree.
</p>
<div class="example">
<pre class="example-preformatted">fn list_to_tree&lt;T: Clone&gt;(elements: &amp;[T]) -&gt; Tree&lt;T&gt; {
    partial_tree(elements, elements.len()).0
}

fn partial_tree&lt;T: Clone&gt;(elts: &amp;[T], n: usize) -&gt; (Tree&lt;T&gt;, &amp;[T]) {
    if n == 0 {
        (Tree::Empty, elts)
    } else {
        let left_size = (n - 1) / 2;
        let (left_tree, non_left_elts) = partial_tree(elts, left_size);
        let this_entry = non_left_elts[0].clone();
        let right_size = n - left_size - 1;
        let (right_tree, remaining) = partial_tree(&amp;non_left_elts[1..], right_size);
        (make_tree(this_entry, left_tree, right_tree), remaining)
    }
}
</pre></div>

<ol class="enumerate" type="a" start="1">
<li> Write a short paragraph explaining as clearly as you can how
<code class="code">partial-tree</code> works.  Draw the tree produced by <code class="code">list-&gt;tree</code> for
the list <code class="code">(1 3 5 7 9 11)</code>.

</li><li> What is the order of growth in the number of steps required by
<code class="code">list-&gt;tree</code> to convert a list of <em class="math">n</em> elements?

</li></ol>
</blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-2_002e65"></a>Exercise 2.65:</strong> Use the results of <a class="ref" href="#Exercise-2_002e63">Exercise 2.63</a>
and <a class="ref" href="#Exercise-2_002e64">Exercise 2.64</a> to give <em class="math">{Θ(n)}</em> implementations of
<code class="code">union_set</code> and <code class="code">intersection_set</code> for sets implemented as (balanced)
binary trees.<a class="footnote" id="DOCF100" href="#FOOT100"><sup>100</sup></a>
</p></blockquote>

<h4 class="subsubheading" id="Sets-and-information-retrieval"><span>Sets and information retrieval<a class="copiable-link" href="#Sets-and-information-retrieval"> &#182;</a></span></h4>

<p>We have examined options for using lists to represent sets and have seen how
the choice of representation for a data object can have a large impact on the
performance of the programs that use the data.  Another reason for
concentrating on sets is that the techniques discussed here appear again and
again in applications involving information retrieval.
</p>
<p>Consider a data base containing a large number of individual records, such as
the personnel files for a company or the transactions in an accounting system.
A typical data-management system spends a large amount of time accessing or
modifying the data in the records and therefore requires an efficient method
for accessing records.  This is done by identifying a part of each record to
serve as an identifying <a class="index-entry-id" id="index-key"></a>
<em class="dfn">key</em>.  A key can be anything that uniquely
identifies the record.  For a personnel file, it might be an employee&#8217;s ID
number.  For an accounting system, it might be a transaction number.  Whatever
the key is, when we define the record as a data structure we should include a
<code class="code">key</code> selector procedure that retrieves the key associated with a given
record.
</p>
<p>Now we represent the data base as a set of records. To locate the record with a
given key we use a procedure <code class="code">lookup</code>, which takes as arguments a key and
a data base and which returns the record that has that key, or false if there
is no such record.  <code class="code">Lookup</code> is implemented in almost the same way as
<code class="code">element_of_set</code>.  For example, if the set of records is implemented as
an unordered list, we could use
</p>
<div class="example">
<pre class="example-preformatted">fn lookup&lt;'a, K, R&gt;(given_key: &amp;K, set_of_records: &amp;'a [R]) -&gt; Option&lt;&amp;'a R&gt;
where
    K: PartialEq,
    R: HasKey&lt;K&gt;,
{
    set_of_records.iter().find(|record| record.key() == given_key)
}

trait HasKey&lt;K&gt; {
    fn key(&amp;self) -&gt; &amp;K;
}
</pre></div>

<p>Of course, there are better ways to represent large sets than as unordered
lists.  Information-retrieval systems in which records have to be &#8220;randomly
accessed&#8221; are typically implemented by a tree-based method, such as the
binary-tree representation discussed previously.  In designing such a system
the methodology of data abstraction can be a great help.  The designer can
create an initial implementation using a simple, straightforward representation
such as unordered lists.  This will be unsuitable for the eventual system, but
it can be useful in providing a &#8220;quick and dirty&#8221; data base with which to
test the rest of the system.  Later on, the data representation can be modified
to be more sophisticated.  If the data base is accessed in terms of abstract
selectors and constructors, this change in representation will not require any
changes to the rest of the system.
</p>
<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-2_002e66"></a>Exercise 2.66:</strong> Implement the <code class="code">lookup</code>
procedure for the case where the set of records is structured as a binary tree,
ordered by the numerical values of the keys.
</p></blockquote>

<hr />
</div>
<div class="subsection-level-extent" id="g_t2_002e3_002e4">
<h4 class="subsection" id="Example_003a-Huffman-Encoding-Trees"><span>2.3.4 Example: Huffman Encoding Trees<a class="copiable-link" href="#Example_003a-Huffman-Encoding-Trees"> &#182;</a></span></h4>

<p>This section provides practice in the use of list structure and data
abstraction to manipulate sets and trees.  The application is to methods for
representing data as sequences of ones and zeros (bits).  For example, the
ASCII standard code used to represent text in computers encodes each character
as a sequence of seven bits.  Using seven bits allows us to distinguish <em class="math">2^7</em>,
or 128, possible different characters.  In general, if we want to distinguish
<em class="math">n</em> different symbols, we will need to use <em class="math">{log_2n}</em> bits per
symbol.  If all our messages are made up of the eight symbols A, B, C, D, E, F,
G, and H, we can choose a code with three bits per character, for example
</p>
<div class="example">
<pre class="example-preformatted">A 000  C 010  E 100  G 110
B 001  D 011  F 101  H 111
</pre></div>

<p>With this code, the message
</p>
<div class="example">
<pre class="example-preformatted">BACADAEAFABBAAAGAH
</pre></div>

<p>is encoded as the string of 54 bits
</p>
<div class="example">
<pre class="example-preformatted">001000010000011000100000101
000001001000000000110000111
</pre></div>

<p>Codes such as ASCII and the A-through-H code above are known as
<a class="index-entry-id" id="index-fixed_002dlength"></a>
<em class="dfn">fixed-length</em> codes, because they represent each symbol in the message
with the same number of bits.  It is sometimes advantageous to use
<a class="index-entry-id" id="index-variable_002dlength"></a>
<em class="dfn">variable-length</em> codes, in which different symbols may be represented
by different numbers of bits.  For example, Morse code does not use the same
number of dots and dashes for each letter of the alphabet.  In particular, E,
the most frequent letter, is represented by a single dot.  In general, if our
messages are such that some symbols appear very frequently and some very
rarely, we can encode data more efficiently (i.e., using fewer bits per
message) if we assign shorter codes to the frequent symbols.  Consider the
following alternative code for the letters A through H:
</p>
<div class="example">
<pre class="example-preformatted">A 0    C 1010  E 1100  G 1110
B 100  D 1011  F 1101  H 1111
</pre></div>

<p>With this code, the same message as above is encoded as the string
</p>
<div class="example">
<pre class="example-preformatted">100010100101101100011
010100100000111001111
</pre></div>

<p>This string contains 42 bits, so it saves more than 20% in space in comparison
with the fixed-length code shown above.
</p>
<p>One of the difficulties of using a variable-length code is knowing when you
have reached the end of a symbol in reading a sequence of zeros and ones.
Morse code solves this problem by using a special <a class="index-entry-id" id="index-separator-code"></a>
<em class="dfn">separator code</em> (in
this case, a pause) after the sequence of dots and dashes for each letter.
Another solution is to design the code in such a way that no complete code for
any symbol is the beginning (or <a class="index-entry-id" id="index-prefix"></a>
<em class="dfn">prefix</em>) of the code for another
symbol.  Such a code is called a <a class="index-entry-id" id="index-prefix-code"></a>
<em class="dfn">prefix code</em>.  In the example above,
A is encoded by 0 and B is encoded by 100, so no other symbol can have a code
that begins with 0 or with 100.
</p>
<p>In general, we can attain significant savings if we use variable-length prefix
codes that take advantage of the relative frequencies of the symbols in the
messages to be encoded.  One particular scheme for doing this is called the
Huffman encoding method, after its discoverer, David Huffman.  A Huffman code
can be represented as a binary tree whose leaves are the symbols that are
encoded.  At each non-leaf node of the tree there is a set containing all the
symbols in the leaves that lie below the node.  In addition, each symbol at a
leaf is assigned a weight (which is its relative frequency), and each non-leaf
node contains a weight that is the sum of all the weights of the leaves lying
below it.  The weights are not used in the encoding or the decoding process.
We will see below how they are used to help construct the tree.
</p>
<p><a class="ref" href="#Figure-2_002e18">Figure 2.18</a> shows the Huffman tree for the A-through-H code given above.
The weights at the leaves indicate that the tree was designed for messages in
which A appears with relative frequency 8, B with relative frequency 3, and the
other letters each with relative frequency 1.
</p>
<div class="float">
<a class="anchor" id="Figure-2_002e18"></a><img class="image" src="fig/chap2/Fig2.18a.std.svg" alt="fig/chap2/Fig2.18a" />
<div class="caption"><p><strong class="strong">Figure 2.18:</strong> A Huffman encoding tree.</p></div></div>
<p>Given a Huffman tree, we can find the encoding of any symbol by starting at the
root and moving down until we reach the leaf that holds the symbol.  Each time
we move down a left branch we add a 0 to the code, and each time we move down a
right branch we add a 1.  (We decide which branch to follow by testing to see
which branch either is the leaf node for the symbol or contains the symbol in
its set.)  For example, starting from the root of the tree in <a class="ref" href="#Figure-2_002e18">Figure 2.18</a>,
we arrive at the leaf for D by following a right branch, then a left
branch, then a right branch, then a right branch; hence, the code for D is
1011.
</p>
<p>To decode a bit sequence using a Huffman tree, we begin at the root and use the
successive zeros and ones of the bit sequence to determine whether to move down
the left or the right branch.  Each time we come to a leaf, we have generated a
new symbol in the message, at which point we start over from the root of the
tree to find the next symbol.  For example, suppose we are given the tree above
and the sequence 10001010.  Starting at the root, we move down the right
branch, (since the first bit of the string is 1), then down the left branch
(since the second bit is 0), then down the left branch (since the third bit is
also 0).  This brings us to the leaf for B, so the first symbol of the decoded
message is B.  Now we start again at the root, and we make a left move because
the next bit in the string is 0.  This brings us to the leaf for A.  Then we
start again at the root with the rest of the string 1010, so we move right,
left, right, left and reach C.  Thus, the entire message is BAC.
</p>
<h4 class="subsubheading" id="Generating-Huffman-trees"><span>Generating Huffman trees<a class="copiable-link" href="#Generating-Huffman-trees"> &#182;</a></span></h4>

<p>Given an &#8220;alphabet&#8221; of symbols and their relative frequencies, how do we
construct the &#8220;best&#8221; code?  (In other words, which tree will encode messages
with the fewest bits?)  Huffman gave an algorithm for doing this and showed
that the resulting code is indeed the best variable-length code for messages
where the relative frequency of the symbols matches the frequencies with which
the code was constructed.  We will not prove this optimality of Huffman codes
here, but we will show how Huffman trees are constructed.<a class="footnote" id="DOCF101" href="#FOOT101"><sup>101</sup></a>
</p>
<p>The algorithm for generating a Huffman tree is very simple. The idea is to
arrange the tree so that the symbols with the lowest frequency appear farthest
away from the root. Begin with the set of leaf nodes, containing symbols and
their frequencies, as determined by the initial data from which the code is to
be constructed. Now find two leaves with the lowest weights and merge them to
produce a node that has these two nodes as its left and right branches. The
weight of the new node is the sum of the two weights. Remove the two leaves
from the original set and replace them by this new node. Now continue this
process. At each step, merge two nodes with the smallest weights, removing them
from the set and replacing them with a node that has these two as its left and
right branches. The process stops when there is only one node left, which is
the root of the entire tree.  Here is how the Huffman tree of <a class="ref" href="#Figure-2_002e18">Figure 2.18</a>
was generated:
</p>
<div class="example">
<pre class="example-preformatted">Initial {(A 8) (B 3) (C 1) (D 1)
leaves   (E 1) (F 1) (G 1) (H 1)}

Merge   {(A 8) (B 3) ({C D} 2)
         (E 1) (F 1) (G 1) (H 1)}

Merge   {(A 8) (B 3) ({C D} 2)
         ({E F} 2) (G 1) (H 1)}

Merge   {(A 8) (B 3) ({C D} 2)
         ({E F} 2) ({G H} 2)}

Merge   {(A 8) (B 3) ({C D} 2)
         ({E F G H} 4)}

Merge   {(A 8) ({B C D} 5)
         ({E F G H} 4)}

Merge   {(A 8) ({B C D E F G H} 9)}

Final   {({A B C D E F G H} 17)}
merge
</pre></div>

<p>The algorithm does not always specify a unique tree, because there may not be
unique smallest-weight nodes at each step.  Also, the choice of the order in
which the two nodes are merged (i.e., which will be the right branch and which
will be the left branch) is arbitrary.
</p>
<h4 class="subsubheading" id="Representing-Huffman-trees"><span>Representing Huffman trees<a class="copiable-link" href="#Representing-Huffman-trees"> &#182;</a></span></h4>

<p>In the exercises below we will work with a system that uses Huffman trees to
encode and decode messages and generates Huffman trees according to the
algorithm outlined above.  We will begin by discussing how trees are
represented.
</p>
<p>Leaves of the tree are represented by a list consisting of the symbol
<code class="code">leaf</code>, the symbol at the leaf, and the weight:
</p>
<div class="example">
<pre class="example-preformatted">#[derive(Debug, Clone)]
enum HuffmanTree {
    Leaf { symbol: char, weight: u32 },
    Branch {
        left: Box&lt;HuffmanTree&gt;,
        right: Box&lt;HuffmanTree&gt;,
        symbols: Vec&lt;char&gt;,
        weight: u32,
    },
}

fn make_leaf(symbol: char, weight: u32) -&gt; HuffmanTree {
    HuffmanTree::Leaf { symbol, weight }
}
</pre></div>

<p>A general tree will be a list of a left branch, a right branch, a set of
symbols, and a weight.  The set of symbols will be simply a list of the
symbols, rather than some more sophisticated set representation.  When we make
a tree by merging two nodes, we obtain the weight of the tree as the sum of the
weights of the nodes, and the set of symbols as the union of the sets of
symbols for the nodes.  Since our symbol sets are represented as lists, we can
form the union by using the <code class="code">append</code> procedure we defined in
<a class="ref" href="2_002e2.xhtml#g_t2_002e2_002e1">Representing Sequences</a>:
</p>
<div class="example">
<pre class="example-preformatted">fn make_code_tree(left: HuffmanTree, right: HuffmanTree) -&gt; HuffmanTree {
    let symbols = [get_symbols(&amp;left), get_symbols(&amp;right)].concat();
    let weight = get_weight(&amp;left) + get_weight(&amp;right);
    HuffmanTree::Branch {
        left: Box::new(left),
        right: Box::new(right),
        symbols,
        weight,
    }
}
</pre></div>

<p>If we make a tree in this way, we have the following selectors:
</p>
<div class="example">
<pre class="example-preformatted">fn get_symbols(tree: &amp;HuffmanTree) -&gt; Vec&lt;char&gt; {
    match tree {
        HuffmanTree::Leaf { symbol, .. } =&gt; vec![*symbol],
        HuffmanTree::Branch { symbols, .. } =&gt; symbols.clone(),
    }
}

fn get_weight(tree: &amp;HuffmanTree) -&gt; u32 {
    match tree {
        HuffmanTree::Leaf { weight, .. } =&gt; *weight,
        HuffmanTree::Branch { weight, .. } =&gt; *weight,
    }
}
</pre></div>

<p>The procedures <code class="code">symbols</code> and <code class="code">weight</code> must do something slightly
different depending on whether they are called with a leaf or a general tree.
These are simple examples of <a class="index-entry-id" id="index-generic-procedures"></a>
<em class="dfn">generic procedures</em> (procedures that can
handle more than one kind of data), which we will have much more to say about
in <a class="ref" href="2_002e4.xhtml#g_t2_002e4">Multiple Representations for Abstract Data</a> and <a class="ref" href="2_002e5.xhtml#g_t2_002e5">Systems with Generic Operations</a>.
</p>
<h4 class="subsubheading" id="The-decoding-procedure"><span>The decoding procedure<a class="copiable-link" href="#The-decoding-procedure"> &#182;</a></span></h4>

<p>The following procedure implements the decoding algorithm.  It takes as
arguments a list of zeros and ones, together with a Huffman tree.
</p>
<div class="example">
<pre class="example-preformatted">fn decode(bits: &amp;[u8], tree: &amp;HuffmanTree) -&gt; Vec&lt;char&gt; {
    let mut result = Vec::new();
    let mut current = tree;
    for &amp;bit in bits {
        current = choose_branch(bit, current);
        if let HuffmanTree::Leaf { symbol, .. } = current {
            result.push(*symbol);
            current = tree; // restart from root
        }
    }
    result
}

fn choose_branch(bit: u8, branch: &amp;HuffmanTree) -&gt; &amp;HuffmanTree {
    match branch {
        HuffmanTree::Branch { left, right, .. } =&gt; match bit {
            0 =&gt; left,
            1 =&gt; right,
            _ =&gt; panic!(&quot;bad bit: {}&quot;, bit),
        },
        HuffmanTree::Leaf { .. } =&gt; panic!(&quot;cannot branch from leaf&quot;),
    }
}
</pre></div>

<p>The procedure <code class="code">decode-1</code> takes two arguments: the list of remaining bits
and the current position in the tree.  It keeps moving &#8220;down&#8221; the tree,
choosing a left or a right branch according to whether the next bit in the list
is a zero or a one.  (This is done with the procedure <code class="code">choose-branch</code>.)
When it reaches a leaf, it returns the symbol at that leaf as the next symbol
in the message by <code class="code">cons</code>ing it onto the result of decoding the rest of the
message, starting at the root of the tree.  Note the error check in the final
clause of <code class="code">choose-branch</code>, which complains if the procedure finds
something other than a zero or a one in the input data.
</p>
<h4 class="subsubheading" id="Sets-of-weighted-elements"><span>Sets of weighted elements<a class="copiable-link" href="#Sets-of-weighted-elements"> &#182;</a></span></h4>

<p>In our representation of trees, each non-leaf node contains a set of symbols,
which we have represented as a simple list.  However, the tree-generating
algorithm discussed above requires that we also work with sets of leaves and
trees, successively merging the two smallest items.  Since we will be required
to repeatedly find the smallest item in a set, it is convenient to use an
ordered representation for this kind of set.
</p>
<p>We will represent a set of leaves and trees as a list of elements, arranged in
increasing order of weight.  The following <code class="code">adjoin_set</code> procedure for
constructing sets is similar to the one described in <a class="ref" href="#Exercise-2_002e61">Exercise 2.61</a>;
however, items are compared by their weights, and the element being added to
the set is never already in it.
</p>
<div class="example">
<pre class="example-preformatted">fn adjoin_set_weighted(x: HuffmanTree, set: Vec&lt;HuffmanTree&gt;) -&gt; Vec&lt;HuffmanTree&gt; {
    let x_weight = get_weight(&amp;x);
    let pos = set.iter().position(|t| get_weight(t) &gt; x_weight);
    let mut result = set;
    match pos {
        Some(i) =&gt; result.insert(i, x),
        None =&gt; result.push(x),
    }
    result
}
</pre></div>

<p>The following procedure takes a list of symbol-frequency pairs such as
<code class="code">((A 4) (B 2) (C 1) (D 1))</code> and constructs an initial ordered set of
leaves, ready to be merged according to the Huffman algorithm:
</p>
<div class="example">
<pre class="example-preformatted">fn make_leaf_set(pairs: &amp;[(char, u32)]) -&gt; Vec&lt;HuffmanTree&gt; {
    pairs.iter()
        .fold(Vec::new(), |set, &amp;(symbol, freq)| {
            adjoin_set_weighted(make_leaf(symbol, freq), set)
        })
}
</pre></div>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-2_002e67"></a>Exercise 2.67:</strong> Define an encoding tree and a
sample message:
</p>
<div class="example">
<pre class="example-preformatted">let sample_tree = make_code_tree(
    make_leaf('A', 4),
    make_code_tree(
        make_leaf('B', 2),
        make_code_tree(
            make_leaf('D', 1),
            make_leaf('C', 1),
        ),
    ),
);

let sample_message: &amp;[u8] = &amp;[0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0];
</pre></div>

<p>Use the <code class="code">decode</code> procedure to decode the message, and give the result.
</p></blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-2_002e68"></a>Exercise 2.68:</strong> The <code class="code">encode</code> procedure takes
as arguments a message and a tree and produces the list of bits that gives the
encoded message.
</p>
<div class="example">
<pre class="example-preformatted">fn encode(message: &amp;[char], tree: &amp;HuffmanTree) -&gt; Vec&lt;u8&gt; {
    message.iter()
        .flat_map(|symbol| encode_symbol(*symbol, tree))
        .collect()
}
</pre></div>

<p><code class="code">Encode-symbol</code> is a procedure, which you must write, that returns the
list of bits that encodes a given symbol according to a given tree.  You should
design <code class="code">encode-symbol</code> so that it signals an error if the symbol is not in
the tree at all.  Test your procedure by encoding the result you obtained in
<a class="ref" href="#Exercise-2_002e67">Exercise 2.67</a> with the sample tree and seeing whether it is the same as
the original sample message.
</p></blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-2_002e69"></a>Exercise 2.69:</strong> The following procedure takes as
its argument a list of symbol-frequency pairs (where no symbol appears in more
than one pair) and generates a Huffman encoding tree according to the Huffman
algorithm.
</p>
<div class="example">
<pre class="example-preformatted">fn generate_huffman_tree(pairs: &amp;[(char, u32)]) -&gt; HuffmanTree {
    successive_merge(make_leaf_set(pairs))
}
</pre></div>

<p><code class="code">Make-leaf-set</code> is the procedure given above that transforms the list of
pairs into an ordered set of leaves.  <code class="code">Successive-merge</code> is the procedure
you must write, using <code class="code">make-code-tree</code> to successively merge the
smallest-weight elements of the set until there is only one element left, which
is the desired Huffman tree.  (This procedure is slightly tricky, but not
really complicated.  If you find yourself designing a complex procedure, then
you are almost certainly doing something wrong.  You can take significant
advantage of the fact that we are using an ordered set representation.)
</p></blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-2_002e70"></a>Exercise 2.70:</strong> The following eight-symbol
alphabet with associated relative frequencies was designed to efficiently
encode the lyrics of 1950s rock songs.  (Note that the &#8220;symbols&#8221; of an
&#8220;alphabet&#8221; need not be individual letters.)
</p>
<div class="example">
<pre class="example-preformatted">

A    2    NA  16
BOOM 1    SHA  3
GET  2    YIP  9
JOB  2    WAH  1
</pre></div>

<p>Use <code class="code">generate-huffman-tree</code> (<a class="ref" href="#Exercise-2_002e69">Exercise 2.69</a>) to generate a
corresponding Huffman tree, and use <code class="code">encode</code> (<a class="ref" href="#Exercise-2_002e68">Exercise 2.68</a>) to
encode the following message:
</p>
<div class="example">
<pre class="example-preformatted">Get a job
Sha na na na na na na na na

Get a job
Sha na na na na na na na na

Wah yip yip yip yip
yip yip yip yip yip
Sha boom
</pre></div>

<p>How many bits are required for the encoding?  What is the smallest number of
bits that would be needed to encode this song if we used a fixed-length code
for the eight-symbol alphabet?
</p></blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-2_002e71"></a>Exercise 2.71:</strong> Suppose we have a Huffman tree
for an alphabet of <em class="math">n</em> symbols, and that the relative frequencies of the
symbols are <em class="math">{1, 2, 4, …, 2^{n-1}}</em>.  Sketch the tree for <em class="math">{n=5}</em>; for
<em class="math">{n=10}</em>.  In such a tree (for general <em class="math">n</em>) how many bits are required to
encode the most frequent symbol?  The least frequent symbol?
</p></blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-2_002e72"></a>Exercise 2.72:</strong> Consider the encoding procedure
that you designed in <a class="ref" href="#Exercise-2_002e68">Exercise 2.68</a>.  What is the order of growth in the
number of steps needed to encode a symbol?  Be sure to include the number of
steps needed to search the symbol list at each node encountered.  To answer
this question in general is difficult.  Consider the special case where the
relative frequencies of the <em class="math">n</em> symbols are as described in <a class="ref" href="#Exercise-2_002e71">Exercise 2.71</a>,
and give the order of growth (as a function of <em class="math">n</em>) of the number of
steps needed to encode the most frequent and least frequent symbols in the
alphabet.
</p></blockquote>

<hr />
</div>
<div class="subsection-level-extent" id="g_t2_002e3_002e4a">
<h4 class="subsection" id="The-Newtype-Pattern_003a-Zero_002dCost-Type-Safety"><span>2.3.5 The Newtype Pattern: Zero-Cost Type Safety<a class="copiable-link" href="#The-Newtype-Pattern_003a-Zero_002dCost-Type-Safety"> &#182;</a></span></h4>
<a class="index-entry-id" id="index-newtype-pattern"></a>
<a class="index-entry-id" id="index-type-safety"></a>
<a class="index-entry-id" id="index-wrapper-types"></a>
<a class="index-entry-id" id="index-zero_002dcost-abstraction-1"></a>

<p>In the previous section, we saw how Huffman encoding trees use distinct types
to represent leaves and internal nodes. Rust provides a powerful technique
called the <a class="index-entry-id" id="index-newtype-pattern-1"></a>
<em class="dfn">newtype pattern</em> that allows us to create distinct types
with zero runtime cost, enforcing type safety at compile time while maintaining
the same performance as using the underlying type directly.
</p>
<p>The newtype pattern addresses a fundamental challenge in programming: how do we
prevent mixing up values that have the same representation but different
semantic meanings? Consider a system that works with both meters and feet. Both
are represented as <code class="code">f64</code> values, but mixing them up leads to catastrophic
errors&#8212;as NASA discovered when the Mars Climate Orbiter crashed due to a
unit conversion mistake.
</p>
<h4 class="subsubheading" id="Creating-Type_002dSafe-Wrappers"><span>Creating Type-Safe Wrappers<a class="copiable-link" href="#Creating-Type_002dSafe-Wrappers"> &#182;</a></span></h4>

<p>A <a class="index-entry-id" id="index-newtype"></a>
<em class="dfn">newtype</em> is a tuple struct with a single field, creating a new type
that wraps an existing one:
</p>
<div class="example">
<pre class="example-preformatted"><a class="index-entry-id" id="index-units-of-measurement"></a>// Wrapper types for units of measurement
struct Meters(f64);
struct Feet(f64);

// These are distinct types, even though both wrap f64
let distance_m = Meters(100.0);
let distance_ft = Feet(328.0);

// This would cause a compile error:
// let total = distance_m + distance_ft;  // Type mismatch!
</pre></div>

<p>The key insight is that <code class="code">Meters</code> and <code class="code">Feet</code> are <em class="emph">different
types</em> despite having identical memory layouts. The Rust compiler prevents us
from accidentally mixing them, eliminating an entire class of bugs at compile
time with zero runtime cost.
</p>
<p>This pattern extends beyond physical units to any domain where we want to
distinguish values by their semantic meaning rather than their representation:
</p>
<div class="example">
<pre class="example-preformatted"><a class="index-entry-id" id="index-type-aliases-vs-newtypes"></a>// User IDs and Product IDs are both u64, but semantically different
struct UserId(u64);
struct ProductId(u64);

fn get_user(id: UserId) -&gt; User {
    // Implementation
}

fn get_product(id: ProductId) -&gt; Product {
    // Implementation
}

// Type safety prevents mistakes
let user_id = UserId(42);
let product_id = ProductId(100);

get_user(user_id);        // OK
// get_user(product_id);  // Compile error: expected UserId, found ProductId
</pre></div>

<p>Compare this to type aliases, which create synonyms rather than distinct types:
</p>
<div class="example">
<pre class="example-preformatted">type UserId = u64;
type ProductId = u64;

// These are interchangeable---no type safety!
let user_id: UserId = 42;
let product_id: ProductId = 100;
get_user(product_id);  // Compiles but semantically wrong
</pre></div>

<h4 class="subsubheading" id="Transparent-Representation-and-FFI"><span>Transparent Representation and FFI<a class="copiable-link" href="#Transparent-Representation-and-FFI"> &#182;</a></span></h4>

<p>For newtypes that need to interact with foreign functions or have guaranteed
memory layout, Rust provides the <code class="code">#[repr(transparent)]</code> attribute:
</p>
<div class="example">
<pre class="example-preformatted"><a class="index-entry-id" id="index-FFI-_0028Foreign-Function-Interface_0029"></a><a class="index-entry-id" id="index-repr_0028transparent_0029"></a>#[repr(transparent)]
struct FileDescriptor(i32);

// Guaranteed to have the same layout as i32
// Safe to pass across FFI boundaries
extern &quot;C&quot; {
    fn close(fd: FileDescriptor) -&gt; i32;
}
</pre></div>

<p>The <code class="code">#[repr(transparent)]</code> attribute guarantees that the newtype has the
same memory layout, size, and alignment as its inner type. This is essential
for interfacing with C code, as the newtype can be safely passed to and from
foreign functions while maintaining type safety on the Rust side.
</p>
<h4 class="subsubheading" id="Implementing-Traits-on-Newtypes"><span>Implementing Traits on Newtypes<a class="copiable-link" href="#Implementing-Traits-on-Newtypes"> &#182;</a></span></h4>

<p>Newtypes allow us to implement traits on types we don&#8217;t own&#8212;a key workaround
for Rust&#8217;s <a class="index-entry-id" id="index-orphan-rule"></a>
<em class="dfn">orphan rule</em>, which states that we can only implement a
trait if either the trait or the type is defined in our crate.
</p>
<div class="example">
<pre class="example-preformatted"><a class="index-entry-id" id="index-orphan-rule-1"></a><a class="index-entry-id" id="index-trait-implementation"></a>use std::fmt;

struct Meters(f64);

// We can implement Display for our newtype
impl fmt::Display for Meters {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;{} m&quot;, self.0)
    }
}

// We can also implement custom operations
impl Meters {
    fn new(value: f64) -&gt; Self {
        assert!(value &gt;= 0.0, &quot;Distance cannot be negative&quot;);
        Meters(value)
    }

    fn to_feet(&amp;self) -&gt; Feet {
        Feet(self.0 * 3.28084)
    }
}

let distance = Meters::new(100.0);
println!(&quot;Distance: {}&quot;, distance);  // &quot;Distance: 100 m&quot;
</pre></div>

<p>This pattern is particularly powerful when we want to add behavior to external
types. For example, we cannot implement <code class="code">Display</code> directly on <code class="code">Vec&lt;T&gt;</code>
because we don&#8217;t own either <code class="code">Display</code> or <code class="code">Vec</code>. But we can create a
newtype:
</p>
<div class="example">
<pre class="example-preformatted"><a class="index-entry-id" id="index-newtype-for-external-types"></a>struct PrettyVec&lt;T&gt;(Vec&lt;T&gt;);

impl&lt;T: fmt::Display&gt; fmt::Display for PrettyVec&lt;T&gt; {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;[&quot;)?;
        for (i, item) in self.0.iter().enumerate() {
            if i &gt; 0 { write!(f, &quot;, &quot;)?; }
            write!(f, &quot;{}&quot;, item)?;
        }
        write!(f, &quot;]&quot;)
    }
}

let numbers = PrettyVec(vec![1, 2, 3, 4, 5]);
println!(&quot;{}&quot;, numbers);  // &quot;[1, 2, 3, 4, 5]&quot;
</pre></div>

<h4 class="subsubheading" id="Ergonomic-Access-with-Deref"><span>Ergonomic Access with Deref<a class="copiable-link" href="#Ergonomic-Access-with-Deref"> &#182;</a></span></h4>

<p>To make newtypes more ergonomic, we can implement the <code class="code">Deref</code> trait,
allowing the newtype to automatically coerce to its inner type in certain
contexts:
</p>
<div class="example">
<pre class="example-preformatted"><a class="index-entry-id" id="index-Deref-trait"></a><a class="index-entry-id" id="index-deref-coercion"></a>use std::ops::Deref;

struct Meters(f64);

impl Deref for Meters {
    type Target = f64;

    fn deref(&amp;self) -&gt; &amp;Self::Target {
        &amp;self.0
    }
}

let distance = Meters(100.0);
// Can call f64 methods directly
let rounded = distance.round();  // Deref coercion to &amp;f64
let absolute = distance.abs();
</pre></div>

<p>However, use <code class="code">Deref</code> judiciously. It should be implemented only when the
newtype truly <em class="emph">is-a</em> special case of the inner type, not just when it
<em class="emph">has-a</em> inner type. Overuse of <code class="code">Deref</code> can break encapsulation and
lead to confusing APIs. Consider providing explicit methods instead:
</p>
<div class="example">
<pre class="example-preformatted">impl Meters {
    fn value(&amp;self) -&gt; f64 {
        self.0
    }

    fn add(&amp;self, other: &amp;Meters) -&gt; Meters {
        Meters(self.0 + other.0)
    }
}
</pre></div>

<h4 class="subsubheading" id="Type-Conversions-with-From-and-Into"><span>Type Conversions with From and Into<a class="copiable-link" href="#Type-Conversions-with-From-and-Into"> &#182;</a></span></h4>

<p>The <code class="code">From</code> and <code class="code">Into</code> traits enable explicit conversions between
types, making newtypes more ergonomic while maintaining type safety:
</p>
<div class="example">
<pre class="example-preformatted"><a class="index-entry-id" id="index-From-trait"></a><a class="index-entry-id" id="index-Into-trait"></a><a class="index-entry-id" id="index-type-conversion"></a>struct Meters(f64);
struct Feet(f64);

impl From&lt;f64&gt; for Meters {
    fn from(value: f64) -&gt; Self {
        Meters(value)
    }
}

impl From&lt;Meters&gt; for Feet {
    fn from(m: Meters) -&gt; Self {
        Feet(m.0 * 3.28084)
    }
}

// Into is automatically implemented when From is implemented
let distance: Meters = 100.0.into();
let distance_ft: Feet = distance.into();
</pre></div>

<p>Note that Rust automatically provides an <code class="code">Into</code> implementation whenever
we implement <code class="code">From</code>, so we only need to implement one direction. By
convention, implement <code class="code">From</code> unless the conversion can fail, in which
case implement <code class="code">TryFrom</code>.
</p>
<h4 class="subsubheading" id="Zero-Runtime-Cost"><span>Zero Runtime Cost<a class="copiable-link" href="#Zero-Runtime-Cost"> &#182;</a></span></h4>

<p>The newtype pattern is a <a class="index-entry-id" id="index-zero_002dcost-abstraction-2"></a>
<em class="dfn">zero-cost abstraction</em>. The compiler
completely erases the type distinction during compilation, generating identical
machine code to using the wrapped type directly:
</p>
<div class="example">
<pre class="example-preformatted">struct Meters(f64);

fn distance_squared(d: Meters) -&gt; f64 {
    d.0 * d.0
}

fn raw_distance_squared(d: f64) -&gt; f64 {
    d * d
}

// Both functions compile to identical assembly:
// mulsd %xmm0, %xmm0
// ret
</pre></div>

<p>We can verify this with cargo&#8217;s assembly output:
</p>
<div class="example">
<pre class="example-preformatted">cargo rustc --release -- --emit asm
</pre></div>

<p>This is the essence of Rust&#8217;s philosophy: abstractions that provide safety and
clarity without sacrificing performance. The type checking happens entirely at
compile time; at runtime, a <code class="code">Meters</code> is exactly an <code class="code">f64</code>.
</p>
<h4 class="subsubheading" id="Newtypes-in-Practice_003a-Validated-Values"><span>Newtypes in Practice: Validated Values<a class="copiable-link" href="#Newtypes-in-Practice_003a-Validated-Values"> &#182;</a></span></h4>

<p>A powerful application of newtypes is enforcing invariants through construction:
</p>
<div class="example">
<pre class="example-preformatted"><a class="index-entry-id" id="index-invariants"></a><a class="index-entry-id" id="index-validated-types"></a>pub struct NonEmptyString(String);

impl NonEmptyString {
    pub fn new(s: String) -&gt; Option&lt;Self&gt; {
        if s.is_empty() {
            None
        } else {
            Some(NonEmptyString(s))
        }
    }

    // Guaranteed to be non-empty
    pub fn as_str(&amp;self) -&gt; &amp;str {
        &amp;self.0
    }
}

// Once created, a NonEmptyString is guaranteed valid
fn process_name(name: NonEmptyString) {
    // No need to check if empty---type system guarantees it
    println!(&quot;First character: {}&quot;, name.as_str().chars().next().unwrap());
}
</pre></div>

<p>This pattern, often called <a class="index-entry-id" id="index-parse_002c-don_0027t-validate"></a>
<em class="dfn">parse, don&#8217;t validate</em>, pushes validation
to the boundaries of the system. Once a value is wrapped in a validated
newtype, all subsequent code can trust its invariants without redundant checks.
</p>
<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-2_002e68a"></a>Exercise 2.68a:</strong> Design a library for working
with temperature values that supports Celsius, Fahrenheit, and Kelvin scales.
Create newtypes for each scale and implement conversions between them. Ensure
that Kelvin values cannot be negative (absolute zero is 0 K). Your implementation
should:
</p>
<ol class="enumerate">
<li> Define newtypes <code class="code">Celsius</code>, <code class="code">Fahrenheit</code>, and <code class="code">Kelvin</code>
</li><li> Implement a <code class="code">new</code> method for <code class="code">Kelvin</code> that returns <code class="code">Option&lt;Kelvin&gt;</code>
to enforce the absolute zero constraint
</li><li> Implement <code class="code">From</code> traits for conversions between all three scales
</li><li> Implement <code class="code">Display</code> to show temperatures with their unit symbols
</li><li> Demonstrate that the compiler prevents mixing different temperature scales
</li></ol>

<p>Conversion formulas:
</p><ul class="itemize mark-bullet">
<li>C = K - 273.15
</li><li>F = C × 9/5 + 32
</li><li>K = C + 273.15
</li></ul>
</blockquote>

<blockquote class="quotation">
<p><strong class="strong"><a class="anchor" id="Exercise-2_002e68b"></a>Exercise 2.68b:</strong> The <a class="index-entry-id" id="index-type-state-pattern"></a>
<em class="dfn">type state pattern</em>
uses newtypes to encode state machine transitions in the type system. Implement
a <code class="code">Connection</code> type that can be in three states: <code class="code">Disconnected</code>,
<code class="code">Connected</code>, and <code class="code">Authenticated</code>. Each state should be represented by
a different type, and methods should only be available in appropriate states:
</p>
<div class="example">
<pre class="example-preformatted">struct Connection&lt;State&gt; {
    address: String,
    state: PhantomData&lt;State&gt;,
}

// State marker types
struct Disconnected;
struct Connected;
struct Authenticated;

impl Connection&lt;Disconnected&gt; {
    fn new(address: String) -&gt; Self { /* ... */ }
    fn connect(self) -&gt; Connection&lt;Connected&gt; { /* ... */ }
}

impl Connection&lt;Connected&gt; {
    fn authenticate(self, password: &amp;str) -&gt; Option&lt;Connection&lt;Authenticated&gt;&gt; { /* ... */ }
    fn disconnect(self) -&gt; Connection&lt;Disconnected&gt; { /* ... */ }
}

impl Connection&lt;Authenticated&gt; {
    fn send_data(&amp;self, data: &amp;[u8]) { /* ... */ }
    fn disconnect(self) -&gt; Connection&lt;Disconnected&gt; { /* ... */ }
}
</pre></div>

<p>Complete the implementation so that:
</p><ol class="enumerate">
<li> <code class="code">send_data</code> is only available on authenticated connections
</li><li> <code class="code">authenticate</code> is only available on connected (but not authenticated) connections
</li><li> State transitions consume the old state and return the new state
</li><li> The compiler prevents calling methods in the wrong state
</li></ol>

<p>Demonstrate the API with example usage showing successful authentication and an
attempt to call <code class="code">send_data</code> on an unauthenticated connection (which should
fail to compile).
</p></blockquote>

<p>The newtype pattern exemplifies Rust&#8217;s approach to safety: by encoding
invariants in the type system, we move error detection from runtime to compile
time. This gives us the confidence to write complex systems knowing that entire
classes of bugs&#8212;unit confusion, identifier mix-ups, invalid state
transitions&#8212;are impossible by construction.
</p>
</div>
</div>
<div class="footnotes-segment">
<hr />
<h4 class="footnotes-heading">Footnotes</h4>

<h5 class="footnote-body-heading"><a id="FOOT91" href="#DOCF91">(91)</a></h5>
<p>Allowing quotation in a language wreaks havoc
with the ability to reason about the language in simple terms, because it
destroys the notion that equals can be substituted for equals.  For example,
three is one plus two, but the word &#8220;three&#8221; is not the phrase &#8220;one plus
two.&#8221;  Quotation is powerful because it gives us a way to build expressions
that manipulate other expressions (as we will see when we write an interpreter
in <a class="ref" href="Chapter-4.xhtml">Metalinguistic Abstraction</a>). But allowing statements in a language that talk about
other statements in that language makes it very difficult to maintain any
coherent principle of what &#8220;equals can be substituted for equals&#8221; should
mean.  For example, if we know that the evening star is the morning star, then
from the statement &#8220;the evening star is Venus&#8221; we can deduce &#8220;the morning
star is Venus.&#8221;  However, given that &#8220;John knows that the evening star is
Venus&#8221; we cannot infer that &#8220;John knows that the morning star is Venus.&#8221;</p>
<h5 class="footnote-body-heading"><a id="FOOT92" href="#DOCF92">(92)</a></h5>
<p>The
single quote is different from the double quote we have been using to enclose
character strings to be printed.  Whereas the single quote can be used to
denote lists or symbols, the double quote is used only with character strings.
In this book, the only use for character strings is as items to be printed.</p>
<h5 class="footnote-body-heading"><a id="FOOT93" href="#DOCF93">(93)</a></h5>
<p>Strictly, our use of the quotation
mark violates the general rule that all compound expressions in our language
should be delimited by parentheses and look like lists.  We can recover this
consistency by introducing a special form <code class="code">quote</code>, which serves the same
purpose as the quotation mark.  Thus, we would type <code class="code">(quote a)</code> instead of
<code class="code">'a</code>, and we would type <code class="code">(quote (a b c))</code> instead of <code class="code">'(a b c)</code>.
This is precisely how the interpreter works.  The quotation mark is just a
single-character abbreviation for wrapping the next complete expression with
<code class="code">quote</code> to form <code class="code">(quote ⟨<var class="var">expression</var>⟩)</code>.  This is
important because it maintains the principle that any expression seen by the
interpreter can be manipulated as a data object.  For instance, we could
construct the expression <code class="code">(car '(a b c))</code>, which is the same as <code class="code">(car
(quote (a b c)))</code>, by evaluating <code class="code">(list 'car (list 'quote '(a b c)))</code>.</p>
<h5 class="footnote-body-heading"><a id="FOOT94" href="#DOCF94">(94)</a></h5>
<p>We
can consider two symbols to be &#8220;the same&#8221; if they consist of the same
characters in the same order.  Such a definition skirts a deep issue that we
are not yet ready to address: the meaning of &#8220;sameness&#8221; in a programming
language.  We will return to this in <a class="ref" href="Chapter-3.xhtml">Modularity, Objects, and State</a> (<a class="ref" href="3_002e1.xhtml#g_t3_002e1_002e3">The Costs of Introducing Assignment</a>).</p>
<h5 class="footnote-body-heading"><a id="FOOT95" href="#DOCF95">(95)</a></h5>
<p>In practice,
programmers use <code class="code">equal?</code> to compare lists that contain numbers as well as
symbols.  Numbers are not considered to be symbols.  The question of whether
two numerically equal numbers (as tested by <code class="code">=</code>) are also <code class="code">eq?</code> is
highly implementation-dependent.  A better definition of <code class="code">equal?</code> (such as
the one that comes as a primitive in Scheme) would also stipulate that if
<code class="code">a</code> and <code class="code">b</code> are both numbers, then <code class="code">a</code> and <code class="code">b</code> are
<code class="code">equal?</code> if they are numerically equal.</p>
<h5 class="footnote-body-heading"><a id="FOOT96" href="#DOCF96">(96)</a></h5>
<p>If we want to be more formal, we can
specify &#8220;consistent with the interpretations given above&#8221; to mean that the
operations satisfy a collection of rules such as these:
</p>
<ul class="itemize mark-bullet">
<li>For any set <code class="code">S</code> and any object <code class="code">x</code>,
<code class="code">(element-of-set? x (adjoin-set x S))</code>
is true (informally: &#8220;Adjoining an object to a
set produces a set that contains the object&#8221;).

</li><li>For any sets <code class="code">S</code> and <code class="code">T</code> and any object <code class="code">x</code>,
<code class="code">(element-of-set? x (union-set S T))</code>
is equal to
<code class="code">(or (element-of-set? x S) (element-of-set? x T))</code>
(informally: &#8220;The elements of <code class="code">(union S T)</code> are the elements that
are in <code class="code">S</code> or in <code class="code">T</code>&#8221;).

</li><li>For any object <code class="code">x</code>,
<code class="code">(element-of-set? x '())</code>
is false (informally: &#8220;No object is an element of the empty set&#8221;).

</li></ul>
<h5 class="footnote-body-heading"><a id="FOOT97" href="#DOCF97">(97)</a></h5>
<p>Halving the size of the problem at each
step is the distinguishing characteristic of logarithmic growth, as we saw with
the fast-exponentiation algorithm of <a class="ref" href="1_002e2.xhtml#g_t1_002e2_002e4">Exponentiation</a> and the half-interval
search method of <a class="ref" href="1_002e3.xhtml#g_t1_002e3_002e3">Procedures as General Methods</a>.</p>
<h5 class="footnote-body-heading"><a id="FOOT98" href="#DOCF98">(98)</a></h5>
<p>We are representing sets in terms of trees, and trees in
terms of lists&#8212;in effect, a data abstraction built upon a data abstraction.
We can regard the procedures <code class="code">entry</code>, <code class="code">left-branch</code>,
<code class="code">right-branch</code>, and <code class="code">make-tree</code> as a way of isolating the abstraction
of a &#8220;binary tree&#8221; from the particular way we might wish to represent such a
tree in terms of list structure.</p>
<h5 class="footnote-body-heading"><a id="FOOT99" href="#DOCF99">(99)</a></h5>
<p>Examples of such structures include <a class="index-entry-id" id="index-B_002dtrees"></a>
<em class="dfn">B-trees</em> and
<a class="index-entry-id" id="index-red_002dblack-trees"></a>
<em class="dfn">red-black trees</em>.  There is a large literature on data structures
devoted to this problem.  See <a class="ref" href="References.xhtml#Cormen-et-al_002e-1990">Cormen et al. 1990</a>.</p>
<h5 class="footnote-body-heading"><a id="FOOT100" href="#DOCF100">(100)</a></h5>
<p><a class="ref" href="#Exercise-2_002e63">Exercise 2.63</a> through <a class="ref" href="#Exercise-2_002e65">Exercise 2.65</a> are due
to Paul Hilfinger.</p>
<h5 class="footnote-body-heading"><a id="FOOT101" href="#DOCF101">(101)</a></h5>
<p>See <a class="ref" href="References.xhtml#Hamming-1980">Hamming 1980</a>
for a discussion of the mathematical properties of Huffman codes.</p>
</div>
<hr />
<div class="nav-panel">
<p>
Next: <a href="2_002e4.xhtml#g_t2_002e4" accesskey="n" rel="next">Multiple Representations for Abstract Data</a>, Previous: <a href="2_002e2.xhtml#g_t2_002e2_002e5" accesskey="p" rel="prev">Algebraic Data Types</a>, Up: <a href="Chapter-2.xhtml" accesskey="u" rel="up">Building Abstractions with Data</a> &#160; [<a href="index.xhtml#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Term-Index.xhtml" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
